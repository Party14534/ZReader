<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="18">Chapter 18 <br class="calibre3"/>
One-Way Hash Functions</h1>

<h3 id="18.1" class="calibre7">18.1 Background</h3>

<p class="calibre9">A one-way hash function, <i class="calibre12">H</i>(<i class="calibre12">M</i>), operates on an arbitrary-length pre-image message, <i class="calibre12">M</i>. It returns a fixed-length hash value, <i class="calibre12">h</i>.</p>

<p class="math-left"><i class="calibre12">h</i> = H(<i class="calibre12">M</i>), where <i class="calibre12">h</i> is of length <i class="calibre12">m</i>
</p>

<p class="calibre9">Many functions can take an arbitrary-length input and return an output of fixed
length, but one-way hash functions have additional characteristics that make
them one-way [<a href="Applied%20Cryptography_split_036.html#r1065" class="calibre5 pcalibre">1065</a>]:</p>

<p class="math-left">Given <i class="calibre12">M</i>, it is easy to compute <i class="calibre12">h</i>.
Given <i class="calibre12">h</i>, it is hard to compute <i class="calibre12">M</i> such that <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">h</i>.
Given <i class="calibre12">M</i>, it is hard to find another message, M’, such that <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">H</i>(<i class="calibre12">M’</i>).
</p>

<p class="calibre9">If Mallory could do the hard things, he would undermine the security of every
protocol that uses the one-way hash function. The whole point of the one-way
hash function is to provide a “fingerprint” of <i class="calibre12">M</i> that is unique. If Alice signed <i class="calibre12">M</i> by using a digital signature algorithm on <i class="calibre12">H</i>(<i class="calibre12">M</i>), and Bob could produce <i class="calibre12">M’</i>, another message different from <i class="calibre12">M</i> where <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">H</i>(<i class="calibre12">M’</i>), then Bob could claim that Alice signed <i class="calibre12">M’</i>.</p>

<p class="calibre9">In some applications, one-wayness is insufficient; we need an additional
requirement called <b class="calibre10">collision-resistance</b>.</p>

<p class="calibre9">It is hard to find two random messages, <i class="calibre12">M</i> and <i class="calibre12">M’</i>, such that <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">H</i>(<i class="calibre12">M’</i>).</p>

<p class="calibre9">Remember the birthday attack from <a href="Applied%20Cryptography_split_009.html#7.4" class="calibre5 pcalibre">Section 7.4</a>? It is not based on finding
another message <i class="calibre12">M’</i>, such that <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">H</i>(<i class="calibre12">M’</i>), but based on finding two random messages, <i class="calibre12">M</i> and <i class="calibre12">M’</i>, such that <i class="calibre12">H</i>(<i class="calibre12">M</i>) = <i class="calibre12">H</i>(<i class="calibre12">M’</i>).</p>

<p class="calibre9">The following protocol, first described by Gideon Yuval [<a href="Applied%20Cryptography_split_036.html#r1635" class="calibre5 pcalibre">1635</a>], shows
how — if the previous requirement were not true — Alice could use the birthday
attack to swindle Bob.</p>

<ol class="calibre17">

<li class="calibre14">Alice prepares two versions of a contract: one is favorable to Bob;
the other bankrupts him.
</li>
<li class="calibre14">Alice makes several subtle changes to each document and calculates
the hash value for each. (These changes could be things like: replacing
SPACE with SPACE-BACKSPACE-SPACE, putting a space or two
before a carriage return, and so on. By either making or not making a
single change on each of 32 lines, Alice can easily generate 2<sup class="calibre19">32</sup> different
documents.)
</li>
<li class="calibre14">Alice compares the hash values for each change in each of the two
documents, looking for a pair that matches. (If the hash function only
outputs a 64-bit value, she would usually find a matching pair with 2<sup class="calibre19">32</sup>
versions of each.) She reconstructs the two documents that hash to the
same value.
</li>
<li class="calibre14">Alice has Bob sign the version of the contract that is favorable to
him, using a protocol in which he only signs the hash value.
</li>
<li class="calibre14">At some time in the future, Alice substitutes the contract Bob signed
with the one that he didn’t. Now she can convince an adjudicator that
Bob signed the other contract.
</li>

</ol>

<p class="calibre9">This is a big problem. (One moral is to always make a cosmetic change to any
document you sign.)</p>

<p class="calibre9">Other similar attacks could be mounted assuming a successful birthday attack.
For example, an adversary could send an automated control system (on a
satellite, perhaps) random message strings with random signature strings.
Eventually, one of those random messages will have a valid signature. The
adversary would have no idea what the command would do, but if his only
objective was to tamper with the satellite, this would do it.</p>

<h4 class="calibre8">Length of One-Way Hash Functions</h4>

<p class="calibre9">Hash functions of 64 bits are just too small to survive a birthday attack. Most
practical one-way hash functions produce 128-bit hashes. This forces anyone
attempting the birthday attack to hash 2<sup class="calibre19">64</sup> random documents to find two that
hash to the same value, not enough for lasting security. NIST, in its Secure
Hash Standard (SHS), uses a 160-bit hash value. This makes the birthday
attack even harder, requiring 2<sup class="calibre19">80</sup> random hashes.</p>

<p class="calibre9">The following method has been proposed to generate a longer hash value than
a given hash function produces.</p>

<ol class="calibre17">

<li class="calibre14">Generate the hash value of a message, using a one-way hash
function listed in this book.
</li>
<li class="calibre14">Prepend the hash value to the message.
</li>
<li class="calibre14">Generate the hash value of the concatenation of the message and the
hash value.
</li>
<li class="calibre14">Create a larger hash value consisting of the hash value generated in
step (1) concatenated with the hash value generated in step (3).
</li>
<li class="calibre14">Repeat steps (1) through (3) as many times as you wish,
 <i class="calibre12">concatenating</i> as you go.
</li>

</ol>

<p class="calibre9">Although this method has never been proved to be either secure or insecure,
various people have some serious reservations about it [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>,<a href="Applied%20Cryptography_split_036.html#r859" class="calibre5 pcalibre">859</a>].</p>

<h4 class="calibre8">Overview of One-Way Hash Functions</h4>

<p class="calibre9">It’s not easy to design a function that accepts an arbitrary-length input, let
alone make it one-way. In the real world, one-way hash functions are built on
the idea of a <b class="calibre10">compression function</b> . This one-way function outputs a hash
value of length <i class="calibre12">n</i> given an input of some larger length <i class="calibre12">m</i> [<a href="Applied%20Cryptography_split_036.html#r1069" class="calibre5 pcalibre">1069</a>,<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>]. The inputs to the compression function are a message block and the output of the
previous blocks of text (see Figure 18.1). The output is the hash of all blocks
up to that point. That is, the hash of block <i class="calibre12">M<sub class="calibre15">i</sub></i> is</p>

<p class="math"><i class="calibre12">h</i><sub class="calibre15">i</sub> = <i class="calibre12">f</i>(<i class="calibre12">M</i><sub class="calibre15">i</sub>, <i class="calibre12">h</i><sub class="calibre15">i</sub>- 1)
</p>

<p class="calibre9">This hash value, along with the next message block, becomes the next input to
the compression function. The hash of the entire message is the hash of the last
block.</p>

<div class="figure" id="figure-18-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-1.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.1</b> One-way function</i>.</p>
</div>

<p class="calibre9">The pre-image should contain some kind of binary representation of the length
of the entire message. This technique overcomes a potential security problem
resulting from messages with different lengths possibly hashing to the same
value [<a href="Applied%20Cryptography_split_036.html#r1069" class="calibre5 pcalibre">1069</a>,<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>]. This technique is sometimes called <b class="calibre10">MD-strengthening</b>
[<a href="Applied%20Cryptography_split_036.html#r930" class="calibre5 pcalibre">930</a>].</p>

<p class="calibre9">Various researchers have theorized that if the compression function is secure,
then this method of hashing an arbitrary-length pre-image is also secure — but
nothing has been proved [<a href="Applied%20Cryptography_split_036.html#r1138" class="calibre5 pcalibre">1138</a>,<a href="Applied%20Cryptography_split_036.html#r1070" class="calibre5 pcalibre">1070</a>,<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>].</p>

<p class="calibre9">A lot has been written on the design of one-way hash functions. For more
mathematical information, consult [<a href="Applied%20Cryptography_split_036.html#r1028" class="calibre5 pcalibre">1028</a>,<a href="Applied%20Cryptography_split_035.html#r793" class="calibre5 pcalibre">793</a>,<a href="Applied%20Cryptography_split_035.html#r791" class="calibre5 pcalibre">791</a>,<a href="Applied%20Cryptography_split_036.html#r1138" class="calibre5 pcalibre">1138</a>,<a href="Applied%20Cryptography_split_036.html#r1069" class="calibre5 pcalibre">1069</a>,<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>,<a href="Applied%20Cryptography_split_035.html#r91" class="calibre5 pcalibre">91</a>,<a href="Applied%20Cryptography_split_036.html#r858" class="calibre5 pcalibre">858</a>,<a href="Applied%20Cryptography_split_036.html#r1264" class="calibre5 pcalibre">1264</a>]. 
Bart Preneel’s thesis [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>] is probably the most comprehensive
treatment of one-way hash functions.</p>

<h3 id="18.2" class="calibre7">18.2 Snefru</h3>

<p class="calibre9">Snefru is a one-way hash function designed by Ralph Merkle [<a href="Applied%20Cryptography_split_036.html#r1070" class="calibre5 pcalibre">1070</a>]. (Snefru,
like Khufu and Khafre, was an Egyptian pharaoh.) Snefru hashes
arbitrary-length messages into either 128-bit or 256-bit values.</p>

<p class="calibre9">First the message is broken into chunks, each 512-<i class="calibre12">m</i> in length. (The variable <i class="calibre12">m</i> is the length of the hash value.) If the output is a 128-bit hash value, then the
chunks are each 384 bits long; if the output is a 256-bit hash value, then the
chunks are each 256 bits long.</p>

<p class="calibre9">The heart of the algorithm is function H, which hashes a 512-bit value into an
<i class="calibre12">m</i>-bit value. The first <i class="calibre12">m</i> bits of H’s output are the hash of the block; the rest are discarded. The next block is appended to the hash of the previous block and
hashed again. (The initial block is appended to a string of zeros.) After the last
block (if the message isn’t an integer number of blocks long, zeros are used to
pad the last block), the first <i class="calibre12">m</i> bits are appended to a binary representation of the length of the message and hashed one final time.</p>

<p class="calibre9">Function H is based on E, which is a reversible block-cipher function that
operates on 512-bit blocks. H is the last <i class="calibre12">m</i> bits of the output of E XORed with the first <i class="calibre12">m</i> bits of the input of E.</p>

<p class="calibre9">The security of Snefru resides in function E, which randomizes data in several
passes. Each pass is composed of 64 randomizing rounds. In each round a
different byte of the data is used as an input to an S-box; the output word of
the S-box is XORed with two neighboring words of the message. The S-boxes
are constructed in a manner similar to those in Khafre (see <a href="Applied%20Cryptography_split_016.html#13.7" class="calibre5 pcalibre">Section 13.7</a>).
Some rotations are thrown in, too. Originally Snefru was designed with two
passes.</p>

<h4 class="calibre8">Cryptanalysis of Snefru</h4>

<p class="calibre9">Using differential cryptanalysis, Biham and Shamir demonstrated the
insecurity of two-pass Snefru (128-bit hash value) [<a href="Applied%20Cryptography_split_035.html#r172" class="calibre5 pcalibre">172</a>]. Their attack finds
pairs of messages that hash to the same value within minutes.</p>

<p class="calibre9">On 128-bit Snefru, their attacks work better than brute force for four passes or
less. A birthday attack against Snefru takes 2<sup class="calibre19">64</sup> operations; differential
cryptanalysis can find a pair of messages that hash to the same value in 2<sup class="calibre19">28.5</sup>
operations for three-pass Snefru and 2<sup class="calibre19">44.5</sup> operations for four-pass Snefru.
Finding a message that hashes to a given value by brute force requires 2<sup class="calibre19">128</sup>
operations; differential cryptanalysis takes 2<sup class="calibre19">56</sup> operations for three-pass Snefru
and 2<sup class="calibre19">88</sup> operations for four-pass Snefru.</p>

<p class="calibre9">Although Biham and Shamir didn’t analyze 256-bit hash values, they extended
their analysis to 224-bit hash values. Compared to a birthday attack that
requires 2<sup class="calibre19">112</sup> operations, they can find messages that hash to the same value in
2<sup class="calibre19">12.5</sup> operations for two-pass Snefru, 2<sup class="calibre19">33</sup> operations for three-pass Snefru, and
2<sup class="calibre19">81</sup> operations for four-pass Snefru.</p>

<p class="calibre9">Currently, Merkle recommends using Snefru with at least eight passes [<a href="Applied%20Cryptography_split_036.html#r1073" class="calibre5 pcalibre">1073</a>].
However, with this many passes the algorithm is significantly slower than
either MD5 or SHA.</p>

<h3 id="18.3" class="calibre7">18.3 N-Hash</h3>

<p class="calibre9"><i class="calibre12">N</i>-Hash is an algorithm invented by researchers at Nippon Telephone and
Telegraph, the same people who invented FEAL, in 1990 [<a href="Applied%20Cryptography_split_036.html#r1105" class="calibre5 pcalibre">1105</a>,<a href="Applied%20Cryptography_split_036.html#r1106" class="calibre5 pcalibre">1106</a>].
<i class="calibre12">N</i>-Hash uses 128-bit message blocks, a complicated randomizing function
similar to FEAL’s, and produces a 128-bit hash value.</p>

<p class="calibre9">The hash of each 128-bit block is a function of the block and the hash of the
previous block.</p>

<p class="math-left"><i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i>, where <i class="calibre12">I</i> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">i</sub> = g(<i class="calibre12">M</i><sub class="calibre15">i</sub>, <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">The hash of the entire message is the hash of the last message block. The
random initial value, <i class="calibre12">I</i>, can be any value determined by the user (even all
zeros).</p>

<p class="calibre9">The function g is a complicated one. Figure 18.2 is an overview of the
algorithm. Initially, the 128-bit hash of the previous message block, <i class="calibre12">H</i><sub class="calibre15">i-1</sub>, has its 64-bit left half and 64-bit right half swapped; it is then XORed with a
repeating one/zero pattern (128 bits worth), and then XORed with the current
message block, <i class="calibre12">M</i><sub class="calibre15">i</sub>. This value then cascades into <i class="calibre12">N</i>(<i class="calibre12">N</i> = 8 in the figures) processing stages. The other input to the processing stage is the previous hash
value XORed with one of eight binary constant values.</p>

<div class="figure" id="figure-18-2">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-2.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.2</b> Outline of N-Hash.</i></p>
</div>

<p class="calibre9">One processing stage is given in Figure 18.3. The message block is broken into
four 32-bit values. The previous hash value is also broken into four 32-bit
values. The function f is given in Figure 18.4. Functions <i class="calibre12">S</i><sub class="calibre15">0</sub> and <i class="calibre12">S</i><sub class="calibre15">1</sub> are the same as they were in FEAL.</p>

<p class="math-left"><i class="calibre12">S</i><sub class="calibre15">0</sub>(<i class="calibre12">a,b</i>) = rotate left two bits ((<i class="calibre12">a + b</i>) mod 256)
<i class="calibre12">S</i><sub class="calibre15">1</sub>(<i class="calibre12">a,b</i>) = rotate left two bits ((<i class="calibre12">a</i> + <i class="calibre12">b</i> + 1) mod 256)
</p>

<div class="figure" id="figure-18-3">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-3.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.3</b> One processing stage of</i> N-<i class="calibre12">Hash</i>.</p>
</div>

<div class="figure" id="figure-18-4">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-4.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.4</b> Function f.</i></p>
</div>

<p class="calibre9">The output of one processing stage becomes the input to the next processing
stage. After the last processing stage, the output is XORed with the <i class="calibre12">M</i><sub class="calibre15">i</sub> and
<i class="calibre12">H</i><sub class="calibre15">i-1</sub>, and then the next block is ready to be hashed.</p>

<h4 class="calibre8">Cryptanalysis of N-Hash</h4>

<p class="calibre9">Bert den Boer discovered a way to produce collisions in the round function of
<i class="calibre12">N</i>-Hash [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>]. Biham and Shamir used differential cryptanalysis to break
6-round <i class="calibre12">N</i>-Hash [<a href="Applied%20Cryptography_split_035.html#r169" class="calibre5 pcalibre">169</a>,<a href="Applied%20Cryptography_split_035.html#r172" class="calibre5 pcalibre">172</a>]. Their particular attack (there certainly could be
others) works for any <i class="calibre12">N</i> that is divisible by 3, and is more efficient than the birthday attack for any <i class="calibre12">N</i> less than 15.</p>

<p class="calibre9">The same attack can find pairs of messages that hash to the same value for
12-round <i class="calibre12">N</i>-Hash in 2<sup class="calibre19">56</sup> operations, compared to 2<sup class="calibre19">64</sup> operations for a
brute-force attack. <i class="calibre12">N</i>-hash with 15 rounds is safe from differential
cryptanalysis: The attack requires 2<sup class="calibre19">72</sup> operations.</p>

<p class="calibre9">The algorithm’s designers recommend using <i class="calibre12">N</i>-Hash with at least 8 rounds
[<a href="Applied%20Cryptography_split_036.html#r1106" class="calibre5 pcalibre">1106</a>]. Given the proven insecurity of <i class="calibre12">N</i>-Hash and FEAL (and its speed with 8
rounds), I recommend using another algorithm entirely.</p>

<h3 id="18.4" class="calibre7">18.4 MD4</h3>

<p class="calibre9">MD4 is a one-way hash function designed by Ron Rivest [<a href="Applied%20Cryptography_split_036.html#r1318" class="calibre5 pcalibre">1318</a>,<a href="Applied%20Cryptography_split_036.html#r1319" class="calibre5 pcalibre">1319</a>,<a href="Applied%20Cryptography_split_036.html#r1321" class="calibre5 pcalibre">1321</a>].
MD stands for <b class="calibre10">Message Digest</b>; the algorithm produces a 128-bit hash, or
message digest, of the input message.</p>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_036.html#r1319" class="calibre5 pcalibre">1319</a>], Rivest outlined his design goals for the algorithm:</p>

<p class="quote"><i class="calibre12">Security</i>. It is computationally infeasible to find two messages that
hashed to the same value. No attack is more efficient than brute force. <br class="calibre3"/>
<i class="calibre12">Direct Security</i>. MD4’s security is not based on any assumption, like the
difficulty of factoring. <br class="calibre3"/>
<i class="calibre12">Speed</i>. MD4 is suitable for high-speed software implementations. It is
based on a simple set of bit manipulations on 32-bit operands. <br class="calibre3"/>
<i class="calibre12">Simplicity and Compactness</i>. MD4 is as simple as possible, without
large data structures or a complicated program. <br class="calibre3"/>
<i class="calibre12">Favor Little-Endian Architectures</i>. MD4 is optimized for
microprocessor architectures (specifically Intel microprocessors); larger
and faster computers make any necessary translations.</p>

<p class="calibre9">After the algorithm was first introduced, Bert den Boer and Antoon Bosselaers
successfully cryptanalyzed the last two of the algorithm’s three rounds [<a href="Applied%20Cryptography_split_035.html#r202" class="calibre5 pcalibre">202</a>].
In an unrelated cryptanalytic result, Ralph Merkle successfully attacked the
first two rounds [<a href="Applied%20Cryptography_split_035.html#r202" class="calibre5 pcalibre">202</a>]. Eli Biham discussed a differential cryptanalysis attack
against the first two rounds of MD4 [<a href="Applied%20Cryptography_split_035.html#r159" class="calibre5 pcalibre">159</a>]. Even though these attacks could not
be extended to the full algorithm, Rivest strengthened the algorithm. The result
is MD5.</p>

<h3 id="18.5" class="calibre7">18.5 MD5</h3>

<p class="calibre9">MD5 is an improved version of MD4 [<a href="Applied%20Cryptography_split_036.html#r1386" class="calibre5 pcalibre">1386</a>,<a href="Applied%20Cryptography_split_036.html#r1322" class="calibre5 pcalibre">1322</a>]. Although more complex
than MD4, it is similar in design and also produces a 128-bit hash.</p>

<h4 class="calibre8">Description of MD5</h4>

<p class="calibre9">After some initial processing, MD5 processes the input text in 512-bit blocks,
divided into 16 32-bit sub-blocks. The output of the algorithm is a set of four
32-bit blocks, which concatenate to form a single 128-bit hash value.</p>

<p class="calibre9">First, the message is padded so that its length is just 64 bits short of being a
multiple of 512. This padding is a single 1-bit added to the end of the message,
followed by as many zeros as are required. Then, a 64-bit representation of the
message’s length (before padding bits were added) is appended to the result.
These two steps serve to make the message length an exact multiple of 512 bits
in length (required for the rest of the algorithm), while ensuring that different
messages will not look the same after padding.</p>

<p class="calibre9">Four 32-bit variables are initialized:</p>

<pre class="calibre20"><i class="calibre22">A</i> = 0x01234567
<i class="calibre22">B</i> = 0x89abcdef
<i class="calibre22">C</i> = 0xfedcba98
<i class="calibre22">D</i> = 0x76543210
</pre>

<p class="calibre9">These are called <b class="calibre10">chaining variables</b>.</p>

<p class="calibre9">Now, the main loop of the algorithm begins. This loop continues for as many
512-bit blocks as are in the message.</p>

<p class="calibre9">The four variables are copied into different variables: <i class="calibre12">a</i> gets <i class="calibre12">A, b</i> gets <i class="calibre12">B, c</i> gets <i class="calibre12">C, </i> and <i class="calibre12">d</i> gets <i class="calibre12">D</i>.</p>

<p class="calibre9">The main loop has four rounds (MD4 had only three rounds), all very similar.
Each round uses a different operation 16 times. Each operation performs a
nonlinear function on three of <i class="calibre12">a, b, c, </i> and <i class="calibre12">d</i>. Then it adds that result to the fourth variable, a sub-block of the text and a constant. Then it rotates that
result to the right a variable number of bits and adds the result to one of <i class="calibre12">a, b, c,</i> or <i class="calibre12">d</i>. Finally the result replaces one of <i class="calibre12">a, b, c, </i> or <i class="calibre12">d</i>. See Figures 18.5 and 18.6.</p>

<div class="figure" id="figure-18-6">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-6.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.5</b> MD5 main loop.</i></p>
</div>

<div class="figure">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-6.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.6</b> One MD5 operation.</i></p>
</div>

<p class="calibre9">There are four nonlinear functions, one used in each operation (a different one
for each round).</p>

<p class="math-left">F(<i class="calibre12">X,Y,Z</i>) = (<i class="calibre12">X</i> ∧ <i class="calibre12">Y</i>) ∨ ((¬<i class="calibre12">X</i>) ∧ <i class="calibre12">Z</i>)
G(<i class="calibre12">X,Y,Z</i>) = (<i class="calibre12">X</i> ∧ <i class="calibre12">Z</i>) ¬(<i class="calibre12">Y</i> (¬<i class="calibre12">Z</i>))
H(<i class="calibre12">X,Y,Z</i>) = <i class="calibre12">X</i> ⊕ <i class="calibre12">Y</i> ⊕ <i class="calibre12">Z</i>
I(<i class="calibre12">X,Y,Z</i>) = <i class="calibre12">Y</i> ⊕ (<i class="calibre12">X</i> ∨ (¬<i class="calibre12">Z</i>))
</p>

<p class="calibre9">(⊕ is XOR, ∧ is AND, ∨ is OR, and ¬ is NOT.)</p>

<p class="calibre9">These functions are designed so that if the corresponding bits of <i class="calibre12">X, Y, </i> and <i class="calibre12">Z</i>
are independent and unbiased, then each bit of the result will also be
independent and unbiased. The function F is the bit-wise conditional: If <i class="calibre12">X</i> then
 <i class="calibre12">Y</i> else <i class="calibre12">Z</i>. The function H is the bit-wise parity operator.</p>

<p class="calibre9">If <i class="calibre12">M</i><sub class="calibre15">j</sub> represents the <i class="calibre12">j</i>th sub-block of the message (from 0 to 15), and &lt;&lt;&lt;s represents a left circular shift of <i class="calibre12">s</i> bits, the four operations are:</p>

<p class="math-left">FF(<i class="calibre12">a,b,c,d,M</i><sub class="calibre15">j</sub> <i class="calibre12">,s,t</i><sub class="calibre15">i</sub>) denotes <i class="calibre12">a</i> = <i class="calibre12">b</i> + ((<i class="calibre12">a</i> + F(<i class="calibre12">b,c,d</i>) + <i class="calibre12">M</i><sub class="calibre15">j</sub> + <i class="calibre12">t</i><sub class="calibre15">i</sub>) &lt;&lt;&lt;<i class="calibre12">s</i>)
GG(<i class="calibre12">a,b,c,d,M</i><sub class="calibre15">j</sub><i class="calibre12">,s,t</i><sub class="calibre15">i</sub>) denotes <i class="calibre12">a</i> = <i class="calibre12">b</i> + ((<i class="calibre12">a</i> + G(<i class="calibre12">b,c,d</i>) + <i class="calibre12">M</i><sub class="calibre15">j</sub> + <i class="calibre12">t</i><sub class="calibre15">i</sub>) &lt;&lt;&lt;<i class="calibre12">s</i>) 
HH(<i class="calibre12">a,b,c,d,M</i><sub class="calibre15">j</sub><i class="calibre12">,s,t</i><sub class="calibre15">i</sub>) denotes <i class="calibre12">a</i> = <i class="calibre12">b</i> + ((<i class="calibre12">a</i> + H(<i class="calibre12">b,c,d</i>) + <i class="calibre12">M</i><sub class="calibre15">j</sub> + <i class="calibre12">t</i><sub class="calibre15">i</sub>) &lt;&lt;&lt;<i class="calibre12">s</i>) 
II(<i class="calibre12">a,b,c,d,M</i><sub class="calibre15">j</sub><i class="calibre12">,s,t</i><sub class="calibre15">i</sub>) denotes <i class="calibre12">a</i> = <i class="calibre12">b</i> + ((<i class="calibre12">a</i> + I(<i class="calibre12">b,c,d</i>) + <i class="calibre12">M</i><sub class="calibre15">j</sub> + <i class="calibre12">t</i><sub class="calibre15">i</sub>) &lt;&lt;&lt;<i class="calibre12">s</i>)
</p>

<p class="calibre9">The four rounds (64 steps) look like:</p>

<pre class="calibre20"><i class="calibre22">Round 1:</i>
FF (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">0</sub>, 7, 0xd76aa478)
FF (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">1</sub>, 12, 0xe8c7b756)
FF (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">2</sub>, 17, 0x242070db)
FF (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">3</sub>, 22, 0xc1bdceee)
FF (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">4</sub>, 7, 0xf57c0faf)
FF (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">5</sub>, 12, 0x4787c62a)
FF (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">6</sub>, 17, 0xa8304613)
FF (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">7</sub>, 22, 0xfd469501)
FF (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">8</sub>, 7, 0x698098d8)
FF (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">9</sub>, 12, 0x8b44f7af)
FF (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">10</sub>, 17, 0xffff5bb1)
FF (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">11</sub>, 22, 0x895cd7be)
FF (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">12</sub>, 7, 0x6b901122)
FF (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">13</sub>, 12, 0xfd987193)
FF (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">14</sub>, 17, 0xa679438e)
FF (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">15</sub>, 22, 0x49b40821)

<i class="calibre22">Round 2:</i>
GG (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">1</sub>, 5, 0xf61e2562)
GG (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">6</sub>, 9, 0xc040b340)
GG (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">11</sub>, 14, 0x265e5a51)
GG (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">0</sub>, 20, 0xe9b6c7aa)
GG (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">5</sub>, 5, 0xd62f105d)
GG (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">10</sub>, 9, 0x02441453)
GG (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">15</sub>, 14, 0xd8a1e681)
GG (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">4</sub>, 20, 0xe7d3fbc8)
GG (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">9</sub>, 5, 0x21e1cde6)
GG (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">14</sub>, 9, 0xc33707d6)
GG (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">3</sub>, 14, 0xf4d50d87)
GG (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">8</sub>, 20, 0x455a14ed)
GG (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">13</sub>, 5, 0xa9e3e905)
GG (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">2</sub>, 9, 0xfcefa3f8)
GG (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">7</sub>, 14, 0x676f02d9)
GG (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">12</sub>, 20, 0x8d2a4c8a)

<i class="calibre22">Round 3:</i>
HH (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">5</sub>, 4, 0xfffa3942)
HH (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">8</sub>, 11, 0x8771f681)
HH (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">11</sub>, 16, 0x6d9d6122)
HH (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">14</sub>, 23, 0xfde5380c)
HH (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">1</sub>, 4, 0xa4beea44)
HH (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">4</sub>, 11, 0x4bdecfa9)
HH (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">7</sub>, 16, 0xf6bb4b60)
HH (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">10</sub>, 23, 0xbebfbc70)
HH (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">13</sub>, 4, 0x289b7ec6)
HH (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">0</sub>, 11, 0xeaa127fa)
HH (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">3</sub>, 16, 0xd4ef3085)
HH (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">6</sub>, 23, 0x04881d05)
HH (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">9</sub>, 4, 0xd9d4d039)
HH (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">12</sub>, 11, 0xe6db99e5)
HH (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">15</sub>, 16, 0x1fa27cf8)
HH (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">2</sub>, 23, 0xc4ac5665)

<i class="calibre22">Round 4:</i>
II (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">0</sub>, 6, 0xf4292244)
II (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">7</sub>, 10, 0x432aff97)
II (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">14</sub>, 15, 0xab9423a7)
II (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">5</sub>, 21, 0xfc93a039)
II (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">12</sub>, 6, 0x655b59c3)
II (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">3</sub>, 10, 0x8f0ccc92)
II (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">10</sub>, 15, 0xffeff47d)
II (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">1</sub>, 21, 0x85845dd1)
II (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">8</sub>, 6, 0x6fa87e4f)
II (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">15</sub>, 10, 0xfe2ce6e0)
II (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">6</sub>, 15, 0xa3014314)
II (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">13</sub>, 21, 0x4e0811a1)
II (<i class="calibre22">a, b, c, d, M</i><sub class="calibre15">4</sub>, 6, 0xf7537e82)
II (<i class="calibre22">d, a, b, c, M</i><sub class="calibre15">11</sub>, 10, 0xbd3af235)
II (<i class="calibre22">c, d, a, b, M</i><sub class="calibre15">2</sub>, 15, 0x2ad7d2bb)
II (<i class="calibre22">b, c, d, a, M</i><sub class="calibre15">9</sub>, 21, 0xeb86d391)
</pre>

<p class="calibre9">Those constants, <i class="calibre12">t</i><sub class="calibre15">i</sub>, were chosen as follows:</p>

<p class="calibre9">In step <i class="calibre12">i, t</i><sub class="calibre15">i</sub> is the integer part of 2<sup class="calibre19">32</sup>*abs(sin(<i class="calibre12">i</i>)), where <i class="calibre12">i</i> is in radians.</p>

<p class="calibre9">After all of this, <i class="calibre12">a, b, c, </i> and <i class="calibre12">d</i> are added to <i class="calibre12">A, B, C, D, </i> respectively, and the algorithm continues with the next block of data. The final output is the
concatenation of <i class="calibre12">A, B, C, </i> and <i class="calibre12">D</i>.</p>

<h4 class="calibre8">Security of MD5</h4>

<p class="calibre9">Ron Rivest outlined the improvements of MD5 over MD4 [<a href="Applied%20Cryptography_split_036.html#r1322" class="calibre5 pcalibre">1322</a>]:</p>

<ol class="calibre17">

<li class="calibre14">A fourth round has been added.
</li>
<li class="calibre14">Each step now has a unique additive constant.
</li>
<li class="calibre14">The function G in round 2 was changed from ((<i class="calibre12">X</i> ∧ Y ) ∨ (<i class="calibre12">X</i> ∧ Z ) ∨ (<i class="calibre12">Y</i> ∧ Z )) to ((<i class="calibre12">X</i> ∧ Z ) ∨ (<i class="calibre12">Y</i> ∧ ¬Z )) to make <i class="calibre12">G</i> less symmetric.
</li>
<li class="calibre14">Each step now adds in the result of the previous step. This promotes
a faster avalanche effect.
</li>
<li class="calibre14">The order in which message sub-blocks are accessed in rounds 2 and
3 is changed, to make these patterns less alike.
</li>
<li class="calibre14">The left circular shift amounts in each round have been
approximately optimized, to yield a faster avalanche effect. The four
shifts used in each round are different from the ones used in other
rounds.
</li>

</ol>

<p class="calibre9">Tom Berson attempted to use differential cryptanalysis against a single round
of MD5 [<a href="Applied%20Cryptography_split_035.html#r144" class="calibre5 pcalibre">144</a>], but his attack is ineffective against all four rounds. A more
successful attack by den Boer and Bosselaers produces collisions using the
compression function in MD5 [<a href="Applied%20Cryptography_split_035.html#r203" class="calibre5 pcalibre">203</a>,<a href="Applied%20Cryptography_split_036.html#r1331" class="calibre5 pcalibre">1331</a>,<a href="Applied%20Cryptography_split_036.html#r1336" class="calibre5 pcalibre">1336</a>]. This does not lend itself to
attacks against MD5 in practical applications, and it does not affect the use of
MD5 in Luby-Rackoff-like encryption algorithms (see <a href="Applied%20Cryptography_split_017.html#14.11" class="calibre5 pcalibre">Section 14.11</a>). It does
mean that one of the basic design principles of MD5 — to design a
collision-resistant compression function — has been violated. Although it is
true that “there seems to be a weakness in the compression function, but it has
no practical impact on the security of the hash function” [<a href="Applied%20Cryptography_split_036.html#r1336" class="calibre5 pcalibre">1336</a>], I am wary of
using MD5.</p>

<h3 id="18.6" class="calibre7">18.6 MD2</h3>

<p class="calibre9">MD2 is another 128-bit one-way hash function designed by Ron Rivest [<a href="Applied%20Cryptography_split_035.html#r801" class="calibre5 pcalibre">801</a>,<a href="Applied%20Cryptography_split_036.html#r1335" class="calibre5 pcalibre">1335</a>]. 
It, along with MD5, is used in the PEM protocols (see <a href="Applied%20Cryptography_split_028.html#24.10" class="calibre5 pcalibre">Section 24.10</a>).
The security of MD2 is dependent on a random permutation of bytes. This
permutation is fixed, and depends on the digits of π. <i class="calibre12">S</i><sub class="calibre15">0</sub>, <i class="calibre12">S</i><sub class="calibre15">1</sub>, <i class="calibre12">S</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">255</sub> is the permutation. To hash a message <i class="calibre12">M:</i></p>

<ol class="calibre17">

<li class="calibre14">Pad the message with <i class="calibre12">i</i> bytes of value <i class="calibre12">i</i> so that the resulting message is a multiple of 16 bytes long.
</li>
<li class="calibre14">Append a 16-byte checksum to the message.
</li>
<li class="calibre14">Initialize a 48-byte block: <i class="calibre12">X</i><sub class="calibre15">0</sub>, <i class="calibre12">X</i><sub class="calibre15">1</sub>, <i class="calibre12">X</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">X</i><sub class="calibre15">47</sub>. Set the first 16 bytes of <i class="calibre12">X</i> to be 0, the second 16 bytes of <i class="calibre12">X</i> to be the first 16 bytes of the
message, and the third 16 bytes of <i class="calibre12">X</i> to be the XOR of the first 16 bytes
of <i class="calibre12">X</i> and the second 16 bytes of <i class="calibre12">X</i>.
</li>
<li class="calibre14">This is the compression function:
<p class="math-left"><i class="calibre12">t</i> = 0
For <i class="calibre12">j</i> = 0 to 17
    For <i class="calibre12">k</i> = 0 to 47
        <i class="calibre12">t</i> = <i class="calibre12">X</i><sub class="calibre15">k</sub> XOR <i class="calibre12">S</i><sub class="calibre15">t</sub>
        <i class="calibre12">X</i><sub class="calibre15">k</sub> = t
        <i class="calibre12">t</i> = (<i class="calibre12">t + j</i>) mod 256
</p>

</li>
<li class="calibre14">Set the second 16 bytes of <i class="calibre12">X</i> to be the second 16 bytes of the
message, and the third 16 bytes of <i class="calibre12">X</i> to be the XOR of the first 16 bytes
of <i class="calibre12">X</i> and the second 16 bytes of <i class="calibre12">X</i>. Do step (4). Repeat steps (5) and (4) with every 16 bytes of the message, in turn.
</li>
<li class="calibre14">The output is the first 16 bytes of <i class="calibre12">X</i>.
</li>

</ol>

<p class="calibre9">Although no weaknesses in MD2 have been found (see [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>]), it is slower
than most other suggested hash functions.</p>

<h3 id="18.7" class="calibre7">18.7 Secure Hash Algorithm (SHA)</h3>

<p class="calibre9">NIST, along with the NSA, designed the Secure Hash Algorithm (SHA) for
use with the Digital Signature Standard (see <a href="Applied%20Cryptography_split_023.html#20.2" class="calibre5 pcalibre">Section 20.2</a>) [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>]. (The
standard is the Secure Hash Standard (SHS); SHA is the algorithm used in the
standard.) According to the <i class="calibre12">Federal Register</i> [<a href="Applied%20Cryptography_split_035.html#r539" class="calibre5 pcalibre">539</a>]:</p>

<p class="quote">A Federal Information Processing Standard (FIPS) for Secure
Hash Standard (SHS) is being proposed. This proposed standard
specified a Secure Hash Algorithm (SHA) for use with the
proposed Digital Signature Standard .... Additionally, for
applications not requiring a digital signature, the SHA is to be
used whenever a secure hash algorithm is required for Federal
applications.</p>

<p class="calibre9">And</p>

<p class="quote">This Standard specifies a Secure Hash Algorithm (SHA), which is
necessary to ensure the security of the Digital Signature
Algorithm (DSA). When a message of any length &lt; 264 bits is
input, the SHA produces a 160-bit output called a message digest.
The message digest is then input to the DSA, which computes the
signature for the message. Signing the message digest rather than
the message often improves the efficiency of the process, because
the message digest is usually much smaller than the message. The
same message digest should be obtained by the verifier of the
signature when the received version of the message is used as
input to SHA. The SHA is called secure because it is designed to
be computationally infeasible to recover a message corresponding
to a given message digest, or to find two different messages
which produce the same message digest. Any change to a
message in transit will, with a very high probability, result in a
different message digest, and the signature will fail to verify. The
SHA is based on principles similar to those used by Professor
Ronald L. Rivest of MIT when designing the MD4 message
digest algorithm [<a href="Applied%20Cryptography_split_036.html#r1319" class="calibre5 pcalibre">1319</a>], and is closely modelled after that
algorithm.</p>

<p class="calibre9">SHA produces a 160-bit hash, longer than MD5.</p>

<h4 class="calibre8">Description of SHA</h4>

<p class="calibre9">First, the message is padded to make it a multiple of 512 bits long. Padding is
exactly the same as in MD5: First append a one, then as many zeros as
necessary to make it 64 bits short of a multiple of 512, and finally a 64-bit
representation of the length of the message before padding.</p>

<p class="calibre9">Five 32-bit variables (MD5 has four variables, but this algorithm needs to
produce a 160-bit hash) are initialized as follows:</p>

<pre class="calibre20"><i class="calibre22">A</i> = 0x67452301
<i class="calibre22">B</i> = 0xefcdab89
<i class="calibre22">C</i> = 0x98badcfe
<i class="calibre22">D</i> = 0x10325476
<i class="calibre22">E</i> = 0xc3d2e1f0
</pre>

<p class="calibre9">The main loop of the algorithm then begins. It processes the message 512 bits
at a time and continues for as many 512-bit blocks as are in the message.</p>

<p class="calibre9">First the five variables are copied into different variables: <i class="calibre12">a</i> gets <i class="calibre12">A, b</i> gets <i class="calibre12">B, c</i> gets <i class="calibre12">C, d</i> gets <i class="calibre12">D, </i> and <i class="calibre12">e</i> gets <i class="calibre12">E</i>.</p>

<p class="calibre9">The main loop has four rounds of 20 operations each (MD5 has four rounds of
16 operations each). Each operation performs a nonlinear function on three of
<i class="calibre12">a, b, c, d, </i> and <i class="calibre12">e, </i> and then does shifting and adding similar to MD5.</p>

<p class="calibre9">SHA’s set of nonlinear functions is:</p>

<p class="math-left"><i class="calibre12">f</i><sub class="calibre15">t</sub>(<i class="calibre12">X,Y,Z</i>) = (<i class="calibre12">X</i> ∧ <i class="calibre12">Y</i>) ∨ ((¬X ) ∧ <i class="calibre12">Z</i>), for <i class="calibre12">t</i> = 0 to 19.
<i class="calibre12">f</i><sub class="calibre15">t</sub>(<i class="calibre12">X,Y,Z</i>) = <i class="calibre12">X</i> ⊕ <i class="calibre12">Y</i> ⊕ <i class="calibre12">Z</i>, for <i class="calibre12">t</i> = 20 to 39.
<i class="calibre12">f</i><sub class="calibre15">t</sub>(<i class="calibre12">X,Y,Z</i>) = (<i class="calibre12">X</i>∧ <i class="calibre12">Y</i>) ∨ (<i class="calibre12">X</i> ∧ <i class="calibre12">Z</i>) ∨ (<i class="calibre12">Y</i> ∧ <i class="calibre12">Z</i>), for <i class="calibre12">t</i> = 40 to 59.
<i class="calibre12">f</i><sub class="calibre15">t</sub>(<i class="calibre12">X,Y,Z</i>) = <i class="calibre12">X</i> ⊕ <i class="calibre12">Y</i> ⊕ <i class="calibre12">Z</i>, for <i class="calibre12">t</i> = 60 to 79.
</p>

<p class="calibre9">Four constants are used in the algorithm:</p>

<p class="math-left"><i class="calibre12">K</i><sub class="calibre15">t</sub> = <code class="calibre18">0x5a827999</code>, for <i class="calibre12">t</i> = 0 to 19.
<i class="calibre12">K</i><sub class="calibre15">t</sub> = <code class="calibre18">0x6ed9eba1</code>, for <i class="calibre12">t</i> = 20 to 39.
<i class="calibre12">K</i><sub class="calibre15">t</sub> = <code class="calibre18">0x8f1bbcdc</code>, for <i class="calibre12">t</i> = 40 to 59.
<i class="calibre12">K</i><sub class="calibre15">t</sub> = <code class="calibre18">0xca62c1d6</code>, for <i class="calibre12">t</i> = 60 to 79.
</p>

<p class="calibre9">(If you wonder where those numbers came from: <code class="calibre18">0x5a827999</code> = 2<sup class="calibre19">1/2</sup>/4,
<code class="calibre18">0x6ed9eba1</code> = 3<sup class="calibre19">1/2</sup>/4, <code class="calibre18">0x8f1bbcdc</code> = 5<sup class="calibre19">1/2</sup>/4, and <code class="calibre18">0xca62c1d6</code> = 10<sup class="calibre19">1/2</sup>/4; all
times 2<sup class="calibre19">32</sup>.)</p>

<p class="calibre9">The message block is transformed from 16 32-bit words (<i class="calibre12">M</i><sub class="calibre15">0</sub> to <i class="calibre12">M</i><sub class="calibre15">15</sub> ) to 80
32-bit words (<i class="calibre12">W</i><sub class="calibre15">0</sub> to <i class="calibre12">W</i><sub class="calibre15">79</sub>) using the following algorithm:</p>

<p class="math"><i class="calibre12">W</i><sub class="calibre15">t</sub> = <i class="calibre12">M</i><sub class="calibre15">t</sub>, for <i class="calibre12">t</i> = 0 to 15
<i class="calibre12">W</i><sub class="calibre15">t</sub> = (<i class="calibre12">W</i><sub class="calibre15">t - 3</sub> ⊕ <i class="calibre12">W</i><sub class="calibre15">t - 8</sub> ⊕ <i class="calibre12">W</i><sub class="calibre15">t - 14</sub> ⊕ <i class="calibre12">W</i><sub class="calibre15">t - 16</sub>) &lt;&lt;&lt; 1, for <i class="calibre12">t</i> = 16 to 79.
</p>

<p class="calibre9">(As an interesting aside, the original SHA specification did not have the left
circular shift. The change “corrects a technical flaw that made the standard less
secure than had been thought” [<a href="Applied%20Cryptography_split_035.html#r543" class="calibre5 pcalibre">543</a>]. The NSA has refused to elaborate on the
exact nature of the flaw.)</p>

<p class="calibre9">If <i class="calibre12">t</i> is the operation number (from 0 to 79), <i class="calibre12">W</i><sub class="calibre15">t</sub> represents the <i class="calibre12">t</i>th sub-block of the expanded message, and &lt;&lt;&lt; <i class="calibre12">s</i> represents a left circular shift of <i class="calibre12">s</i> bits, then the main loop looks like:</p>

<p class="math-left">FOR <i class="calibre12">t</i> = 0 to 79
    <i class="calibre12">TEMP</i> = (<i class="calibre12">a</i> &lt;&lt;&lt; 5) + <i class="calibre12">f</i><sub class="calibre15">t</sub>(<i class="calibre12">b,c,d</i>) + <i class="calibre12">e</i> + <i class="calibre12">W</i><sub class="calibre15">t</sub> + <i class="calibre12">K</i><sub class="calibre15">t</sub>
    <i class="calibre12">e</i> = <i class="calibre12">d</i>
    <i class="calibre12">d</i> = <i class="calibre12">c</i>
    <i class="calibre12">c</i> = <i class="calibre12">b</i> &lt;&lt;&lt; 30
    <i class="calibre12">b</i> = <i class="calibre12">a</i>
    <i class="calibre12">a</i> = <i class="calibre12">TEMP</i>
</p>

<p class="calibre9">Figure 18.7 shows one operation. Shifting the variables accomplishes the same
thing as MD5 does by using different variables in different locations.</p>

<div class="figure" id="figure-18-7">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-7.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.7</b> One SHA operation.</i></p>
</div>

<p class="calibre9">After all of this, <i class="calibre12">a, b, c, d, </i> and <i class="calibre12">e</i> are added to <i class="calibre12">A, B, C, D, </i> and <i class="calibre12">E</i> respectively, and the algorithm continues with the next block of data. The final output is the
concatenation of <i class="calibre12">A, B, C, D, </i> and <i class="calibre12">E</i>.</p>

<h4 class="calibre8">Security of SHA</h4>

<p class="calibre9">SHA is very similar to MD4, but has a 160-bit hash value. The main changes
are the addition of an expand transformation and the addition of the previous
step’s output into the next step for a faster avalanche effect. Ron Rivest made
public the design decisions behind MD5, but SHA’s designers did not. Here
are Rivest’s MD5 improvements to MD4 and how they compare with SHA’s:</p>

<ol class="calibre17">

<li class="calibre14">“A fourth round has been added.” SHA does this, too. However, in
SHA the fourth round uses the same f function as the second round.
</li>
<li class="calibre14">“Each step now has a unique additive constant.” SHA keeps the MD4
scheme where it reuses the constants for each group of 20 rounds.
</li>
<li class="calibre14">“The function G in round 2 was changed from ((<i class="calibre12">X</i> ∧ <i class="calibre12">Y</i>) ∨ (<i class="calibre12">X</i> ∧ <i class="calibre12">Z</i>) ∨ (<i class="calibre12">Y</i> ∧
 <i class="calibre12">Z</i>)) to ((<i class="calibre12">X</i> ∧ <i class="calibre12">Z</i>) ∨ (<i class="calibre12">Y</i> ∧ ¬(<i class="calibre12">Z</i>))) to make <i class="calibre12">G</i> less symmetric.” SHA uses the MD4 version: ((<i class="calibre12">X</i> ∧ <i class="calibre12">Y</i>) ∨ (<i class="calibre12">X</i> ∧ <i class="calibre12">Z</i>) ∨ (<i class="calibre12">Y</i> ∧ <i class="calibre12">Z</i>)).
</li>
<li class="calibre14">“Each step now adds in the result of the previous step. This promotes
a faster avalanche effect.” This change has been made in SHA as well.
The difference in SHA is that a fifth variable is added, and not <i class="calibre12">b, c, </i> or <i class="calibre12">d,</i> which is already used in <i class="calibre12">f</i><sub class="calibre15">t</sub>. This subtle change makes the den
Boer-Bosselaers attack against MD5 impossible against SHA.
</li>
<li class="calibre14">“The order in which message sub-blocks are accessed in rounds 2
and 3 is changed, to make these patterns less alike.” SHA is completely
different, since it uses a cyclic error-correcting code.
</li>
<li class="calibre14">“The left circular shift amounts in each round have been
approximately optimized, to yield a faster avalanche effect. The four
shifts used in each round are different from the ones used in other
rounds.” SHA uses a constant shift amount in each round. This shift
amount is relatively prime to the word size, as in MD4.
</li>

</ol>

<p class="calibre9">This leads to the following comparison: SHA is MD4 with the addition of an
expand transformation, an extra round, and better avalanche effect; MD5 is
MD4 with improved bit hashing, an extra round, and better avalanche effect.</p>

<p class="calibre9">There are no known cryptographic attacks against SHA. Because it produces a
160-bit hash, it is more resistant to brute-force attacks (including birthday
attacks) than 128-bit hash functions covered in this chapter.</p>

<h3 id="18.8" class="calibre7">18.8 RIPE-MD</h3>

<p class="calibre9">RIPE-MD was developed for the European Community’s RIPE project [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>]
(see <a href="Applied%20Cryptography_split_029.html#25.7" class="calibre5 pcalibre">Section 25.7</a>). The algorithm is a variation of MD4, designed to resist
known cryptanalytic attacks, and produce a 128-bit hash value. The rotations
and the order of the message words are modified. Additionally, two instances
of the algorithm, differing only in the constants, run in parallel. After each
block, the output of both instances are added to the chaining variables. This
seems to make the algorithm highly resistant to cryptanalysis.</p>

<h3 id="18.9" class="calibre7">18.9 HAVAL</h3>

<p class="calibre9">HAVAL is a variable-length one-way hash function [<a href="Applied%20Cryptography_split_036.html#r1646" class="calibre5 pcalibre">1646</a>]. It is a
modification of MD5. HAVAL processes messages in blocks of 1024 bits,
twice those of MD5. It has eight 32-bit chaining variables, twice those of
MD5. It has a variable number of rounds, from three to five (each of which has
16 steps), and it can produce a hash length of 128, 160, 192, 224, or 256 bits.</p>

<p class="calibre9">HAVAL replaces MD5’s simple nonlinear functions with highly nonlinear
7-variable functions, each of which satisfies the strict avalanche criterion. Each
round uses a single function, but in every step a different permutation is
applied to the inputs. It has a new message order and every step (except those
in the first round) uses a different additive constant. The algorithm also has
two rotations.</p>

<p class="calibre9">The core of the algorithm is</p>

<p class="math-left"><i class="calibre12">TEMP</i> = (f(<i class="calibre12">j,A,B,C,D,E,F,G</i>) &lt;&lt;&lt; 7) + (<i class="calibre12">H</i> &lt;&lt;&lt; 11) + <i class="calibre12">M</i>[<i class="calibre12">i</i>][<i class="calibre12">r</i> (<i class="calibre12">j</i>)] + <i class="calibre12">K</i>(<i class="calibre12">j</i>) 
<i class="calibre12">H</i> = <i class="calibre12">G; G</i> = <i class="calibre12">F; F</i> = <i class="calibre12">E; E</i> = <i class="calibre12">D; D</i> = <i class="calibre12">C; C</i> = <i class="calibre12">B; B</i> = <i class="calibre12">A; A</i> = <i class="calibre12">TEMP</i>
</p>

<p class="calibre9">The variable number of rounds and variable-length output mean there are 15
versions of this algorithm. Den Boer’s and Bosselaers’s attack against MD5
[<a href="Applied%20Cryptography_split_035.html#r203" class="calibre5 pcalibre">203</a>] does not apply to HAVAL because of the rotation of H.</p>

<h3 id="18.10" class="calibre7">18.10 Other One-Way Hash Functions</h3>

<p class="calibre9">MD3 is yet another hash function designed by Ron Rivest. It had several flaws
and never really made it out of the laboratory, although a description was
recently published in [<a href="Applied%20Cryptography_split_036.html#r1335" class="calibre5 pcalibre">1335</a>].</p>

<p class="calibre9">A group of researchers at the University of Waterloo have proposed a one-way
hash function based on iterated exponentiation in GF(2<sup class="calibre19">593</sup>) [<a href="Applied%20Cryptography_split_035.html#r22" class="calibre5 pcalibre">22</a>]. In this
scheme, a message is divided into 593-bit blocks; beginning with the first
block, the blocks are successively exponentiated. Each exponent is the result
of the computation with the previous block; the first exponent is given by an
IV.</p>

<p class="calibre9">Ivan Damgård designed a one-way hash function based on the knapsack
problem (see <a href="Applied%20Cryptography_split_022.html#19.2" class="calibre5 pcalibre">Section 19.2</a>) [<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>]; it can be broken in about 2<sup class="calibre19">32</sup> operations
[<a href="Applied%20Cryptography_split_035.html#r290" class="calibre5 pcalibre">290</a>,<a href="Applied%20Cryptography_split_036.html#r1232" class="calibre5 pcalibre">1232</a>,<a href="Applied%20Cryptography_split_035.html#r787" class="calibre5 pcalibre">787</a>].</p>

<p class="calibre9">Steve Wolfram’s cellular automata [<a href="Applied%20Cryptography_split_036.html#r1608" class="calibre5 pcalibre">1608</a>] have been proposed as a basis for
one-way hash functions. An early implementation [<a href="Applied%20Cryptography_split_035.html#r414" class="calibre5 pcalibre">414</a>] is insecure [<a href="Applied%20Cryptography_split_036.html#r1052" class="calibre5 pcalibre">1052</a>,<a href="Applied%20Cryptography_split_035.html#r404" class="calibre5 pcalibre">404</a>]. 
Another one-way hash function, Cellhash [<a href="Applied%20Cryptography_split_035.html#r384" class="calibre5 pcalibre">384</a>,<a href="Applied%20Cryptography_split_035.html#r404" class="calibre5 pcalibre">404</a>], and an improved
version, Subhash [<a href="Applied%20Cryptography_split_035.html#r384" class="calibre5 pcalibre">384</a>,<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>,<a href="Applied%20Cryptography_split_035.html#r405" class="calibre5 pcalibre">405</a>], are based on cellular automata; both are
designed for hardware. Boognish mixes the design principles of Cellhash with
those of MD4 [<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>,<a href="Applied%20Cryptography_split_035.html#r407" class="calibre5 pcalibre">407</a>]. StepRightUp can be implemented as a hash function
as well [<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>].</p>

<p class="calibre9">Claus Schnorr proposed a one-way hash function based on the discrete Fourier
transform, called FFT-Hash, in the summer of 1991 [<a href="Applied%20Cryptography_split_036.html#r1399" class="calibre5 pcalibre">1399</a>]; it was broken a
few months later by two independent groups [<a href="Applied%20Cryptography_split_035.html#r403" class="calibre5 pcalibre">403</a>,<a href="Applied%20Cryptography_split_035.html#r84" class="calibre5 pcalibre">84</a>]. Schnorr proposed a
revised version, called FFT-Hash II (the previous version was renamed
FFT-Hash I) [<a href="Applied%20Cryptography_split_036.html#r1400" class="calibre5 pcalibre">1400</a>], which was broken a few weeks later [<a href="Applied%20Cryptography_split_036.html#r1567" class="calibre5 pcalibre">1567</a>]. Schnorr has
proposed further modifications [<a href="Applied%20Cryptography_split_036.html#r1402" class="calibre5 pcalibre">1402</a>,<a href="Applied%20Cryptography_split_036.html#r1403" class="calibre5 pcalibre">1403</a>] but, as it stands, the algorithm is
much slower than the others in this chapter. Another hash function, called <i class="calibre12">SL</i><sub class="calibre15">2</sub>
[<a href="Applied%20Cryptography_split_036.html#r1526" class="calibre5 pcalibre">1526</a>], is insecure [<a href="Applied%20Cryptography_split_035.html#r315" class="calibre5 pcalibre">315</a>].</p>

<p class="calibre9">Additional theoretical work on constructing one-way hash functions from
one-way functions and one-way permutations can be found in [<a href="Applied%20Cryptography_split_035.html#r412" class="calibre5 pcalibre">412</a>,<a href="Applied%20Cryptography_split_036.html#r1138" class="calibre5 pcalibre">1138</a>,<a href="Applied%20Cryptography_split_036.html#r1342" class="calibre5 pcalibre">1342</a>].</p>

<h3 id="18.11" class="calibre7">18.11 One-Way Hash Functions Using Symmetric Block Algorithms</h3>

<p class="calibre9">It is possible to use a symmetric block cipher algorithm as a one-way hash
function. The idea is that if the block algorithm is secure, then the one-way
hash function will also be secure.</p>

<p class="calibre9">The most obvious method is to encrypt the message with the algorithm in CBC
or CFB mode, a fixed key, and IV; the last ciphertext block is the hash value.
These methods are described in various standards using DES: both modes in
[<a href="Applied%20Cryptography_split_036.html#r1143" class="calibre5 pcalibre">1143</a>], CFB in [<a href="Applied%20Cryptography_split_036.html#r1145" class="calibre5 pcalibre">1145</a>], CBC in [<a href="Applied%20Cryptography_split_035.html#r55" class="calibre5 pcalibre">55</a>,<a href="Applied%20Cryptography_split_035.html#r56" class="calibre5 pcalibre">56</a>,<a href="Applied%20Cryptography_split_035.html#r54" class="calibre5 pcalibre">54</a>]. This just isn’t good enough for
one-way hash functions, although it will work for a MAC (see <a href="#18.14" class="calibre5 pcalibre">Section 18.14</a>) [<a href="Applied%20Cryptography_split_035.html#r29" class="calibre5 pcalibre">29</a>].</p>

<p class="calibre9">A cleverer approach uses the message block as the key, the previous hash
value as the input, and the current hash value as the output.</p>

<p class="calibre9">The actual hash functions proposed are even more complex. The block size is
usually the key length, and the size of the hash value is the block size. Since
most block algorithms are 64 bits, several schemes are designed around a hash
that is twice the block size.</p>

<p class="calibre9">Assuming the hash function is correct, the security of the scheme is based on
the security of the underlying block function. There are exceptions, though.
Differential cryptanalysis is easier against block functions in hash functions
than against block functions used for encryption: The key is known, so several
tricks can be applied; only one right pair is needed for success; and you can
generate as much chosen plaintext as you want. Some work on these lines is
[<a href="Applied%20Cryptography_split_036.html#r1263" class="calibre5 pcalibre">1263</a>,<a href="Applied%20Cryptography_split_036.html#r858" class="calibre5 pcalibre">858</a>,<a href="Applied%20Cryptography_split_036.html#r1313" class="calibre5 pcalibre">1313</a>].</p>

<p class="calibre9">What follows is a summary of the various hash functions that have appeared in
the literature [<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>,<a href="Applied%20Cryptography_split_036.html#r1465" class="calibre5 pcalibre">1465</a>,<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>]. Statements about attacks against these
schemes assume that the underlying block cipher is secure; that is, the best
attack against them is brute force.</p>

<p class="calibre9">One useful measure for hash functions based on block ciphers is the <b class="calibre10">hash rate</b>,
or the number of <i class="calibre12">n</i>-bit messages blocks, where <i class="calibre12">n</i> is the block size of the algorithm, processed per encryption. The higher the hash rate, the faster the
algorithm. (This measure was given the opposite definition in [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>], but the
definition given here is more intuitive and is more widely used. This can be
confusing.)</p>

<h4 class="calibre8">Schemes Where the Hash Length Equals the Block Size</h4>

<p class="calibre9">The general scheme is as follows (see Figure 18.8):</p>

<p class="math-left">
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">B</i>) ⊕ <i class="calibre12">C</i>
</p>

<p class="calibre9">where <i class="calibre12">A, B, </i> and <i class="calibre12">C</i> can be either <i class="calibre12">M</i><sub class="calibre15">i</sub>, <i class="calibre12">H</i><sub class="calibre15">-1</sub>, (<i class="calibre12">M</i><sub class="calibre15">i</sub> • <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>), or a constant (assumed to be 0). <i class="calibre12">H</i><sub class="calibre15">0</sub> is some random initial value: <i class="calibre12">I</i><sub class="calibre15">H</sub>. The message is divided up into block-size chunks, <i class="calibre12">M</i><sub class="calibre15">i</sub>, and processed individually. And there is some kind of
MD-strengthening, perhaps the same padding procedure used in MD5 and
SHA.</p>

<div class="figure" id="figure-18-8">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-8.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.8</b> General hash function where the hash length equals the block size.</i></p>
</div>

<p class="calibre9">The three different variables can take on one of four possible values, so there
are 64 total schemes of this type. Bart Preneel studied them all [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>].</p>

<p class="calibre9">Fifteen are trivially weak because the result does not depend on one of the
inputs. Thirty-seven are insecure for more subtle reasons. Table 18.1 lists the
12 secure schemes remaining: The first 4 are secure against all attacks (see
Figure 18.9) and the last 8 are secure against all but a fixed-point attack, which
is not really worth worrying about.</p>

<p id="table-18-1" class="calibre9"><b class="calibre10">Table 18.1</b> - Secure Hash Functions Where the Block Length Equals the Hash Size</p>
<hr class="calibre63"/>
<p class="math-left">
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">H<sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">H<sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">H<sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">H<sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
</p>
<hr class="calibre63"/>

<div class="figure" id="figure-18-9">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-9.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.9</b> The four secure hash functions where the block length equals the hash size.</i></p>
</div>

<p class="calibre9">The first scheme was described in [<a href="Applied%20Cryptography_split_036.html#r1028" class="calibre5 pcalibre">1028</a>]. The third scheme was described in
[<a href="Applied%20Cryptography_split_036.html#r1555" class="calibre5 pcalibre">1555</a>,<a href="Applied%20Cryptography_split_036.html#r1105" class="calibre5 pcalibre">1105</a>,<a href="Applied%20Cryptography_split_036.html#r1106" class="calibre5 pcalibre">1106</a>] and was proposed as an ISO standard [<a href="Applied%20Cryptography_split_035.html#r766" class="calibre5 pcalibre">766</a>]. The fifth
scheme was proposed by Carl Meyer, but is commonly called Davies-Meyer in
the literature [<a href="Applied%20Cryptography_split_036.html#r1606" class="calibre5 pcalibre">1606</a>,<a href="Applied%20Cryptography_split_036.html#r1607" class="calibre5 pcalibre">1607</a>,<a href="Applied%20Cryptography_split_035.html#r434" class="calibre5 pcalibre">434</a>,<a href="Applied%20Cryptography_split_036.html#r1028" class="calibre5 pcalibre">1028</a>]. The tenth scheme was proposed as a
hash-function mode for LOKI [<a href="Applied%20Cryptography_split_035.html#r273" class="calibre5 pcalibre">273</a>].</p>

<p class="calibre9">The first, second, third, fourth, ninth, and eleventh schemes have a hash rate of
1; the key length equals the block length. The others have a rate of <i class="calibre12">k/n, </i> where <i class="calibre12">k</i> is the key length. This means that if the key length is shorter than the block
length, then the message block can only be the length of the key. It is not
recommended that the message block be longer than the key length, even if the
encryption algorithm’s key length is longer than the block length.</p>

<p class="calibre9">If the block algorithm has a DES-like complementation property and DES-like
weak keys, there is an additional attack that is possible against all 12 schemes.
The attack isn’t very dangerous and not really worth worrying about.
However, you can solve it by fixing bits 2 and 3 of the key to “01” or “10”
[<a href="Applied%20Cryptography_split_036.html#r1081" class="calibre5 pcalibre">1081</a>,<a href="Applied%20Cryptography_split_036.html#r1107" class="calibre5 pcalibre">1107</a>]. Of course, this reduces the length of <i class="calibre12">k</i> from 56 bits to 54 bits (in DES, for example) and decreases the hash rate.</p>

<p class="calibre9">The following schemes, proposed in the literature, have been shown to be
insecure.</p>

<p class="calibre9">This scheme [<a href="Applied%20Cryptography_split_036.html#r1282" class="calibre5 pcalibre">1282</a>] was broken in [<a href="Applied%20Cryptography_split_035.html#r369" class="calibre5 pcalibre">369</a>]:</p>

<p class="math"><i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>)
</p>

<p class="calibre9">Davies and Price proposed a variant which cycles the entire message through
the algorithm twice [<a href="Applied%20Cryptography_split_035.html#r432" class="calibre5 pcalibre">432</a>,<a href="Applied%20Cryptography_split_035.html#r433" class="calibre5 pcalibre">433</a>]. Coppersmith’s attack works on this variant
with not much larger computational requirements [<a href="Applied%20Cryptography_split_035.html#r369" class="calibre5 pcalibre">369</a>].</p>

<p class="calibre9">Another scheme [<a href="Applied%20Cryptography_split_035.html#r432" class="calibre5 pcalibre">432</a>,<a href="Applied%20Cryptography_split_035.html#r458" class="calibre5 pcalibre">458</a>] was shown insecure in [<a href="Applied%20Cryptography_split_036.html#r1606" class="calibre5 pcalibre">1606</a>]:</p>

<p class="math"><i class="calibre12">Hi</i> = <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub> ⊕ H<sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>)
</p>

<p class="calibre9">This scheme was shown insecure in [<a href="Applied%20Cryptography_split_036.html#r1028" class="calibre5 pcalibre">1028</a>] (<i class="calibre12">c</i> is a constant):</p>

<p class="math"><i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">c</sub>(<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
</p>

<h4 class="calibre8">Modified Davies-Meyer</h4>

<p class="calibre9">Lai and Massey modified the Davies-Meyer technique to work with the IDEA
cipher [<a href="Applied%20Cryptography_split_036.html#r930" class="calibre5 pcalibre">930</a>,<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>]. IDEA has a 64-bit block size and 128-bit key size. Their
scheme is</p>

<p class="math-left"><i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">H<sub class="calibre16">i- 1</sub>,M<sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>)
</p>

<p class="calibre9">This function hashes the message in blocks of 64 bits and produces a 64-bit
hash value (See Figure 18.10).</p>

<p class="calibre9">No known attack on this scheme is easier than brute force.</p>

<div class="figure" id="figure-18-10">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-10.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.10</b> Modified Davies-Meyer.</i></p>
</div>

<h4 class="calibre8">Preneel-Bosselaers-Govaerts-Vandewalle</h4>

<p class="calibre9">This hash function, first proposed in [<a href="Applied%20Cryptography_split_036.html#r1266" class="calibre5 pcalibre">1266</a>], produces a hash value twice the
block length of the encryption algorithm: A 64-bit algorithm produces a
128-bit hash.</p>

<p class="calibre9">With a 64-bit block algorithm, the scheme produces two 64-bit hash values, <i class="calibre12">G</i><sub class="calibre15">i</sub> and <i class="calibre12">H</i><sub class="calibre15">i</sub>, which are concatenated to produce the 128-bit hash. With most block
algorithms, the block size is 64 bits. Two adjacent message blocks, <i class="calibre12">L</i><sub class="calibre15">i</sub> and <i class="calibre12">R</i><sub class="calibre15">i</sub>, each the size of the block length, are hashed together.</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is another random initial value
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">R</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub> ⊕ <i class="calibre22">R</i><sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub>) ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">Lai demonstrates attacks against this scheme that, in some instances, make the
birthday attack trivially solvable [<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>,<a href="Applied%20Cryptography_split_036.html#r926" class="calibre5 pcalibre">926</a>]. Preneel [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>] and Coppersmith
[<a href="Applied%20Cryptography_split_035.html#r372" class="calibre5 pcalibre">372</a>] also have successful attacks against this scheme. Do not use it.</p>

<h4 class="calibre8">Quisquater-Girault</h4>

<p class="calibre9">This scheme, first proposed in [<a href="Applied%20Cryptography_split_036.html#r1279" class="calibre5 pcalibre">1279</a>], generates a hash that is twice the block
length and has a hash rate of 1. It has two hash values, <i class="calibre12">G</i><sub class="calibre15">i</sub> and <i class="calibre12">H</i><sub class="calibre15">i</sub>, and two blocks, <i class="calibre12">L</i><sub class="calibre15">i</sub> and <i class="calibre12">R</i><sub class="calibre15">i</sub>, are hashed together.</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is another random initial value
<i class="calibre12">W</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub></sub>(<i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">R<sub class="calibre16">i</sub></sub>(<i class="calibre12">W</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">W</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">This scheme appeared in a 1989 draft ISO standard [<a href="Applied%20Cryptography_split_035.html#r764" class="calibre5 pcalibre">764</a>], but was dropped in
a later version [<a href="Applied%20Cryptography_split_035.html#r765" class="calibre5 pcalibre">765</a>]. Security problems with this scheme were identified in
[<a href="Applied%20Cryptography_split_036.html#r1107" class="calibre5 pcalibre">1107</a>, <a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>, <a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>, <a href="Applied%20Cryptography_split_035.html#r372" class="calibre5 pcalibre">372</a>]. (Actually, the version in the proceedings was
strengthened after the version presented at the conference was attacked.) In
some instances the birthday attack is solvable with a complexity of 2<sup class="calibre19">39</sup>, not
2<sup class="calibre19">64</sup>, through brute force. Do not use this scheme.</p>

<h4 class="calibre8">LOKI Double-Block</h4>

<p class="calibre9">This algorithm is a modification of Quisquater-Girault, specifically designed to
work with LOKI [<a href="Applied%20Cryptography_split_035.html#r273" class="calibre5 pcalibre">273</a>]. All parameters are as in Quisquater-Girault.</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is another random initial value
<i class="calibre12">W</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub> ⊕ <i class="calibre22">G</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">R<sub class="calibre16">i</sub> ⊕ <i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(<i class="calibre12">W</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">W</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">G</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">Again, in some instances the birthday attack is trivially solvable [<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>,<a href="Applied%20Cryptography_split_036.html#r926" class="calibre5 pcalibre">926</a>,<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>,<a href="Applied%20Cryptography_split_035.html#r372" class="calibre5 pcalibre">372</a>,<a href="Applied%20Cryptography_split_035.html#r736" class="calibre5 pcalibre">736</a>]. Do not use this scheme.</p>

<h4 class="calibre8">Parallel Davies-Meyer</h4>

<p class="calibre9">This is yet another attempt at an algorithm with a hash rate of 1 that produces a
hash twice the block length [<a href="Applied%20Cryptography_split_035.html#r736" class="calibre5 pcalibre">736</a>].</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is a random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is another random initial value
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub> ⊕ <i class="calibre22">R</i><sub class="calibre16">i</sub></sub>(<i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">L</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">L<sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">R</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">Unfortunately, this scheme isn’t secure either [<a href="Applied%20Cryptography_split_036.html#r928" class="calibre5 pcalibre">928</a>,<a href="Applied%20Cryptography_split_036.html#r861" class="calibre5 pcalibre">861</a>]. As it turns out, a
double-length hash function with a hash rate of 1 cannot be more secure than
Davies-Meyer [<a href="Applied%20Cryptography_split_036.html#r861" class="calibre5 pcalibre">861</a>].</p>

<h4 class="calibre8">Tandem and Abreast Davies-Meyer</h4>

<p class="calibre9">Another way around the inherent limitations of a block cipher with a 64-bit
key uses an algorithm, like IDEA (see <a href="Applied%20Cryptography_split_016.html#13.9" class="calibre5 pcalibre">Section 13.9</a>), with a 64-bit block and a
128-bit key. These two schemes produce a 128-bit hash value and have a hash
rate of ½ [<a href="Applied%20Cryptography_split_036.html#r930" class="calibre5 pcalibre">930</a>,<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>].</p>

<div class="figure" id="figure-18-11">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-11.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.11</b> Tandem Davies-Meyer.</i></p>
</div>

<p class="calibre9">In this first scheme, two modified Davies-Meyer functions work in tandem
(see Figure 18.11).</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is some random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is some other random initial value
<i class="calibre12">W</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">G<sub class="calibre16">i- 1</sub>,<i class="calibre22">M</i><sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>)
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub>,<i class="calibre22">W</i><sub class="calibre16">i</sub></sub>(<i class="calibre12">G</i><sub class="calibre15">i - 1</sub>)
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">W</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>
</p>

<div class="figure" id="figure-18-12">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-12.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.12</b> Abreast Davies-Meyer.</i></p>
</div>

<p class="calibre9">The following scheme uses two modified Davies-Meyer functions side-by-side
(see Figure 18.12).</p>

<p class="math-left"><i class="calibre12">G</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">G</sub>, where <i class="calibre12">I</i><sub class="calibre15">G</sub> is some random initial value
<i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is some other random initial value
<i class="calibre12">G</i><sub class="calibre15">i</sub> = <i class="calibre12">G</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">E</i><sub class="calibre15">M<sub class="calibre16">i</sub>,<i class="calibre22">H</i><sub class="calibre16">i - 1</sub></sub>(¬<i class="calibre12">G</i><sub class="calibre15">i - 1</sub>)
<i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">E</i><sub class="calibre15">G<sub class="calibre16">i- 1</sub>,<i class="calibre22">M</i><sub class="calibre16">i</sub></sub>(<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>)
</p>

<p class="calibre9">In both schemes, the two 64-bit hash values <i class="calibre12">G</i><sub class="calibre15">i</sub> and <i class="calibre12">H</i><sub class="calibre15">i</sub> are concatenated to produce a single 128-bit hash.</p>

<p class="calibre9">As far as anyone knows, these algorithms have ideal security for a 128-bit hash
function: Finding a message that hashes to a given hash value requires 2<sup class="calibre19">128</sup>
attempts, and finding two random messages that hash to the same value
requires 2<sup class="calibre19">64</sup> attempts — assuming that there is no better way to attack the block
algorithm than by using brute force.</p>

<h4 class="calibre8">MDC-2 and MDC-4</h4>

<p class="calibre9">MDC-2 and MDC-4 were first developed at IBM [<a href="Applied%20Cryptography_split_036.html#r1081" class="calibre5 pcalibre">1081</a>,<a href="Applied%20Cryptography_split_036.html#r1079" class="calibre5 pcalibre">1079</a>]. MDC-2,
sometimes called Meyer-Schilling, is under consideration as an ANSI and ISO
standard [<a href="Applied%20Cryptography_split_035.html#r61" class="calibre5 pcalibre">61</a>,<a href="Applied%20Cryptography_split_035.html#r765" class="calibre5 pcalibre">765</a>]; a variant was proposed in [<a href="Applied%20Cryptography_split_035.html#r762" class="calibre5 pcalibre">762</a>]. MDC-4 is specified for
the RIPE project [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>] (see <a href="Applied%20Cryptography_split_029.html#25.7" class="calibre5 pcalibre">Section 25.7</a>). The specifications use DES as the
block function, although in theory any encryption algorithm could be used.</p>

<p class="calibre9">MDC-2 has a hash rate of ½, and produces a hash value twice the length of the
block size. It is shown in Figure 18.13. MDC-4 also produces a hash value
twice the length of the block size, and has a hash rate of ¼ (see Figure 18.14).</p>

<div class="figure" id="figure-18-13">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-13.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.13</b> MDC-2.</i></p>
</div>

<div class="figure" id="figure-18-14">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-14.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.14</b> MDC-4.</i></p>
</div>

<p class="calibre9">These schemes have been analyzed in [<a href="Applied%20Cryptography_split_036.html#r925" class="calibre5 pcalibre">925</a>,<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>]. They are secure against
current computing power, but they are not nearly as secure as the designers
have estimated. If the block algorithm is DES, they have been looked at with
respect to differential cryptanalysis [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>].</p>

<p class="calibre9">Both MDC-2 and MDC-4 are patented [<a href="Applied%20Cryptography_split_035.html#r223" class="calibre5 pcalibre">223</a>].</p>

<h4 class="calibre8">AR Hash Function</h4>

<p class="calibre9">The AR hash function was developed by Algorithmic Research, Ltd. and has
been distributed by the ISO for information purposes only [<a href="Applied%20Cryptography_split_035.html#r767" class="calibre5 pcalibre">767</a>]. Its basic
structure is a variant of the underlying block cipher (DES in the reference) in
CBC mode. The last two ciphertext blocks and a constant are XORed to the
current message block and encrypted by the algorithm. The hash is the last two
ciphertext blocks computed. The message is processed twice, with two
different keys, so the hash function has a hash rate of ½. The first key is
<code class="calibre18">0x0000000000000000</code>, the second key is <code class="calibre18">0x2a41522f4446502a</code>, and c is
<code class="calibre18">0x0123456789abcdef</code>. The result is compressed to a single 128-bit hash value.
See [<a href="Applied%20Cryptography_split_035.html#r750" class="calibre5 pcalibre">750</a>] for the details.</p>

<p class="math"><i class="calibre12">H</i><sub class="calibre15">i</sub> = <i class="calibre12">E</i><sub class="calibre15">K</sub> (<i class="calibre12">M</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">H</i><sub class="calibre15">i - 2</sub> ⊕ <i class="calibre12">c</i>) ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>
</p>

<p class="calibre9">This sounds interesting, but it is insecure. After considerable preprocessing, it
is possible to find collisions for this hash function easily [<a href="Applied%20Cryptography_split_035.html#r416" class="calibre5 pcalibre">416</a>].</p>

<h4 class="calibre8">GOST Hash Function</h4>

<p class="calibre9">This hash function comes from Russia, and is specified in the standard GOST
R 34.11-94 [<a href="Applied%20Cryptography_split_035.html#r657" class="calibre5 pcalibre">657</a>]. It uses the GOST block algorithm (see <a href="Applied%20Cryptography_split_017.html#14.1" class="calibre5 pcalibre">Section 14.1</a>),
although in theory it could use any block algorithm with a 64-bit block size
and a 256-bit key. The function produces a 256-bit hash value.</p>

<p class="calibre9">The compression function, <i class="calibre12">H</i><sub class="calibre15">i</sub> = f(<i class="calibre12">M</i><sub class="calibre15">i</sub><i class="calibre12">,H</i><sub class="calibre15">i - 1</sub>) (both operands are 256-bit quantities) is defined as follows:</p>

<ol class="calibre17">

<li class="calibre14">Generate four GOST encryption keys by some linear mixing of <i class="calibre12">M</i><sub class="calibre15">i</sub>,
<i class="calibre12">H</i><sub class="calibre15">i - 1</sub>, and some constants.
</li>
<li class="calibre14">Use each key to encrypt a different 64 bits of <i class="calibre12">H</i><sub class="calibre15">i - 1</sub> in ECB mode.
Store the resulting 256 bits into a temporary variable, <i class="calibre12">S</i>.
</li>
<li class="calibre14"><i class="calibre12">H</i><sub class="calibre15">i</sub> is a complex, although linear, function of <i class="calibre12">S, M</i><sub class="calibre15">i</sub>, and <i class="calibre12">H</i><sub class="calibre15">i - 1</sub>.
</li>

</ol>

<p class="calibre9">The final hash of <i class="calibre12">M</i> is not the hash of the last block. There are actually three chaining variables: <i class="calibre12">H</i><sub class="calibre15">n</sub> is the hash of the last message block, <i class="calibre12">Z</i> is the sum mod 2256 of all the message blocks, and <i class="calibre12">L</i> is the length of the message. Given those variables and the padded last block, <i class="calibre12">M' </i>, the final hash value is:</p>

<p class="math"><i class="calibre12">H</i> = f(<i class="calibre12">Z</i> ⊕ <i class="calibre12">M' </i>, f(<i class="calibre12">L,</i> f(<i class="calibre12">M’</i>, <i class="calibre12">H</i><sub class="calibre15">n</sub>)))
</p>

<p class="calibre9">The documentation is a bit confusing (and in Russian), but I think all that is
correct. In any case, this hash function is specified for use with the Russian
Digital Signature Standard (see <a href="Applied%20Cryptography_split_023.html#20.3" class="calibre5 pcalibre">Section 20.3</a>).</p>

<h4 class="calibre8">Other Schemes</h4>

<p class="calibre9">Ralph Merkle proposed a scheme using DES, but it’s slow; it only processes
seven message bits per iteration and each iteration involves two DES
encryptions [<a href="Applied%20Cryptography_split_036.html#r1065" class="calibre5 pcalibre">1065</a>,<a href="Applied%20Cryptography_split_036.html#r1069" class="calibre5 pcalibre">1069</a>]. Another scheme [<a href="Applied%20Cryptography_split_036.html#r1642" class="calibre5 pcalibre">1642</a>,<a href="Applied%20Cryptography_split_036.html#r1645" class="calibre5 pcalibre">1645</a>] is insecure [<a href="Applied%20Cryptography_split_036.html#r1267" class="calibre5 pcalibre">1267</a>]; it
was once proposed as an ISO standard.</p>

<h3 id="18.12" class="calibre7">18.12 Using Public-Key Algorithms</h3>

<p class="calibre9">It is possible to use a public-key encryption algorithm in a block chaining
mode as a one-way hash function. If you then throw away the private key,
breaking the hash would be as difficult as reading the message without the
private key.</p>

<p class="calibre9">Here’s an example using RSA. If <i class="calibre12">M</i> is the message to be hashed, <i class="calibre12">n</i> is the product of two primes <i class="calibre12">p</i> and <i class="calibre12">q, </i> and <i class="calibre12">e</i> is another large number relatively prime to (<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1), then the hash function, H(<i class="calibre12">M</i>), would be</p>

<p class="math">H(<i class="calibre12">M</i>) = <i class="calibre12">M<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">An even easier solution would be to use a single strong prime as the modulus
<i class="calibre12">p</i>. Then:</p>

<p class="math">H(<i class="calibre12">M</i>) = <i class="calibre12">M<sup class="calibre19">e</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">Breaking this problem is probably as difficult as finding the discrete logarithm
of <i class="calibre12">e</i>. The problem with this algorithm is that it’s far slower than any others
discussed here. I don’t recommend it for that reason.</p>

<h3 id="18.13" class="calibre7">18.13 Choosing a One-Way Hash Function</h3>

<p class="calibre9">The contenders seem to be SHA, MD5, and constructions based on block
ciphers; the others really haven’t been studied enough to be in the running. I
vote for SHA. It has a longer hash value than MD5, is faster than the various
block-cipher constructions, and was developed by the NSA. I trust the NSA’s
abilities at cryptanalysis, even if they don’t make their results public.</p>

<p class="calibre9">Table 18.2 gives timing measurements for some hash functions. They are
meant for comparison purposes only.</p>

<table class="data-table1" id="table-18-2">
<caption class="calibre67">Table 18.2 - Speeds of Some Hash Functions on a 33 MHz 486SX</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Algorithm</th>
<th class="calibre26">Hash Length</th>
<th class="calibre26">Encryption Speed (kilobytes/second)</th>
</tr>
<tr class="calibre25"><td class="calibre61">Abreast Davies-Meyer (with IDEA)</td><td class="calibre70">128</td><td class="calibre70">22</td></tr>
<tr class="calibre25"><td class="calibre61">Davies-Meyer (with DES)</td><td class="calibre70">64</td><td class="calibre70">9</td></tr>
<tr class="calibre25"><td class="calibre61">GOST Hash</td><td class="calibre70">256</td><td class="calibre70">11</td></tr>
<tr class="calibre25"><td class="calibre61">HAVAL (3 passes)</td><td class="calibre70">variable</td><td class="calibre70">168</td></tr>
<tr class="calibre25"><td class="calibre61">HAVAL (4 passes)</td><td class="calibre70">variable</td><td class="calibre70">118</td></tr>
<tr class="calibre25"><td class="calibre61">HAVAL (5 passes)</td><td class="calibre70">variable</td><td class="calibre70">95</td></tr>
<tr class="calibre25"><td class="calibre61">MD2</td><td class="calibre70">128</td><td class="calibre70">23</td></tr>
<tr class="calibre25"><td class="calibre61">MD4</td><td class="calibre70">128</td><td class="calibre70">236</td></tr>
<tr class="calibre25"><td class="calibre61">MD5</td><td class="calibre70">128</td><td class="calibre70">174</td></tr>
<tr class="calibre25"><td class="calibre61">N-HASH (12 rounds)</td><td class="calibre70">128</td><td class="calibre70">29</td></tr>
<tr class="calibre25"><td class="calibre61">N-HASH (15 rounds)</td><td class="calibre70">128</td><td class="calibre70">24</td></tr>
<tr class="calibre25"><td class="calibre61">RIPE-MD</td><td class="calibre70">128</td><td class="calibre70">182</td></tr>
<tr class="calibre25"><td class="calibre61">SHA</td><td class="calibre70">160</td><td class="calibre70">75</td></tr>
<tr class="calibre71"><td class="calibre78">SNEFRU (4 passes)</td><td class="calibre72">128</td><td class="calibre72">48</td></tr>
<tr class="calibre25"><td class="calibre61">SNEFRU (8 passes)</td><td class="calibre70">128</td><td class="calibre70">23</td></tr>
</tbody></table>


<h3 id="18.14" class="calibre7">18.14 Message Authentication Codes</h3>

<p class="calibre9">A message authentication code, or MAC, is a key-dependent one-way hash
function. MACs have the same properties as the one-way hash functions
discussed previously, but they also include a key. Only someone with the
identical key can verify the hash. They are very useful to provide authenticity
without secrecy.</p>

<p class="calibre9">MACs can be used to authenticate files between users. They can also be used
by a single user to determine if his files have been altered, perhaps by a virus.
A user could compute the MAC of his files and store that value in a table. If
the user used instead a one-way hash function, then the virus could compute
the new hash value after infection and replace the table entry. A virus could
not do that with a MAC, because the virus does not know the key.</p>

<p class="calibre9">An easy way to turn a one-way hash function into a MAC is to encrypt the
hash value with a symmetric algorithm. Any MAC can be turned into a
one-way hash function by making the key public.</p>

<h4 class="calibre8">CBC-MAC</h4>

<p class="calibre9">The simplest way to make a key-dependent one-way hash function is to
encrypt a message with a block algorithm in CBC or CFB modes. The hash is
the last encrypted block, encrypted once more in CBC or CFB modes. The
CBC method is specified in ANSI X9.9 [<a href="Applied%20Cryptography_split_035.html#r54" class="calibre5 pcalibre">54</a>], ANSI X9.19 [<a href="Applied%20Cryptography_split_035.html#r56" class="calibre5 pcalibre">56</a>], ISO 8731-1
[<a href="Applied%20Cryptography_split_035.html#r759" class="calibre5 pcalibre">759</a>], ISO 9797 [<a href="Applied%20Cryptography_split_035.html#r763" class="calibre5 pcalibre">763</a>], and an Australian standard [<a href="Applied%20Cryptography_split_036.html#r1496" class="calibre5 pcalibre">1496</a>]. Differential
cryptanalysis can break this scheme with reduced-round DES or FEAL as the
underlying block algorithms [<a href="Applied%20Cryptography_split_036.html#r1197" class="calibre5 pcalibre">1197</a>].</p>

<p class="calibre9">The potential security problem with this method is that the receiver must have
the key, and that key allows him to generate messages with the same hash
value as a given message by decrypting in the reverse direction.</p>

<h4 class="calibre8">Message Authenticator Algorithm (MAA)</h4>

<p class="calibre9">This algorithm is an ISO standard [<a href="Applied%20Cryptography_split_035.html#r760" class="calibre5 pcalibre">760</a>]. It produces a 32-bit hash, and was
designed for mainframe computers with a fast multiply instruction [<a href="Applied%20Cryptography_split_035.html#r428" class="calibre5 pcalibre">428</a>].</p>

<p class="math-left"><i class="calibre12">v</i> = <i class="calibre12">v</i> &lt;&lt;&lt; 1
<i class="calibre12">e</i> = <i class="calibre12">v</i> ⊕ <i class="calibre12">w</i>
<i class="calibre12">x</i> = ((((<i class="calibre12">e</i> + <i class="calibre12">y</i>) mod 2<sup class="calibre19">32</sup>) ∨ A ∧ C) * (<i class="calibre12">x</i> ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>)) mod 2<sup class="calibre19">32</sup> - 1
<i class="calibre12">y</i> = ((((<i class="calibre12">e + x</i>) mod 2<sup class="calibre19">32</sup>) ∨ B ∧ D) * (<i class="calibre12">y</i> ⊕ <i class="calibre12">M</i><sub class="calibre15">i</sub>)) mod 2<sup class="calibre19">32</sup> - 2
</p>

<p class="calibre9">Iterate these for each message block, <i class="calibre12">M</i><sub class="calibre15">i</sub>, and the resultant hash is the XOR of <i class="calibre12">x</i> and <i class="calibre12">y</i>. The variables <i class="calibre12">v</i> and <i class="calibre12">e</i> are determined from the key. A, B, C, and D are constants.</p>

<p class="calibre9">This algorithm is probably in wide use, but I can’t believe it is all that secure.
It was designed a long time ago, and isn’t very complicated.</p>

<h4 class="calibre8">Bidirectional MAC</h4>

<p class="calibre9">This MAC produces a hash value twice the length of the block algorithm
[<a href="Applied%20Cryptography_split_036.html#r978" class="calibre5 pcalibre">978</a>]. First, compute the CBC-MAC of the message. Then, compute the
CBC-MAC of the message with the blocks in reverse order. The bidirectional
MAC value is simply the concatenation of the two. Unfortunately, this
construction is insecure [<a href="Applied%20Cryptography_split_036.html#r1097" class="calibre5 pcalibre">1097</a>].</p>

<h4 class="calibre8">Jueneman’s Methods</h4>

<p class="calibre9">This MAC is also called a quadratic congruential manipulation detection code
(QCMDC) [<a href="Applied%20Cryptography_split_035.html#r792" class="calibre5 pcalibre">792</a>,<a href="Applied%20Cryptography_split_035.html#r789" class="calibre5 pcalibre">789</a>]. First, divide the message into m- bit blocks. Then:</p>

<p class="math-left"><i class="calibre12">H</i><sub class="calibre15">0</sub> = <i class="calibre12">I</i><sub class="calibre15">H</sub>, where <i class="calibre12">I</i><sub class="calibre15">H</sub> is the secret key
<i class="calibre12">H</i><sub class="calibre15">i</sub> = (<i class="calibre12">H</i><sub class="calibre15">i - 1</sub> + <i class="calibre12">M</i><sub class="calibre15">i</sub>)<sup class="calibre19">2</sup> mod <i class="calibre12">p, </i> where <i class="calibre12">p</i> is a prime less than 2<sup class="calibre19">m</sup> - 1 and + denotes integer addition
</p>

<p class="calibre9">Jueneman suggests <i class="calibre12">n</i> = 16 and <i class="calibre12">p</i> = 2<sup class="calibre19">31</sup> - 1. In [<a href="Applied%20Cryptography_split_035.html#r792" class="calibre5 pcalibre">792</a>] he also suggests that an additional key be used as <i class="calibre12">H</i><sub class="calibre15">1</sub>, with the actual message starting at <i class="calibre12">H</i><sub class="calibre15">2</sub>.</p>

<p class="calibre9">Because of a variety of birthday-type attacks discovered in conjunction with
Don Coppersmith, Jueneman suggested computing the QCMDC four times,
using the result of one iteration as the IV for the next iteration, and then
concatenating the results to obtain a 128-bit hash value [<a href="Applied%20Cryptography_split_035.html#r793" class="calibre5 pcalibre">793</a>]. This was further
strengthened by doing the four iterations in parallel and cross-linking them
[<a href="Applied%20Cryptography_split_035.html#r790" class="calibre5 pcalibre">790</a>,<a href="Applied%20Cryptography_split_035.html#r791" class="calibre5 pcalibre">791</a>]. This scheme was broken by Coppersmith [<a href="Applied%20Cryptography_split_035.html#r376" class="calibre5 pcalibre">376</a>].</p>

<p class="calibre9">Another variant [<a href="Applied%20Cryptography_split_035.html#r432" class="calibre5 pcalibre">432</a>,<a href="Applied%20Cryptography_split_035.html#r434" class="calibre5 pcalibre">434</a>] replaced the addition operation with an XOR and
used message blocks significantly smaller than <i class="calibre12">p. H</i><sub class="calibre15">0</sub> was also set, making it a keyless one-way hash function. After this scheme was attacked [<a href="Applied%20Cryptography_split_035.html#r612" class="calibre5 pcalibre">612</a>], it was
strengthened as part of the European Open Shop Information-TeleTrust project
[<a href="Applied%20Cryptography_split_036.html#r1221" class="calibre5 pcalibre">1221</a>], quoted in CCITT X.509 [<a href="Applied%20Cryptography_split_035.html#r304" class="calibre5 pcalibre">304</a>], and adopted in ISO 10118 [<a href="Applied%20Cryptography_split_035.html#r764" class="calibre5 pcalibre">764</a>,<a href="Applied%20Cryptography_split_035.html#r765" class="calibre5 pcalibre">765</a>].
Unfortunately, Coppersmith has broken this scheme as well [<a href="Applied%20Cryptography_split_035.html#r376" class="calibre5 pcalibre">376</a>]. There has
been some research using exponents other than 2 [<a href="Applied%20Cryptography_split_035.html#r603" class="calibre5 pcalibre">603</a>], but none of it has been
promising.</p>

<h4 class="calibre8">RIPE-MAC</h4>

<p class="calibre9">RIPE-MAC was invented by Bart Preneel [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>] and adopted by the RIPE
project [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>] (see <a href="#18.8" class="calibre5 pcalibre">Section 18.8</a>). It is based on ISO 9797 [<a href="Applied%20Cryptography_split_035.html#r763" class="calibre5 pcalibre">763</a>], and uses DES
as a block encryption function. RIPE-MAC has two flavors: one using normal
DES, called RIPE-MAC1, and another using triple-DES for even greater
security, called RIPE-MAC3. RIPE-MAC1 uses one DES encryption per
64-bit message block; RIPE-MAC3 uses three.</p>

<p class="calibre9">The algorithm consists of three parts. First, the message is expanded to a
length that is a multiple of 64 bits. Next, the expanded message is divided up
into 64-bit blocks. A keyed compression function is used to hash these blocks,
under the control of a secret key, into a single block of 64 bits. This is the step
that uses either DES or triple-DES. Finally, the output of this compression is
subjected to another DES-based encryption with a different key, derived from
the key used in the compression. See [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>] for details.</p>

<h4 class="calibre8">IBC-Hash</h4>

<p class="calibre9">IBC-Hash is another MAC adopted by the RIPE project [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>] (see <a href="#18.8" class="calibre5 pcalibre">Section 18.8</a>). 
It is interesting because it is provably secure; the chance of successful
attack can be quantified. Unfortunately, every message must be hashed with a
different key. The chosen level of security puts constraints on the maximum
message size that can be hashed — something no other function in this chapter
does. Given these considerations, the RIPE report recommends that IBC-Hash
be used only for long, infrequently sent messages.</p>

<p class="calibre9">The heart of the function is</p>

<p class="math"><i class="calibre12">h</i><sub class="calibre15">i</sub> = ((<i class="calibre12">M</i><sub class="calibre15">i</sub> mod <i class="calibre12">p</i>) + <i class="calibre12">v</i>) mod 2<sup class="calibre19">n</sup>
</p>

<p class="calibre9">The secret key is the pair <i class="calibre12">p</i> and <i class="calibre12">v, </i> where <i class="calibre12">p</i> is an N-bit prime and <i class="calibre12">v</i> is a random number less than 2<sup class="calibre19">n</sup>. The M<sub class="calibre15">i</sub> values are derived by a carefully specified
padding procedure. The probabilities of breaking both the one-wayness and the
collision-resistance can be quantified, and users can choose their security level
by changing the parameters.</p>

<h4 class="calibre8">One-Way Hash Function MAC</h4>

<p class="calibre9">A one-way hash function can also be used as a MAC [<a href="Applied%20Cryptography_split_036.html#r1537" class="calibre5 pcalibre">1537</a>]. Assume Alice
and Bob share a key <i class="calibre12">K, </i> and Alice wants to send Bob a MAC for message <i class="calibre12">M</i>.
Alice concatenates <i class="calibre12">K</i> and <i class="calibre12">M, </i> and computes the one-way hash of the
concatenation: <i class="calibre12">H</i>(<i class="calibre12">K,M</i>). This hash is the MAC. Since Bob knows <i class="calibre12">K, </i> he can reproduce Alice’s result. Mallory, who does not know <i class="calibre12">K, </i> can’t.</p>

<p class="calibre9">This method works with MD-strengthening techniques, but has serious
problems. Mallory can always add new blocks to the end of the message and
compute a valid MAC. This attack can be thwarted if you put the message
length at the beginning, but Preneel is suspicious of this scheme [<a href="Applied%20Cryptography_split_036.html#r1265" class="calibre5 pcalibre">1265</a>]. It is
better to put the key at the end of the message, <i class="calibre12">H</i>(<i class="calibre12">M,K</i>), but this has some problems as well [<a href="Applied%20Cryptography_split_036.html#r1265" class="calibre5 pcalibre">1265</a>]. If <i class="calibre12">H</i> is one-way but not collision-free, Mallory can
forge messages. Still better is <i class="calibre12">H</i> (<i class="calibre12">K,M,K</i>), or <i class="calibre12">H</i>(<i class="calibre12">K</i><sub class="calibre15">1</sub><i class="calibre12">,M,K</i><sub class="calibre15">2</sub>), where <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12"><i class="calibre12">K</i><sub class="calibre15">2</sub></i>
are different [<a href="Applied%20Cryptography_split_036.html#r1537" class="calibre5 pcalibre">1537</a>]. Preneel is still suspicious [<a href="Applied%20Cryptography_split_036.html#r1265" class="calibre5 pcalibre">1265</a>].</p>

<p class="calibre9">The following constructions seem secure:</p>

<p class="math-left"><i class="calibre12">H</i>(<i class="calibre12">K</i><sub class="calibre15">1</sub>,H(<i class="calibre12">K</i><sub class="calibre15">2</sub>,<i class="calibre12">M</i>))
<i class="calibre12">H</i>(<i class="calibre12">K,H</i>(<i class="calibre12">K,M</i>))
<i class="calibre12">H</i>(<i class="calibre12">K,p,M,K</i>), where <i class="calibre12">p</i> pads <i class="calibre12">K</i> to a full message block.
</p>

<p class="calibre9">The best approach is to concatenate at least 64 bits of the key with each
message block. This makes the one-way hash function less efficient, because
the message blocks are smaller, but it is much more secure [<a href="Applied%20Cryptography_split_036.html#r1265" class="calibre5 pcalibre">1265</a>].</p>

<p class="calibre9">Alternatively, use a one-way hash function and a symmetric algorithm. Hash
the file, then encrypt the hash. This is more secure than first encrypting the file
and then hashing the encrypted file, but it is vulnerable to the same attack as
the <i class="calibre12">H</i>(<i class="calibre12">M,K</i>) approach [<a href="Applied%20Cryptography_split_036.html#r1265" class="calibre5 pcalibre">1265</a>].</p>

<h4 class="calibre8">Stream Cipher MAC</h4>

<p class="calibre9">This MAC scheme uses stream ciphers (see Figure 18.15) [<a href="Applied%20Cryptography_split_036.html#r932" class="calibre5 pcalibre">932</a>]. A
cryptographically secure pseudo-random-bit generator demultiplexes the
message stream into two substreams. If the output bit of the bit generator <i class="calibre12">k</i><sub class="calibre15">i</sub>, is 1, then the current message bit <i class="calibre12">m</i><sub class="calibre15">i</sub>, is routed to the first substream; if the <i class="calibre12">k</i><sub class="calibre15">i</sub> is 0, the <i class="calibre12">m<sub class="calibre15">i</sub></i> is routed to the second substream. The substreams are each fed into a
different LFSR (see <a href="Applied%20Cryptography_split_019.html#16.2" class="calibre5 pcalibre">Section 16.2</a>). The output of the MAC is simply the final
states of the shift registers.</p>

<div class="figure" id="figure-18-15">
<div class="image1">
<p class="calibre9"><img src="ac-figure-18-15.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 18.15</b> Stream cipher MAC.</i></p>
</div>

<p class="calibre9">Unfortunately, this method is not secure against small changes in the message
[<a href="Applied%20Cryptography_split_036.html#r1523" class="calibre5 pcalibre">1523</a>]. For example, if you alter the last bit of the message, then only 2 bits in
the corresponding MAC value need to be altered to create a fake MAC; this
can be done with reasonable probability. The author presents a more secure,
and more complicated, alternative.</p>

<div class="calibre6" id="calibre_pb_42"></div>
</div>






</body></html>
