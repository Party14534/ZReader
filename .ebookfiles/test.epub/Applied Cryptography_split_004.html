<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="3">Chapter 3 <br class="calibre3"/>
Basic Protocols</h1>

<h3 id="3.1" class="calibre7">3.1 Key Exchange</h3>

<p class="calibre9">A common cryptographic technique is to encrypt each individual conversation
with a separate key. This is called a session key, because it is used for only one
particular communications session. As discussed in <a href="Applied%20Cryptography_split_010.html#8.5" class="calibre5 pcalibre">Section 8.5</a>, session keys
are useful because they only exist for the duration of the communication. How
this common session key gets into the hands of the conversants can be a
complicated matter.</p>

<h4 class="calibre8">Key Exchange with Symmetric Cryptography</h4>

<p class="calibre9">This protocol assumes that Alice and Bob, users on a network, each share a
secret key with the Key Distribution Center (KDC) [<a href="Applied%20Cryptography_split_036.html#r1260" class="calibre5 pcalibre">1260</a>] — Trent in our
protocols. These keys must be in place before the start of the protocol. (The
protocol ignores the very real problem of how to distribute these secret keys;
just assume they are in place and Mallory has no idea what they are.)</p>

<ol class="calibre17">

<li class="calibre14">Alice calls Trent and requests a session key to communicate with
Bob.
</li>
<li class="calibre14">Trent generates a random session key. He encrypts two copies of it:
one in Alice’s key and the other in Bob’s key. Trent sends both copies to
Alice.
</li>
<li class="calibre14">Alice decrypts her copy of the session key.
</li>
<li class="calibre14">Alice sends Bob his copy of the session key.
</li>
<li class="calibre14">Bob decrypts his copy of the session key.
</li>
<li class="calibre14">Both Alice and Bob use this session key to communicate securely.
</li>

</ol>

<p class="calibre9">This protocol relies on the absolute security of Trent, who is more likely to be
a trusted computer program than a trusted individual. If Mallory corrupts
Trent, the whole network is compromised. He has all of the secret keys that
Trent shares with each of the users; he can read all past communications traffic
that he has saved, and all future communications traffic. All he has to do is to
tap the communications lines and listen to the encrypted message traffic.</p>

<p class="calibre9">The other problem with this system is that Trent is a potential bottleneck. He
has to be involved in every key exchange. If Trent fails, that disrupts the entire
system.</p>

<h4 class="calibre8">Key Exchange with Public-Key Cryptography</h4>

<p class="calibre9">The basic hybrid cryptosystem was discussed in <a href="Applied%20Cryptography_split_003.html#2.5" class="calibre5 pcalibre">Section 2.5</a>. Alice and Bob
use public-key cryptography to agree on a session key, and use that session
key to encrypt data. In some practical implementations, both Alice’s and Bob’s
signed public keys will be available on a database. This makes the
key-exchange protocol even easier, and Alice can send a secure message to
Bob even if he has never heard of her:</p>

<ol class="calibre17">

<li class="calibre14">Alice gets Bob’s public key from the KDC.
</li>
<li class="calibre14">Alice generates a random session key, encrypts it using Bob’s
public key, and sends it to Bob.
</li>
<li class="calibre14">Bob then decrypts Alice’s message using his private key.
</li>
<li class="calibre14">Both of them encrypt their communications using the same session
key.
</li>

</ol>

<h4 class="calibre8">Man-in-the-Middle Attack</h4>

<p class="calibre9">While Eve cannot do better than try to break the public-key algorithm or
attempt a ciphertext-only attack on the ciphertext, Mallory is a lot more
powerful than Eve. Not only can he listen to messages between Alice and Bob,
he can also modify messages, delete messages, and generate totally new ones.
Mallory can imitate Bob when talking to Alice and imitate Alice when talking
to Bob. Here’s how the attack works:</p>

<ol class="calibre17">

<li class="calibre14">Alice sends Bob her public key. Mallory intercepts this key and
sends Bob his own public key.
</li>
<li class="calibre14">Bob sends Alice his public key. Mallory intercepts this key and
sends Alice his own public key.
</li>
<li class="calibre14">When Alice sends a message to Bob, encrypted in “Bob’s” public
key, Mallory intercepts it. Since the message is really encrypted with his
own public key, he decrypts it with his private key, re-encrypts it with
Bob’s public key, and sends it on to Bob.
</li>
<li class="calibre14">When Bob sends a message to Alice, encrypted in “Alice’s” public
key, Mallory intercepts it. Since the message is really encrypted with his
own public key, he decrypts it with his private key, re-encrypts it with
Alice’s public key, and sends it on to Alice.
</li>

</ol>

<p class="calibre9">Even if Alice’s and Bob’s public keys are stored on a database, this attack will
work. Mallory can intercept Alice’s database inquiry and substitute his own
public key for Bob’s. He can do the same to Bob and substitute his own public
key for Alice’s. Or better yet, he can break into the database surreptitiously
and substitute his key for both Alice’s and Bob’s. Then he simply waits for
Alice and Bob to talk with each other, intercepts and modifies the messages,
and he has succeeded.</p>

<p class="calibre9">This <b class="calibre10">man-in-the-middle attack</b> works because Alice and Bob have no way to
verify that they are talking to each other. Assuming Mallory doesn’t cause any
noticeable network delays, the two of them have no idea that someone sitting
between them is reading all of their supposedly secret communications.</p>

<h4 class="calibre8">Interlock Protocol</h4>

<p class="calibre9">The <b class="calibre10">interlock protocol</b>, invented by Ron Rivest and Adi Shamir [<a href="Applied%20Cryptography_split_036.html#r1327" class="calibre5 pcalibre">1327</a>], has a
good chance of foiling the man-in-the-middle attack. Here’s how it works:</p>

<ol class="calibre17">

<li class="calibre14">Alice sends Bob her public key.
</li>
<li class="calibre14">Bob sends Alice his public key.
</li>
<li class="calibre14">Alice encrypts her message using Bob’s public key. She sends half
of the encrypted message to Bob.
</li>
<li class="calibre14">Bob encrypts his message using Alice’s public key. He sends half of
the encrypted message to Alice.
</li>
<li class="calibre14">Alice sends the other half of her encrypted message to Bob.
</li>
<li class="calibre14">Bob puts the two halves of Alice’s message together and decrypts it
with his private key. Bob sends the other half of his encrypted message
to Alice.
</li>
<li class="calibre14">Alice puts the two halves of Bob’s message together and decrypts it
with her private key.
</li>

</ol>

<p class="calibre9">The important point is that half of the message is useless without the other
half; it can’t be decrypted. Bob cannot read any part of Alice’s message until
step (6); Alice cannot read any part of Bob’s message until step (7). There are
a number of ways to do this:</p>

<ul class="calibre13">

<li class="calibre14">If the encryption algorithm is a block algorithm, half of each block
(e.g., every other bit) could be sent in each half message.
</li>
<li class="calibre14">Decryption of the message could be dependent on an initialization
vector (see <a href="Applied%20Cryptography_split_011.html#9.3" class="calibre5 pcalibre">Section 9.3</a>), which could be sent with the second half of the
message.
</li>
<li class="calibre14">The first half of the message could be a one-way hash function of the
encrypted message (see <a href="Applied%20Cryptography_split_003.html#2.4" class="calibre5 pcalibre">Section 2.4</a>) and the encrypted message itself
could be the second half.
</li>

</ul>

<p class="calibre9">To see how this causes a problem for Mallory, let’s review his attempt to
subvert the protocol. He can still substitute his own public keys for Alice’s and
Bob’s in steps (1) and (2). But now, when he intercepts half of Alice’s
message in step (3), he cannot decrypt it with his private key and re-encrypt it
with Bob’s public key. He must invent a totally new message and send half of
it to Bob. When he intercepts half of Bob’s message to Alice in step (4), he has
the same problem. He cannot decrypt it with his private key and re-encrypt it
with Alice’s public key. He has to invent a totally new message and send half
of it to Alice. By the time he intercepts the second halves of the real messages
in steps (5) and (6), it is too late for him to change the new messages he
invented. The conversation between Alice and Bob will necessarily be
completely different.</p>

<p class="calibre9">Mallory could possibly get away with this scheme. If he knows Alice and Bob
well enough to mimic both sides of a conversation between them, they might
never realize that they are being duped. But surely this is much harder than
sitting between the two of them, intercepting and reading their messages.</p>

<h4 class="calibre8">Key Exchange with Digital Signatures</h4>

<p class="calibre9">Implementing digital signatures during a session-key exchange protocol
circumvents this man-in-the-middle attack as well. Trent signs both Alice’s
and Bob’s public keys. The signed keys include a signed certification of
ownership. When Alice and Bob receive the keys, they each verify Trent’s
signature. Now they know that the public key belongs to that other person. The
key exchange protocol can then proceed.</p>

<p class="calibre9">Mallory has serious problems. He cannot impersonate either Alice or Bob
because he doesn’t know either of their private keys. He cannot substitute his
public key for either of theirs because, while he has one signed by Trent, it is
signed as being Mallory’s. All he can do is listen to the encrypted traffic go
back and forth or disrupt the lines of communication and prevent Alice and
Bob from talking.</p>

<p class="calibre9">This protocol uses Trent, but the risk of compromising the KDC is less than
the first protocol. If Mallory compromises Trent (breaks into the KDC), all he
gets is Trent’s private key. This key enables him only to sign new keys; it does
not let him decrypt any session keys or read any message traffic. To read the
traffic, Mallory has to impersonate a user on the network and trick legitimate
users into encrypting messages with his phony public key.</p>

<p class="calibre9">Mallory can launch that kind of attack. With Trent’s private key, he can create
phony signed keys to fool both Alice and Bob. Then, he can either exchange
them in the database for real signed keys, or he can intercept users’ database
requests and reply with his phony keys. This enables him to launch a
man-in-the-middle attack and read people’s communications.</p>

<p class="calibre9">This attack will work, but remember that Mallory has to be able to intercept
and modify messages. In some networks this is a lot more difficult than
passively sitting on a network reading messages as they go by. On a broadcast
channel, such as a radio network, it is almost impossible to replace one
message with another — although the entire network can be jammed. On
computer networks this is easier and seems to be getting easier every day.
Consider IP spoofing, router attacks, and so forth; active attacks don’t
necessarily mean someone down a manhole with a datascope, and they are not
limited to three-letter agencies.</p>

<h4 class="calibre8">Key and Message Transmission</h4>

<p class="calibre9">Alice and Bob need not complete the key-exchange protocol before
exchanging messages. In this protocol, Alice sends Bob the message, <i class="calibre12">M</i>,
without any previous key exchange protocol:</p>

<ol class="calibre17">

<li class="calibre14">Alice generates a random session key, <i class="calibre12">K</i>, and encrypts <i class="calibre12">M</i> using <i class="calibre12">K</i>.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>)
</p>

</li>
<li class="calibre14">Alice gets Bob’s public key from the database.
</li>
<li class="calibre14">Alice encrypts <i class="calibre12">K</i> with Bob’s public key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K</i>)
</p>
</li>
<li class="calibre14">Alice sends both the encrypted message and encrypted session key
to Bob.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>), <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K</i>)
</p>
<p class="calibre9">For added security against man-in-the-middle attacks, Alice can sign the
transmission.</p>
</li>
<li class="calibre14">Bob decrypts Alice’s session key, <i class="calibre12">K</i>, using his private key.
</li>
<li class="calibre14">Bob decrypts Alice’s message using the session key.
</li>

</ol>

<p class="calibre9">This hybrid system is how public-key cryptography is most often used in a
communications system. It can be combined with digital signatures,
timestamps, and any other security protocols.</p>

<h4 class="calibre8">Key and Message Broadcast</h4>

<p class="calibre9">There is no reason Alice can’t send the encrypted message to several people.
In this example, Alice will send the encrypted message to Bob, Carol, and
Dave:</p>

<ol class="calibre17">

<li class="calibre14">Alice generates a random session key, <i class="calibre12">K</i>, and encrypts <i class="calibre12">M</i> using <i class="calibre12">K</i>.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>( <i class="calibre12">M</i>)
</p>
</li>
<li class="calibre14">Alice gets Bob’s, Carol’s, and Dave’s public keys from the
database.
</li>
<li class="calibre14">Alice encrypts <i class="calibre12">K</i> with Bob’s public key, encrypts <i class="calibre12">K</i> with Carol’s public key, and then encrypts <i class="calibre12">K</i> with Dave’s public key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">K</i>)
</p>
</li>
<li class="calibre14">Alice broadcasts the encrypted message and all the encrypted keys
to anybody who cares to receive it.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>)
</p>
</li>
<li class="calibre14">Only Bob, Carol, and Dave can decrypt the key, <i class="calibre12">K</i>, each using his or her private key.
</li>
<li class="calibre14">Only Bob, Carol, and Dave can decrypt Alice’s message using <i class="calibre12">K</i>.
</li>

</ol>

<p class="calibre9">This protocol can be implemented on a store-and-forward network. A central
server can forward Alice’s message to Bob, Carol, and Dave along with their
particular encrypted key. The server doesn’t have to be secure or trusted, since
it will not be able to decrypt any of the messages.</p>

<h3 id="3.2" class="calibre7">3.2 Authentication</h3>

<p class="calibre9">When Alice logs into a host computer (or an automatic teller, or a telephone
banking system, or any other type of terminal), how does the host know who
she is? How does the host know she is not Eve trying to falsify Alice’s
identity? Traditionally, passwords solve this problem. Alice enters her
password, and the host confirms that it is correct. Both Alice and the host
know this secret piece of knowledge and the host requests it from Alice every
time she tries to log in.</p>

<h4 class="calibre8">Authentication Using One-Way Functions</h4>

<p class="calibre9">What Roger Needham and Mike Guy realized is that the host does not need to
know the passwords; the host just has to be able to differentiate valid
passwords from invalid passwords. This is easy with one-way functions
[<a href="Applied%20Cryptography_split_036.html#r1599" class="calibre5 pcalibre">1599</a>,<a href="Applied%20Cryptography_split_035.html#r526" class="calibre5 pcalibre">526</a>,<a href="Applied%20Cryptography_split_036.html#r1274" class="calibre5 pcalibre">1274</a>,<a href="Applied%20Cryptography_split_036.html#r1121" class="calibre5 pcalibre">1121</a>]. Instead of storing passwords, the host stores one-way
functions of the passwords.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends the host her password.
</li>
<li class="calibre14">The host performs a one-way function on the password.
</li>
<li class="calibre14">The host compares the result of the one-way function to the value it
previously stored.
</li>

</ol>

<p class="calibre9">Since the host no longer stores a table of everybody’s valid password, the
threat of someone breaking into the host and stealing the password list is
mitigated. The list of passwords operated on by the one-way function is
useless, because the one-way function cannot be reversed to recover the
passwords.</p>

<h4 class="calibre8">Dictionary Attacks and Salt</h4>

<p class="calibre9">A file of passwords encrypted with a one-way function is still vulnerable. In
his spare time, Mallory compiles a list of the 1,000,000 most common
passwords. He operates on all 1,000,000 of them with the one-way function
and stores the results. If each password is about 8 bytes, the resulting file will
be no more than 8 megabytes; it will fit on a few floppy disks. Now, Mallory
steals an encrypted password file. He compares that file with his file of
encrypted possible passwords and sees what matches.</p>

<p class="calibre9">This is a <b class="calibre10">dictionary attack</b>, and it’s surprisingly successful (see <a href="Applied%20Cryptography_split_010.html#8.1" class="calibre5 pcalibre">Section 8.1</a>).
<b class="calibre10">Salt</b> is a way to make it more difficult. Salt is a random string that is
concatenated with passwords before being operated on by the one-way
function. Then, both the salt value and the result of the one-way function are
stored in a database on the host. If the number of possible salt values is large
enough, this practically eliminates a dictionary attack against commonly used
passwords because Mallory has to generate the one-way hash for each possible
salt value. This is a simple attempt at an initialization vector (see <a href="Applied%20Cryptography_split_011.html#9.3" class="calibre5 pcalibre">Section 9.3</a>).</p>

<p class="calibre9">The point here is to make sure that Mallory has to do a trial encryption of each
password in his dictionary every time he tries to break another person’s
password, rather than just doing one massive precomputation for all possible
passwords.</p>

<p class="calibre9">A lot of salt is needed. Most UNIX systems use only 12 bits of salt. Even with
that, Daniel Klein developed a password-guessing program that often cracks
40 percent of the passwords on a given host system within a week [<a href="Applied%20Cryptography_split_036.html#r847" class="calibre5 pcalibre">847</a>,<a href="Applied%20Cryptography_split_036.html#r848" class="calibre5 pcalibre">848</a>]
(see <a href="Applied%20Cryptography_split_010.html#8.1" class="calibre5 pcalibre">Section 8.1</a>). David Feldmeier and Philip Karn compiled a list of about
732,000 common passwords concatenated with each of 4096 possible salt
values. They estimate that 30 percent of passwords on any given host can be
broken with this list [<a href="Applied%20Cryptography_split_035.html#r561" class="calibre5 pcalibre">561</a>].</p>

<p class="calibre9">Salt isn’t a panacea; increasing the number of salt bits won’t solve everything.
Salt only protects against general dictionary attacks on a password file, not
against a concerted attack on a single password. It protects people who have
the same password on multiple machines, but doesn’t make poorly chosen
passwords any better.</p>

<h4 class="calibre8">SKEY</h4>

<p class="calibre9">SKEY is an authentication program that relies on a one-way function for its
security. It’s easy to explain.</p>

<p class="calibre9">To set up the system, Alice enters a random number, <i class="calibre12">R</i>. The computer
computes <i class="calibre12">f</i>(<i class="calibre12">R</i>), <i class="calibre12">f</i>(<i class="calibre12">f</i>(<i class="calibre12">R</i>)), <i class="calibre12">f</i>(<i class="calibre12">f</i>(<i class="calibre12">f</i>(<i class="calibre12">R</i>))), and so on, about a hundred times. Call these numbers <i class="calibre12">x</i><sub class="calibre15">1</sub>, <i class="calibre12">x</i><sub class="calibre15">2</sub>, <i class="calibre12">x</i><sub class="calibre15">3</sub>,..., <i class="calibre12">x</i><sub class="calibre15">100</sub>. The computer prints out this list of numbers, and Alice puts it in her pocket for safekeeping. The computer also stores <i class="calibre12">x</i><sub class="calibre15">101</sub>, in the clear, in a login database next to Alice’s name.</p>

<p class="calibre9">The first time Alice wants to log in, she types her name and <i class="calibre12">x</i><sub class="calibre15">100</sub>. The
computer calculates <i class="calibre12">f</i>(<i class="calibre12">x</i><sub class="calibre15">100</sub>) and compares it with <i class="calibre12">x</i><sub class="calibre15">101</sub>; if they match, Alice is authenticated. Then, the computer replaces <i class="calibre12">x</i><sub class="calibre15">101</sub> with <i class="calibre12">x</i><sub class="calibre15">100</sub> in the database.
Alice crosses <i class="calibre12">x</i><sub class="calibre15">100</sub> off her list.</p>

<p class="calibre9">Every time Alice logs in, she enters the last uncrossed number on her list: <i class="calibre12">x</i><sub class="calibre15">i</sub>.
The computer calculates <i class="calibre12">f</i>(<i class="calibre12">x</i><sub class="calibre15">i</sub>) and compares it with <i class="calibre12">x</i><sub class="calibre15">i+1</sub> stored in its database.
Eve can’t get any useful information because each number is only used once,
and the function is one-way. Similarly, the database is not useful to an
attacker. Of course, when Alice runs out of numbers on her list, she has to
reinitialize the system.</p>

<h4 class="calibre8">Authentication Using Public-Key Cryptography</h4>

<p class="calibre9">Even with salt, the first protocol has serious security problems. When Alice
sends her password to her host, anyone who has access to her data path can
read it. She might be accessing her host through a convoluted transmission
path that passes through four industrial competitors, three foreign countries,
and two forward-thinking universities. Eve can be at any one of those points,
listening to Alice’s login sequence. If Eve has access to the processor memory
of the host, she can see the password before the host hashes it.</p>

<p class="calibre9">Public-key cryptography can solve this problem. The host keeps a file of every
user’s public key; all users keep their own private keys. Here is a naïve
attempt at a protocol. When logging in, the protocol proceeds as follows:</p>

<ol class="calibre17">

<li class="calibre14">The host sends Alice a random string.
</li>
<li class="calibre14">Alice encrypts the string with her private key and sends it back to
the host, along with her name.
</li>
<li class="calibre14">The host looks up Alice’s public key in its database and decrypts the
message using that public key.
</li>
<li class="calibre14">If the decrypted string matches what the host sent Alice in the first
place, the host allows Alice access to the system.
</li>

</ol>

<p class="calibre9">No one else has access to Alice’s private key, so no one else can impersonate
Alice. More important, Alice never sends her private key over the transmission
line to the host. Eve, listening in on the interaction, cannot get any information
that would enable her to deduce the private key and impersonate Alice.</p>

<p class="calibre9">The private key is both long and non-mnemonic, and will probably be
processed automatically by the user’s hardware or communications software.
This requires an intelligent terminal that Alice trusts, but neither the host nor
the communications path needs to be secure.</p>

<p class="calibre9">It is foolish to encrypt arbitrary strings — not only those sent by untrusted third
parties, but under any circumstances at all. Attacks similar to the one discussed
in <a href="Applied%20Cryptography_split_022.html#19.3" class="calibre5 pcalibre">Section 19.3</a> can be mounted. Secure proof-of-identity protocols take the
following, more complicated, form:</p>

<ol class="calibre17">

<li class="calibre14">Alice performs a computation based on some random numbers and
her private key and sends the result to the host.
</li>
<li class="calibre14">The host sends Alice a different random number.
</li>
<li class="calibre14">Alice makes some computation based on the random numbers (both
the ones she generated and the one she received from the host) and her
private key, and sends the result to the host.
</li>
<li class="calibre14">The host does some computation on the various numbers received
from Alice and her public key to verify that she knows her private key.
</li>
<li class="calibre14">If she does, her identity is verified.
</li>

</ol>

<p class="calibre9">If Alice does not trust the host any more than the host trusts Alice, then Alice
will require the host to prove its identity in the same manner.</p>

<p class="calibre9">Step (1) might seem unnecessary and confusing, but it is required to prevent
attacks against the protocol. <a href="Applied%20Cryptography_split_024.html#21.1" class="calibre5 pcalibre">Sections 21.1</a> and <a href="Applied%20Cryptography_split_024.html#21.2" class="calibre5 pcalibre">21.2</a> mathematically describe
several algorithms and protocols for proving identity. See also [<a href="Applied%20Cryptography_split_036.html#r935" class="calibre5 pcalibre">935</a>].</p>

<h4 class="calibre8">Mutual Authentication Using the Interlock Protocol</h4>

<p class="calibre9">Alice and Bob are two users who want to authenticate each other. Each of
them has a password that the other knows: Alice has <i class="calibre12">P</i><sub class="calibre15">A</sub> and Bob has <i class="calibre12">P</i><sub class="calibre15">B</sub>.
Here’s a protocol that will <i class="calibre12">not</i> work:</p>

<ol class="calibre17">

<li class="calibre14">Alice and Bob trade public keys.
</li>
<li class="calibre14">Alice encrypts <i class="calibre12">P</i><sub class="calibre15">A</sub> with Bob’s public key and sends it to him.
</li>
<li class="calibre14">Bob encrypts <i class="calibre12">P</i><sub class="calibre15">B</sub> with Alice’s public key and sends it to her.
</li>
<li class="calibre14">Alice decrypts what she received in step (2) and verifies that it is
correct.
</li>
<li class="calibre14">Bob decrypts what he received in step (3) and verifies that it is
correct.
</li>

</ol>

<p class="calibre9">Mallory can launch a successful man-in-the-middle attack (see <a href="#3.1" class="calibre5 pcalibre">Section 3.1</a>):</p>

<ol class="calibre17">

<li class="calibre14">Alice and Bob trade public keys. Mallory intercepts both messages.
He substitutes his public key for Bob’s and sends it to Alice. Then he
substitutes his public key for Alice’s and sends it to Bob.
</li>
<li class="calibre14">Alice encrypts <i class="calibre12">P</i><sub class="calibre15">A</sub> with “Bob’s” public key and sends it to him.
Mallory intercepts the message, decrypts <i class="calibre12">P</i><sub class="calibre15">A</sub> with his private key,
re-encrypts it with Bob’s public key and sends it on to him.
</li>
<li class="calibre14">Bob encrypts <i class="calibre12">P</i><sub class="calibre15">B</sub> with “Alice’s” public key and sends it to her.
Mallory intercepts the message, decrypts <i class="calibre12">P</i><sub class="calibre15">B</sub> with his private key,
re-encrypts it with Alice’s public key, and sends it on to her.
</li>
<li class="calibre14">Alice decrypts <i class="calibre12">P</i><sub class="calibre15">B</sub> and verifies that it is correct.
</li>
<li class="calibre14">Bob decrypts <i class="calibre12">P</i><sub class="calibre15">A</sub> and verifies that it is correct.
</li>

</ol>

<p class="calibre9">Alice and Bob see nothing different. However, Mallory knows both <i class="calibre12">P</i><sub class="calibre15">A</sub> and
<i class="calibre12">P</i><sub class="calibre15">B</sub>.</p>

<p class="calibre9">Donald Davies and Wyn Price describe how the interlock protocol (described
in <a href="#3.1" class="calibre5 pcalibre">Section 3.1</a>) can defeat this attack [<a href="Applied%20Cryptography_split_035.html#r435" class="calibre5 pcalibre">435</a>]. Steve Bellovin and Michael Merritt
discuss ways to attack this protocol [<a href="Applied%20Cryptography_split_035.html#r110" class="calibre5 pcalibre">110</a>]. If Alice is a user and Bob is a host,
Mallory can pretend to be Bob, complete the beginning steps of the protocol
with Alice, and then drop the connection. True artistry demands Mallory do
this by simulating line noise or network failure, but the final result is that
Mallory has Alice’s password. He can then connect with Bob and complete the
protocol, thus getting Bob’s password, too.</p>

<p class="calibre9">The protocol can be modified so that Bob gives his password before Alice,
under the assumption that the user’s password is much more sensitive than the
host’s password. This falls to a more complicated attack, also described in
[<a href="Applied%20Cryptography_split_035.html#r110" class="calibre5 pcalibre">110</a>].</p>

<h4 class="calibre8">SKID</h4>

<p class="calibre9">SKID2 and SKID3 are symmetric cryptography identification protocols
developed for RACE’s RIPE project [<a href="Applied%20Cryptography_split_036.html#r1305" class="calibre5 pcalibre">1305</a>] (See <a href="Applied%20Cryptography_split_029.html#25.7" class="calibre5 pcalibre">Section 25.7</a>). They use a
MAC (see <a href="Applied%20Cryptography_split_003.html#2.4" class="calibre5 pcalibre">Section 2.4</a>) to provide security and both assume that both Alice
and Bob share a secret key, <i class="calibre12">K</i>.</p>

<p class="calibre9">SKID2 allows Bob to prove his identity to Alice. Here’s the protocol:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Alice chooses a random number, <i class="calibre32">R</i><sub class="calibre33">A</sub>. (The RIPE document specifies
a 64-bit number). She sends it to Bob.
</li>
<li class="pcalibre1 calibre30">Bob chooses a random number, <i class="calibre32">R</i><sub class="calibre33">B</sub>. (The RIPE document specifies a
64-bit number). He sends Alice:
<p class="math1"><i class="calibre32">R</i><sub class="calibre33">B</sub>,H<sub class="calibre33">K</sub>(<i class="calibre32">R</i><sub class="calibre33">A</sub>,R<sub class="calibre33">B</sub>,B)
</p>
<p class="calibre34"><i class="calibre32">H</i><sub class="calibre33">K</sub> is the MAC. (The RIPE document suggests the RIPE-MAC
function — see <a href="Applied%20Cryptography_split_021.html#18.14" class="pcalibre calibre31">Section 18.14</a>.) <i class="calibre32">B</i> is Bob’s name.</p>

</li>
<li class="pcalibre1 calibre30">Alice computes <i class="calibre32">H</i><sub class="calibre33">K</sub>(<i class="calibre32">R</i><sub class="calibre33">A</sub>, <i class="calibre32">R</i><sub class="calibre33">B</sub>,B) and compares it with what she received from Bob. If the results are identical, then Alice knows that she
is communicating with Bob.
</li>

</ol>

<p class="calibre9">SKID3 provides mutual authentication between Alice and Bob. Steps (1)
through (3) are identical to SKID2, and then the protocol proceeds with:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Alice sends Bob:
<p class="math1"><i class="calibre32">H</i><sub class="calibre33">K</sub>(<i class="calibre32">R</i><sub class="calibre33">B</sub>,A)
</p>
<p class="calibre34"><i class="calibre32">A</i> is Alice’s name.</p>

</li>
<li class="pcalibre1 calibre30">Bob computes <i class="calibre32">H</i><sub class="calibre33">K</sub>(<i class="calibre32">R</i><sub class="calibre33">B</sub>, <i class="calibre32">A</i>), and compares it with what he received from Alice. If the results are identical, then Bob knows that he is
communicating with Alice.
</li>

</ol>

<p class="calibre9">This protocol is not secure against a man-in-the-middle attack. In general, a
man-in-the-middle attack can defeat any protocol that doesn’t involve a secret
of some kind.</p>

<h4 class="calibre8">Message Authentication</h4>

<p class="calibre9">When Bob receives a message from Alice, how does he know it is authentic?
If Alice signed her message, this is easy. Alice’s digital signature is enough to
convince anyone that the message is authentic.</p>

<p class="calibre9">Symmetric cryptography provides some authentication. When Bob receives a
message from Alice encrypted in their shared key, he knows it is from Alice.
No one else knows their key. However, Bob has no way of convincing a third
party of this fact. Bob can’t show the message to Trent and convince him that
it came from Alice. Trent can be convinced that the message came from either
Alice or Bob (since no one else shared their secret key), but he has no way of
knowing which one.
</p>
<p class="calibre9">If the message is unencrypted, Alice could also use a MAC. This also
convinces Bob that the message is authentic, but has the same problems as
symmetric cryptography solutions.</p>

<h3 id="3.3" class="calibre7">3.3 Authentication and Key Exchange</h3>

<p class="calibre9">These protocols combine authentication with key exchange to solve a general
computer problem: Alice and Bob are on opposite ends of a network and want
to talk securely. How can Alice and Bob exchange a secret key and at the same
time each be sure that he or she is talking to the other and not to Mallory?
Most of the protocols assume that Trent shares a different secret key with each
participant, and that all of these keys are in place before the protocol begins.</p>

<p class="calibre9">The symbols used in these protocols are summarized in Table 3.1.</p>

<h4 class="calibre8">Wide-Mouth Frog</h4>

<p class="calibre9">The Wide-Mouth Frog protocol [<a href="Applied%20Cryptography_split_035.html#r283" class="calibre5 pcalibre">283</a>,<a href="Applied%20Cryptography_split_035.html#r284" class="calibre5 pcalibre">284</a>] is probably the simplest symmetric
key-management protocol that uses a trusted server. Both Alice and Bob share
a secret key with Trent. The keys are just used for key distribution and not to
encrypt any actual messages between users. Just by using two messages, Alice
transfers a session key to Bob:</p>

<table class="data-table1" id="table-3-1">
<caption class="calibre23">TABLE 3.1 - Symbols used in authentication and key exchange protocols</caption>
<tbody class="calibre24"><tr class="calibre25"><td class="calibre29"><i class="calibre12">A</i></td><td class="calibre29">Alice’s name</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">B</i></td><td class="calibre27">Bob’s name</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">E</i><sub class="calibre15">A</sub></td><td class="calibre27">Encryption with a key Trent shares with Alice</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">E</i><sub class="calibre15">B</sub></td><td class="calibre27">Encryption with a key Trent shares with Bob</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">I</i></td><td class="calibre27">Index number</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">K</i></td><td class="calibre27">A random session key</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">L</i></td><td class="calibre27">Lifetime</td></tr>
<tr class="calibre25"><td class="calibre27"><i class="calibre12">T</i><sub class="calibre15">A</sub>, <i class="calibre12">T</i><sub class="calibre15">B</sub></td><td class="calibre27">A timestamp</td></tr>
<tr class="calibre25"><td class="calibre28"><i class="calibre12">R</i><sub class="calibre15">A</sub>,  <i class="calibre12">R</i><sub class="calibre15">B</sub></td><td class="calibre28">A random number, sometimes called a <b class="calibre10">nonce</b>, chosen by Alice and Bob respectively</td></tr>
</tbody></table>

<ol class="calibre17">

<li class="calibre14">Alice concatenates a timestamp, Bob’s name, and a random session
key and encrypts the whole message with the key she shares with Trent.
She sends this to Trent, along with her name.
<p class="math"><i class="calibre12">A,E</i><sub class="calibre15">A</sub>(<i class="calibre12">T</i><sub class="calibre15">A</sub>,B,K)
</p>
</li>
<li class="calibre14">Trent decrypts the message from Alice. Then he concatenates a new
timestamp, Alice’s name, and the random session key; he encrypts the
whole message with the key he shares with Bob. Trent sends to Bob:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">T</i><sub class="calibre15">B</sub>,A,K)
</p>
</li>

</ol>

<p class="calibre9">The biggest assumption made in this protocol is that Alice is competent
enough to generate good session keys. Remember that random numbers aren’t
easy to generate; it might be more than Alice can be trusted to do properly.</p>

<h4 class="calibre8">Yahalom</h4>

<p class="calibre9">In this protocol, both Alice and Bob share a secret key with Trent [<a href="Applied%20Cryptography_split_035.html#r283" class="calibre5 pcalibre">283</a>,<a href="Applied%20Cryptography_split_035.html#r284" class="calibre5 pcalibre">284</a>].</p>

<ol class="calibre17">

<li class="calibre14">Alice concatenates her name and a random number, and sends it to
Bob.
<p class="math"><i class="calibre12">A,R</i><sub class="calibre15">A</sub>
</p>
</li>
<li class="calibre14">Bob concatenates Alice’s name, Alice’s random number, his own
random number, and encrypts it with the key he shares with Trent. He
sends this to Trent, along with his name.
<p class="math"><i class="calibre12">B,E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,R</i><sub class="calibre15">A</sub>,R<sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Trent generates two messages. The first consists of Bob’s name, a
random session key, Alice’s random number, and Bob’s random
number, all encrypted with the key he shares with Alice. The second
consists of Alice’s name and the random session key, encrypted with
the key he shares with Bob. He sends both messages to Alice.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">B,K,R</i><sub class="calibre15">A</sub>, <i class="calibre12">R</i><sub class="calibre15">B</sub>)<i class="calibre12">,E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,K</i>)
</p>
</li>
<li class="calibre14">Alice decrypts the first message, extracts <i class="calibre12">K</i>, and confirms that <i class="calibre12">R</i><sub class="calibre15">A</sub> has the same value as it did in step (1). Alice sends Bob two messages.
The first is the message received from Trent, encrypted with Bob’s key.
The second is <i class="calibre12">R</i><sub class="calibre15">B</sub>, encrypted with the session key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,K</i>),<i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Bob decrypts the message encrypted with his key, extracts <i class="calibre12">K</i>, and
confirms that <i class="calibre12">R</i><sub class="calibre15">B</sub> has the same value as it did in step (2).
</li>

</ol>

<p class="calibre9">At the end, Alice and Bob are each convinced that they are talking to the other
and not to a third party. The novelty here is that Bob is the first one to contact
Trent, who only sends one message to Alice.</p>

<h4 class="calibre8">Needham-Schroeder</h4>

<p class="calibre9">This protocol, invented by Roger Needham and Michael Schroeder [<a href="Applied%20Cryptography_split_036.html#r1159" class="calibre5 pcalibre">1159</a>],
also uses symmetric cryptography and Trent.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends a message to Trent consisting of her name, Bob’s name,
and a random number.
<p class="math"><i class="calibre12">A,B,R</i><sub class="calibre15">A</sub>
</p>
</li>
<li class="calibre14">Trent generates a random session key. He encrypts a message
consisting of a random session key and Alice’s name with the secret key
he shares with Bob. Then he encrypts Alice’s random value, Bob’s
name, the key, and the encrypted message with the secret key he shares
with Alice. Finally, he sends her the encrypted message:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>, <i class="calibre12">B,K,E</i><sub class="calibre15">B</sub>(<i class="calibre12">K,A</i>))
</p>
</li>
<li class="calibre14">Alice decrypts the message and extracts <i class="calibre12">K</i>. She confirms that R<sub class="calibre15">A</sub> is the same value that she sent Trent in step (1). Then she sends Bob the
message that Trent encrypted in his key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K,A</i>)
</p>
</li>
<li class="calibre14">Bob decrypts the message and extracts <i class="calibre12">K</i>. He then generates another random value, <i class="calibre12">R</i><sub class="calibre15">B</sub>. He encrypts the message with <i class="calibre12">K</i> and sends it to Alice.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Alice decrypts the message with <i class="calibre12">K</i>. She generates <i class="calibre12">R</i><sub class="calibre15">B</sub> - 1 and encrypts it with <i class="calibre12">K</i>. Then she sends the message back to Bob.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub> - 1)
</p>
</li>
<li class="calibre14">Bob decrypts the message with <i class="calibre12">K</i> and verifies that it is <i class="calibre12">R</i><sub class="calibre15">B</sub> - 1.
</li>

</ol>

<p class="calibre9">All of this fussing around with <i class="calibre12">R</i><sub class="calibre15">A</sub> and <i class="calibre12">R</i><sub class="calibre15">B</sub> and <i class="calibre12">R</i><sub class="calibre15">B</sub> - 1 is to prevent <b class="calibre10">replay</b> <b class="calibre10">attacks</b>. In this attack, Mallory can record old messages and then use them
later in an attempt to subvert the protocol. The presence of <i class="calibre12">R</i><sub class="calibre15">A</sub> in step (2)
assures Alice that Trent’s message is legitimate and not a replay of a response
from a previous execution of the protocol. When Alice successfully decrypts
<i class="calibre12">R</i><sub class="calibre15">B</sub> and sends Bob <i class="calibre12">R</i><sub class="calibre15">B</sub> - 1 in step (5), Bob is ensured that Alice’s messages are not replays from an earlier execution of the protocol.</p>

<p class="calibre9">The major security hole in this protocol is that old session keys are valuable. If
Mallory gets access to an old <i class="calibre12">K</i>, he can launch a successful attack [<a href="Applied%20Cryptography_split_035.html#r461" class="calibre5 pcalibre">461</a>]. All he has to do is record Alice’s messages to Bob in step (3). Then, once he has <i class="calibre12">K</i>,
he can pretend to be Alice:</p>

<ol class="calibre17">

<li class="calibre14">Mallory sends Bob the following message:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K,A</i>)
</p>
</li>
<li class="calibre14">Bob extracts <i class="calibre12">K</i>, generates <i class="calibre12">R</i><sub class="calibre15">B</sub>, and sends Alice:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Mallory intercepts the message, decrypts it with <i class="calibre12">K</i>, and sends Bob:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub> - 1)
</p>
</li>
<li class="calibre14">Bob verifies that “Alice’s” message is <i class="calibre12">R</i><sub class="calibre15">B</sub> - 1.
</li>

</ol>

<p class="calibre9">Now, Mallory has Bob convinced that he is Alice.</p>

<p class="calibre9">A stronger protocol, using timestamps, can defeat this attack [<a href="Applied%20Cryptography_split_035.html#r461" class="calibre5 pcalibre">461</a>,<a href="Applied%20Cryptography_split_035.html#r456" class="calibre5 pcalibre">456</a>]. A
time-stamp is added to Trent’s message in step (2) encrypted with Bob’s key:
<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">K,A,T</i>). Timestamps require a secure and accurate system clock — not a trivial problem in itself.</p>

<p class="calibre9">If the key Trent shares with Alice is ever compromised, the consequences are
drastic. Mallory can use it to obtain session keys to talk with Bob (or anyone
else he wishes to talk to). Even worse, Mallory can continue to do this even
after Alice changes her key [<a href="Applied%20Cryptography_split_035.html#r90" class="calibre5 pcalibre">90</a>].</p>

<p class="calibre9">Needham and Schroeder attempted to correct these problems in a modified
version of their protocol [<a href="Applied%20Cryptography_split_036.html#r1160" class="calibre5 pcalibre">1160</a>]. Their new protocol is essentially the same as
the Otway-Rees protocol, published in the same issue of the same journal.</p>

<h4 class="calibre8">Otway-Rees</h4>

<p class="calibre9">This protocol also uses symmetric cryptography [<a href="Applied%20Cryptography_split_036.html#r1224" class="calibre5 pcalibre">1224</a>].</p>

<ol class="calibre17">

<li class="calibre14">Alice generates a message consisting of an index number, her name,
Bob’s name, and a random number, all encrypted in the key she shares
with Trent. She sends this message to Bob along with the index number,
her name, and his name:
<p class="math"><i class="calibre12">I,A,B,E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>,I,A,B)
</p>
</li>
<li class="calibre14">Bob generates a message consisting of a new random number, the
index number, Alice’s name, and Bob’s name, all encrypted in the key
he shares with Trent. He sends it to Trent, along with Alice’s encrypted
message, the index number, her name, and his name:
<p class="math"><i class="calibre12">I,A,B,E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>,I,A,B), <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>,I,A,B)
</p>
</li>
<li class="calibre14">Trent generates a random session key. Then he creates two
messages. One is Alice’s random number and the session key, encrypted
in the key he shares with Alice. The other is Bob’s random number and
the session key, encrypted in the key he shares with Bob. He sends these
two messages, along with the index number, to Bob:
<p class="math"><i class="calibre12">I,E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>, <i class="calibre12">K</i>), <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>,K)
</p>
</li>
<li class="calibre14">Bob sends Alice the message encrypted in her key, along with the
index number:
<p class="math"><i class="calibre12">I,E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>,K)
</p>
</li>
<li class="calibre14">Alice decrypts the message to recover her key and random number.
She then confirms that both have not changed in the protocol.
</li>

</ol>

<p class="calibre9">Assuming that all the random numbers match, and the index number hasn’t
changed along the way, Alice and Bob are now convinced of each other’s
identity, and they have a secret key with which to communicate.</p>

<h4 class="calibre8">Kerberos</h4>

<p class="calibre9">Kerberos is a variant of Needham-Schroeder and is discussed in detail in
<a href="Applied%20Cryptography_split_028.html#24.5" class="calibre5 pcalibre">Section 24.5</a>. In the basic Kerberos Version 5 protocol, Alice and Bob each
share keys with Trent. Alice wants to generate a session key for a conversation
with Bob.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends a message to Trent with her identity and Bob’s identity.
<p class="math"><i class="calibre12">A,B</i>
</p>
</li>
<li class="calibre14">Trent generates a message with a timestamp, a lifetime, <i class="calibre12">L</i>, a random session key, and Alice’s identity. He encrypts this in the key he shares
with Bob. Then he takes the timestamp, the lifetime, the session key,
and Bob’s identity, and encrypts these in the key he shares with Alice.
He sends both encrypted messages to Alice.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">T,L,K,B</i>), <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">T,L,K,A</i>)
</p>
</li>
<li class="calibre14">Alice generates a message with her identity and the timestamp,
encrypts it in <i class="calibre12">K</i>, and sends it to Bob. Alice also sends Bob the message
encrypted in Bob’s key from Trent.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">A,T</i>), <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">T,L,K,A</i>)
</p>
</li>
<li class="calibre14">Bob creates a message consisting of the timestamp plus one,
encrypts it in <i class="calibre12">K</i>, and sends it to Alice.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">T</i> + 1)
</p>
</li>

</ol>

<p class="calibre9">This protocol works, but it assumes that everyone’s clocks are synchronized
with Trent’s clock. In practice, the effect is obtained by synchronizing clocks
to within a few minutes of a secure time server and detecting replays within
the time interval.</p>

<h4 class="calibre8">Neuman-Stubblebine</h4>

<p class="calibre9">Whether by system faults or by sabotage, clocks can become unsynchronized.
If the clocks get out of sync, there is a possible attack against most of these
protocols [<a href="Applied%20Cryptography_split_035.html#r644" class="calibre5 pcalibre">644</a>]. If the sender’s clock is ahead of the receiver’s clock, Mallory
can intercept a message from the sender and replay it later when the timestamp
becomes current at the receiver’s site. This attack is called <b class="calibre10">suppress-replay</b>
and can have irritating consequences.</p>

<p class="calibre9">This protocol, first presented in [<a href="Applied%20Cryptography_split_035.html#r820" class="calibre5 pcalibre">820</a>] and corrected in [<a href="Applied%20Cryptography_split_036.html#r1162" class="calibre5 pcalibre">1162</a>] attempts to
counter the suppress-replay attack. It is an enhancement to Yahalom and is an
excellent protocol.</p>

<ol class="calibre17">

<li class="calibre14">Alice concatenates her name and a random number and sends it to
Bob.
<p class="math"><i class="calibre12">A,R</i><sub class="calibre15">A</sub>
</p>
</li>
<li class="calibre14">Bob concatenates Alice’s name, her random number, and a
timestamp, and encrypts with the key he shares with Trent. He sends it
to Trent along with his name and a new random number.
<p class="math"><i class="calibre12">B,R</i><sub class="calibre15">B</sub>, <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,R</i><sub class="calibre15">A</sub>, <i class="calibre12">T</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Trent generates a random session key. Then he creates two
messages. The first is Bob’s name, Alice’s random number, a random
session key, and the timestamp, all encrypted with the key he shares
with Alice. The second is Alice’s name, the session key, and the
timestamp, all encrypted with the key he shares with Bob. He sends
these both to Alice, along with Bob’s random number.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">B,R</i><sub class="calibre15">A</sub> <i class="calibre12">,K,T</i><sub class="calibre15">B</sub>), <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">A,K,T</i><sub class="calibre15">B</sub>), <i class="calibre12">R</i><sub class="calibre15">B</sub>
</p>
</li>
<li class="calibre14">Alice decrypts the message encrypted with her key, extracts <i class="calibre12">K</i>, and confirms that <i class="calibre12">R</i><sub class="calibre15">A</sub> has the same value as it did in step (1). Alice sends
Bob two messages. The first is the message received from Trent,
encrypted with Bob’s key. The second is <i class="calibre12">R</i><sub class="calibre15">B</sub>, encrypted with the session
key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,K,T</i><sub class="calibre15">B</sub>), <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Bob decrypts the message encrypted with his key, extracts <i class="calibre12">K</i>, and
confirms that <i class="calibre12">T</i><sub class="calibre15">B</sub> and <i class="calibre12">R</i><sub class="calibre15">B</sub> have the same value they did in step (2).
</li>

</ol>

<p class="calibre9">Assuming both random numbers and the timestamp match, Alice and Bob are
convinced of one another’s identity and share a secret key. Synchronized
clocks are not required because the timestamp is only relative to Bob’s clock;
Bob only checks the timestamp he generated himself.</p>

<p class="calibre9">One nice thing about this protocol is that Alice can use the message she
received from Trent for subsequent authentication with Bob, within some
predetermined time limit. Assume that Alice and Bob completed the above
protocol, communicated, and then terminated the connection. Alice and Bob
can reauthenticate in three steps, without having to rely on Trent.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends Bob the message Trent sent her in step (3) and a new
random number.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">A,K,T</i><sub class="calibre15">B</sub>), <i class="calibre12">R’</i><sub class="calibre15">A</sub>
</p>
</li>
<li class="calibre14">Bob sends Alice another new random number, and Alice’s new
random number encrypted in their session key.
<p class="math"><i class="calibre12">R’</i><sub class="calibre15">B</sub>, <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R’</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Alice sends Bob his new random number, encrypted in their session
key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R’</i><sub class="calibre15">B</sub>)
</p>
</li>

</ol>

<p class="calibre9">The new random numbers prevent replay attacks.</p>

<h4 class="calibre8">DASS</h4>

<p class="calibre9">The Distributed Authentication Security Service (DASS) protocols, developed
at Digital Equipment Corporation, also provide for mutual authentication and
key exchange [<a href="Applied%20Cryptography_split_035.html#r604" class="calibre5 pcalibre">604</a>,<a href="Applied%20Cryptography_split_036.html#r1519" class="calibre5 pcalibre">1519</a>,<a href="Applied%20Cryptography_split_036.html#r1518" class="calibre5 pcalibre">1518</a>]. Unlike the previous protocols, DASS uses
both public-key and symmetric cryptography. Alice and Bob each have a
private key. Trent has signed copies of their public keys.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends a message to Trent, consisting of Bob’s name.
<p class="math"><i class="calibre12">B</i>
</p>
</li>
<li class="calibre14">Trent sends Alice Bob’s public key, <i class="calibre12">K</i><sub class="calibre15">B</sub>, signed with Trent’s private key, <i class="calibre12">T</i>. The signed message includes Bob’s name.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">B,K</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Alice verifies Trent’s signature to confirm that the key she received
is actually Bob’s public key. She generates a random session key, and a
random public-key/private-key key pair: <i class="calibre12">K</i><sub class="calibre15">P</sub>. She encrypts a timestamp
with <i class="calibre12">K</i>. Then she signs a key lifetime, <i class="calibre12">L</i>, her name, and <i class="calibre12">K</i><sub class="calibre15">P</sub> with her private key, <i class="calibre12">K</i><sub class="calibre15">A</sub>. Finally, she encrypts <i class="calibre12">K</i> with Bob’s public key, and
signs it with <i class="calibre12">K</i><sub class="calibre15">P</sub>. She sends all of this to Bob.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">T</i><sub class="calibre15">A</sub>), <i class="calibre12">S</i><sub class="calibre15">K<sub class="calibre16">A</sub></sub>(<i class="calibre12">L,A,K</i><sub class="calibre15">P</sub>), <i class="calibre12">S</i><sub class="calibre15">K<sub class="calibre16">P</sub></sub>(<i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">B</sub></sub>(<i class="calibre12">K</i>))
</p>
</li>
<li class="calibre14">Bob sends a message to Trent (this may be a different Trent),
consisting of Alice’s name.
<p class="math"><i class="calibre12">A</i>
</p>
</li>
<li class="calibre14">Trent sends Bob Alice’s public key, signed in Trent’s private key.
The signed message includes Alice’s name.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">A,K</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Bob verifies Trent’s signature to confirm that the key he received is
actually Alice’s public key. He then verifies Alice’s signature and
recovers <i class="calibre12">K</i><sub class="calibre15">P</sub>. He verifies the signature and uses his private key to recover
<i class="calibre12">K</i>. Then he decrypts <i class="calibre12">T</i><sub class="calibre15">A</sub> to make sure this is a current message.
</li>
<li class="calibre14">If mutual authentication is required, Bob encrypts a new timestamp
with <i class="calibre12">K</i>, and sends it to Alice.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">T</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Alice decrypts <i class="calibre12">T</i><sub class="calibre15">B</sub> with <i class="calibre12">K</i> to make sure that the message is current.
</li>

</ol>

<p class="calibre9">SPX, a product by DEC, is based on DASS. Additional information can be
found in [<a href="Applied%20Cryptography_split_035.html#r34" class="calibre5 pcalibre">34</a>].</p>

<h4 class="calibre8">Denning-Sacco</h4>

<p class="calibre9">This protocol also uses public-key cryptography [<a href="Applied%20Cryptography_split_035.html#r461" class="calibre5 pcalibre">461</a>]. Trent keeps a database
of everyone’s public keys.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends a message to Trent with her identity and Bob’s identity:
<p class="math"><i class="calibre12">A,B</i>
</p>
</li>
<li class="calibre14">Trent sends Alice Bob’s public key, <i class="calibre12">K</i><sub class="calibre15">B</sub>, signed with Trent’s private key, <i class="calibre12">T</i>. Trent also sends Alice her own public key, <i class="calibre12">K</i><sub class="calibre15">A</sub>, signed with his private key.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">B,K</i><sub class="calibre15">B</sub>), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">A,K</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Alice sends Bob a random session key and a timestamp, signed in
her private key and encrypted in Bob’s public key, along with both
signed public keys.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">S</i><sub class="calibre15">A</sub>(<i class="calibre12">K,T</i><sub class="calibre15">A</sub>)), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">B,K</i><sub class="calibre15">B</sub>), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">A,K</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Bob decrypts Alice’s message with his private key and then verifies
Alice’s signature with her public key. He checks to make sure that the
timestamp is still valid.
</li>

</ol>

<p class="calibre9">At this point both Alice and Bob have <i class="calibre12">K</i>, and can communicate securely.</p>

<p class="calibre9">This looks good, but it isn’t. After completing the protocol with Alice, Bob
can then masquerade as Alice [<a href="Applied%20Cryptography_split_035.html#r5" class="calibre5 pcalibre">5</a>]. Watch:</p>

<ol class="calibre17">

<li class="calibre14">Bob sends his name and Carol’s name to Trent
<p class="math"><i class="calibre12">B,C</i>
</p>
</li>
<li class="calibre14">Trent sends Bob both Bob’s and Carol’s signed public keys.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">B,K</i><sub class="calibre15">B</sub>), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">C,K</i><sub class="calibre15">C</sub>)
</p>
</li>
<li class="calibre14">Bob sends Carol the signed session key and timestamp he
previously received from Alice, encrypted with Carol’s public key,
along with Alice’s certificate and Carol’s certificate.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">S</i><sub class="calibre15">A</sub>(<i class="calibre12">K,T</i><sub class="calibre15">A</sub>)), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">A,K</i><sub class="calibre15">A</sub>), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">C,K</i><sub class="calibre15">C</sub>)
</p>
</li>
<li class="calibre14">Carol decrypts Alice’s message with her private key and then
verifies Alice’s signature with her public key. She checks to make sure
that the timestamp is still valid.
</li>

</ol>

<p class="calibre9">Carol now thinks she is talking to Alice; Bob has successfully fooled her. In
fact, Bob can fool everyone on the network until the timestamp expires.</p>

<p class="calibre9">This is easy to fix. Add the names inside the encrypted message in step (3):</p>

<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">S</i><sub class="calibre15">A</sub>(<i class="calibre12">A,B,K,T</i><sub class="calibre15">A</sub>)), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">A,K</i><sub class="calibre15">A</sub>), <i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">B,K</i><sub class="calibre15">B</sub>)
</p>

<p class="calibre9">Now Bob can’t replay the old message to Carol, because it is clearly meant for
communication between Alice and Bob.</p>

<h4 class="calibre8">Woo-Lam</h4>

<p class="calibre9">This protocol also uses public-key cryptography [<a href="Applied%20Cryptography_split_036.html#r1610" class="calibre5 pcalibre">1610</a>,<a href="Applied%20Cryptography_split_036.html#r1611" class="calibre5 pcalibre">1611</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Alice sends a message to Trent with her identity and Bob’s identity:
<p class="math"><i class="calibre12">A,B</i>
</p>
</li>
<li class="calibre14">Trent sends Alice Bob’s public key, <i class="calibre12">K</i><sub class="calibre15">B</sub>, signed with Trent’s private key, <i class="calibre12">T</i>.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">K</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Alice verifies Trent’s signature. Then she sends Bob her name and a
random number, encrypted with Bob’s public key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">B</sub></sub>(<i class="calibre12">A,R</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Bob sends Trent his name, Alice’s name, and Alice’s random
number encrypted with Trent’s public key, <i class="calibre12">K</i><sub class="calibre15">T</sub>.
<p class="math"><i class="calibre12">A,B,E</i><sub class="calibre15">K<sub class="calibre16">T</sub></sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub>)
</p>
</li>
<li class="calibre14">Trent sends Bob Alice’s public key, <i class="calibre12">K</i><sub class="calibre15">A</sub>, signed with Trent’s private key. He also sends him Alice’s random number, a random session key,
Alice’s name, and Bob’s name, all signed with Trent’s private key and
encrypted with Bob’s public key.
<p class="math"><i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">K</i><sub class="calibre15">A</sub>), <i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">B</sub></sub>(<i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub><i class="calibre12">,K,A,B</i>))
</p>
</li>
<li class="calibre14">Bob verifies Trent’s signatures. Then he sends Alice the second part
of Trent’s message from step (5) and a new random number — all
encrypted in Alice’s public key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">A</sub></sub>(<i class="calibre12">S</i><sub class="calibre15">T</sub>(<i class="calibre12">R</i><sub class="calibre15">A</sub><i class="calibre12">,K,A,B</i>), <i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Alice verifies Trent’s signature and her random number. Then she
sends Bob the second random number, encrypted in the session key.
<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">R</i><sub class="calibre15">B</sub>)
</p>
</li>
<li class="calibre14">Bob decrypts his random number and verifies that it unchanged.
</li>

</ol>

<h4 class="calibre8">Other Protocols</h4>

<p class="calibre9">There are many other protocols in the literature. The X.509 protocols are
discussed in <a href="Applied%20Cryptography_split_028.html#24.9" class="calibre5 pcalibre">Section 24.9</a>, KryptoKnight is discussed in <a href="Applied%20Cryptography_split_028.html#24.6" class="calibre5 pcalibre">Section 24.6</a>, and
Encrypted Key Exchange is discussed in <a href="Applied%20Cryptography_split_025.html#22.5" class="calibre5 pcalibre">Section 22.5</a>.</p>

<p class="calibre9">Another new public-key protocol is Kuperee [<a href="Applied%20Cryptography_split_035.html#r694" class="calibre5 pcalibre">694</a>]. And work is being done on
protocols that use <b class="calibre10">beacons</b>, a trusted node on a network that continuously
broadcasts authenticated nonces [<a href="Applied%20Cryptography_split_035.html#r783" class="calibre5 pcalibre">783</a>].</p>

<h4 class="calibre8">Lessons Learned</h4>

<p class="calibre9">There are some important lessons in the previous protocols, both those which
have been broken and those which have not:</p>

<ul class="calibre13">

<li class="calibre14">Many protocols failed because the designers tried to be too clever.
They optimized their protocols by leaving out important pieces: names,
random numbers, and so on. The remedy is to make everything explicit
[<a href="Applied%20Cryptography_split_035.html#r43" class="calibre5 pcalibre">43</a>,<a href="Applied%20Cryptography_split_035.html#r44" class="calibre5 pcalibre">44</a>].
</li>
<li class="calibre14">Trying to optimize is an absolute tar pit and depends a whole lot on
the assumptions you make. For example: If you have authenticated time,
you can do a whole lot of things you can’t do if you don’t.
</li>
<li class="calibre14">The protocol of choice depends on the underlying communications
architecture. Do you want to minimize the size of messages or the
number of messages? Can all parties talk with each other or can only a
few of them?
</li>

</ul>

<p class="calibre9">It’s questions like these that led to the development of formal methods for
analyzing protocols.</p>

<h3 id="3.4" class="calibre7">3.4 Formal Analysis of Authentication and Key-Exchange Protocols</h3>

<p class="calibre9">The problem of establishing secure session keys between pairs of computers
(and people) on a network is so fundamental that it has led to a great deal of
research. Some of the research focused on the development of protocols like
the ones discussed in <a href="#3.1" class="calibre5 pcalibre">Sections 3.1</a>, <a href="#3.2" class="calibre5 pcalibre">3.2</a>, and <a href="#3.3" class="calibre5 pcalibre">3.3</a>. This, in turn, has led to a
greater and more interesting problem: the formal analysis of authentication and
key-exchange protocols. People have found flaws in seemingly secure
protocols years after they were proposed, and researchers wanted tools that
could prove a protocol’s security from the start. Although much of this work
can apply to general cryptographic protocols, the emphasis in research is
almost exclusively on authentication and key exchange.</p>

<p class="calibre9">There are four basic approaches to the analysis of cryptographic protocols
[<a href="Applied%20Cryptography_split_036.html#r1045" class="calibre5 pcalibre">1045</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Model and verify the protocol using specification languages and
verification tools not specifically designed for the analysis of
cryptographic protocols.
</li>
<li class="calibre14">Develop expert systems that a protocol designer can use to develop
and investigate different scenarios.
</li>
<li class="calibre14">Model the requirements of a protocol family using logics for the
analysis of knowledge and belief.
</li>
<li class="calibre14">Develop a formal method based on the algebraic term-rewriting
properties of cryptographic systems.
</li>

</ol>

<p class="calibre9">A full discussion on these four approaches and the research surrounding them
is well beyond the scope of this book. See [<a href="Applied%20Cryptography_split_036.html#r1047" class="calibre5 pcalibre">1047</a>,<a href="Applied%20Cryptography_split_036.html#r1355" class="calibre5 pcalibre">1355</a>] for a good introduction
to the topic; I am only going to touch on the major contributions to the field.</p>

<p class="calibre9">The first approach treats a cryptographic protocol as any other computer
program and attempts to prove correctness. Some researchers represent a
protocol as a finite-state machine [<a href="Applied%20Cryptography_split_036.html#r1449" class="calibre5 pcalibre">1449</a>,<a href="Applied%20Cryptography_split_036.html#r1565" class="calibre5 pcalibre">1565</a>], others use extensions of
first-order predicate calculus [<a href="Applied%20Cryptography_split_035.html#r822" class="calibre5 pcalibre">822</a>], and still others use specification languages
to analyze protocols [<a href="Applied%20Cryptography_split_036.html#r1566" class="calibre5 pcalibre">1566</a>]. However, proving correctness is not the same as
proving security and this approach fails to detect many flawed protocols.
Although it was widely studied at first, most of the work in this area has been
redirected as the third approach gained popularity.</p>

<p class="calibre9">The second approach uses expert systems to determine if a protocol can reach
an undesirable state (the leaking of a key, for example). While this approach
better identifies flaws, it neither guarantees security nor provides techniques
for developing attacks. It is good at determining whether a protocol contains a
given flaw, but is unlikely to discover unknown flaws in a protocol. Examples
of this approach can be found in [<a href="Applied%20Cryptography_split_036.html#r987" class="calibre5 pcalibre">987</a>,<a href="Applied%20Cryptography_split_036.html#r1521" class="calibre5 pcalibre">1521</a>]; [<a href="Applied%20Cryptography_split_036.html#r1092" class="calibre5 pcalibre">1092</a>] discusses a rule-based
system developed by the U.S. military, called the Interrogator.</p>

<p class="calibre9">The third approach is by far the most popular, and was pioneered by Michael
Burrows, Martin Abadi, and Roger Needham. They developed a formal logic
model for the analysis of knowledge and belief, called <b class="calibre10">BAN logic</b> [<a href="Applied%20Cryptography_split_035.html#r283" class="calibre5 pcalibre">283</a>,<a href="Applied%20Cryptography_split_035.html#r284" class="calibre5 pcalibre">284</a>].
BAN logic is the most widely used logic for analyzing authentication
protocols. It assumes that authentication is a function of integrity and
freshness, and uses logical rules to trace both of those attributes through the
protocol. Although many variants and extensions have been proposed, most
protocol designers still refer back to the original work.</p>

<p class="calibre9">BAN logic doesn’t provide a proof of security; it can only reason about
authentication. It has a simple, straightforward logic that is easy to apply and
still useful for detecting flaws. Some of the statements in BAN logic include:</p>

<ul class="split1">
<li class="calibre35">Alice believes X. (Alice acts as though X is true.)</li>
<li class="calibre35">Alice sees X. (Someone has sent a message containing X to Alice,
who can read and repeat X — possibly after decrypting it.)</li>
<li class="calibre35">Alice said X. (At some time, Alice sent a message that includes
the statement X. It is not known how long ago the message was
sent or even that it was sent during the current run of the protocol. 
It is known that Alice believed X when she said it.)</li>
<li class="calibre35">X is fresh. (X has not been sent in a message at any time before
the current run of the protocol.)</li>
</ul>

<p class="calibre9">And so on. BAN logic also provides rules for reasoning about belief in a
protocol. These rules can then be applied to the logical statements about the
protocol to prove things or answer questions about the protocol. For example,
one rule is the message-meaning rule:</p>

<ul class="split1">
<li class="calibre35">IF Alice believes that Alice and Bob share a secret key, <i class="calibre12">K</i>, and
Alice sees <i class="calibre12">X</i>, encrypted under <i class="calibre12">K</i>, and Alice did not encrypt <i class="calibre12">X</i>
under <i class="calibre12">K</i>, THEN Alice believes that Bob once said <i class="calibre12">X</i>.</li>
</ul>

<p class="calibre9">Another rule is the nonce-verification rule:</p>

<ul class="split1">
<li class="calibre35">IF Alice believes that <i class="calibre12">X</i> could have been uttered only recently and
that Bob once said <i class="calibre12">X</i>, THEN Alice believes that Bob believes <i class="calibre12">X</i>.</li>
</ul>

<p class="calibre9">There are four steps in BAN analysis:</p>

<ol class="calibre17">

<li class="calibre14">Convert the protocol into idealized form, using the statements
previously described.
</li>
<li class="calibre14">Add all assumptions about the initial state of the protocol.
</li>
<li class="calibre14">Attach logical formulas to the statements: assertions about the state
of the system after each statement.
</li>
<li class="calibre14">Apply the logical postulates to the assertions and assumptions to
discover the beliefs held by the parties in the protocol.
</li>

</ol>

<p class="calibre9">The authors of BAN logic “view the idealized protocols as clearer and more
complete specifications than traditional descriptions found in the literature....”
[<a href="Applied%20Cryptography_split_035.html#r283" class="calibre5 pcalibre">283</a>,<a href="Applied%20Cryptography_split_035.html#r284" class="calibre5 pcalibre">284</a>]. Others are not so impressed and criticize this step because it may
not accurately reflect the real protocol [<a href="Applied%20Cryptography_split_036.html#r1161" class="calibre5 pcalibre">1161</a>,<a href="Applied%20Cryptography_split_036.html#r1612" class="calibre5 pcalibre">1612</a>]. Further debate is in
[<a href="Applied%20Cryptography_split_035.html#r221" class="calibre5 pcalibre">221</a>,<a href="Applied%20Cryptography_split_036.html#r1557" class="calibre5 pcalibre">1557</a>]. Other critics try to show that BAN logic can deduce characteristics
about protocols that are obviously false [<a href="Applied%20Cryptography_split_036.html#r1161" class="calibre5 pcalibre">1161</a>] — see [<a href="Applied%20Cryptography_split_035.html#r285" class="calibre5 pcalibre">285</a>,<a href="Applied%20Cryptography_split_036.html#r1509" class="calibre5 pcalibre">1509</a>] for a
rebuttal — and that BAN logic deals only with trust and not security [<a href="Applied%20Cryptography_split_036.html#r1509" class="calibre5 pcalibre">1509</a>].
More debate is in [<a href="Applied%20Cryptography_split_036.html#r1488" class="calibre5 pcalibre">1488</a>,<a href="Applied%20Cryptography_split_035.html#r706" class="calibre5 pcalibre">706</a>,<a href="Applied%20Cryptography_split_036.html#r1002" class="calibre5 pcalibre">1002</a>].</p>

<p class="calibre9">Despite these criticisms, BAN logic has been a success. It has found flaws in
several protocols, including Needham-Schroeder and an early draft of a
CCITT X.509 protocol [<a href="Applied%20Cryptography_split_035.html#r303" class="calibre5 pcalibre">303</a>]. It has uncovered redundancies in many
protocols, including Yahalom, Needham-Schroeder, and Kerberos. Many
published papers use BAN logic to make claims about their protocol’s security
[<a href="Applied%20Cryptography_split_035.html#r40" class="calibre5 pcalibre">40</a>,<a href="Applied%20Cryptography_split_036.html#r1162" class="calibre5 pcalibre">1162</a>,<a href="Applied%20Cryptography_split_035.html#r73" class="calibre5 pcalibre">73</a>].</p>

<p class="calibre9">Other logic systems have been published, some designed as extensions to BAN
logic [<a href="Applied%20Cryptography_split_035.html#r645" class="calibre5 pcalibre">645</a>,<a href="Applied%20Cryptography_split_035.html#r586" class="calibre5 pcalibre">586</a>,<a href="Applied%20Cryptography_split_036.html#r1556" class="calibre5 pcalibre">1556</a>,<a href="Applied%20Cryptography_split_036.html#r828" class="calibre5 pcalibre">828</a>] and others based on BAN to correct perceived
weaknesses [<a href="Applied%20Cryptography_split_036.html#r1488" class="calibre5 pcalibre">1488</a>,<a href="Applied%20Cryptography_split_036.html#r1002" class="calibre5 pcalibre">1002</a>]. The most successful of these is GNY [<a href="Applied%20Cryptography_split_035.html#r645" class="calibre5 pcalibre">645</a>], although
it has some shortcomings [<a href="Applied%20Cryptography_split_035.html#r40" class="calibre5 pcalibre">40</a>]. Probabalistic beliefs were added to BAN logic,
with mixed success, by [<a href="Applied%20Cryptography_split_035.html#r292" class="calibre5 pcalibre">292</a>,<a href="Applied%20Cryptography_split_035.html#r474" class="calibre5 pcalibre">474</a>]. Other formal logics are [<a href="Applied%20Cryptography_split_035.html#r156" class="calibre5 pcalibre">156</a>,<a href="Applied%20Cryptography_split_035.html#r798" class="calibre5 pcalibre">798</a>,<a href="Applied%20Cryptography_split_035.html#r288" class="calibre5 pcalibre">288</a>];
[<a href="Applied%20Cryptography_split_036.html#r1514" class="calibre5 pcalibre">1514</a>] attempts to combine the features of several logics. And [<a href="Applied%20Cryptography_split_036.html#r1124" class="calibre5 pcalibre">1124</a>,<a href="Applied%20Cryptography_split_036.html#r1511" class="calibre5 pcalibre">1511</a>]
present logics where beliefs can change over time.</p>

<p class="calibre9">The fourth approach to the analysis of cryptographic protocols models the
protocol as an algebraic system, expresses the state of the participants’
knowledge about the protocol, and then analyzes the attainability of certain
states. This approach has not received as much attention as formal logics, but
that is changing. It was first used by Michael Merritt [<a href="Applied%20Cryptography_split_036.html#r1076" class="calibre5 pcalibre">1076</a>], who showed that
an algebraic model can be used to analyze cryptographic protocols. Other
approaches are in [<a href="Applied%20Cryptography_split_035.html#r473" class="calibre5 pcalibre">473</a>,<a href="Applied%20Cryptography_split_036.html#r1508" class="calibre5 pcalibre">1508</a>,<a href="Applied%20Cryptography_split_036.html#r1530" class="calibre5 pcalibre">1530</a>,<a href="Applied%20Cryptography_split_036.html#r1531" class="calibre5 pcalibre">1531</a>,<a href="Applied%20Cryptography_split_036.html#r1532" class="calibre5 pcalibre">1532</a>,<a href="Applied%20Cryptography_split_036.html#r1510" class="calibre5 pcalibre">1510</a>,<a href="Applied%20Cryptography_split_036.html#r1612" class="calibre5 pcalibre">1612</a>].</p>

<p class="calibre9">The Navy Research Laboratory’s (NRL) Protocol Analyzer is probably the
most successful application of these techniques [<a href="Applied%20Cryptography_split_036.html#r1512" class="calibre5 pcalibre">1512</a>,<a href="Applied%20Cryptography_split_035.html#r823" class="calibre5 pcalibre">823</a>,<a href="Applied%20Cryptography_split_036.html#r1046" class="calibre5 pcalibre">1046</a>,<a href="Applied%20Cryptography_split_036.html#r1513" class="calibre5 pcalibre">1513</a>]; it has
been used to discover both new and known flaws in a variety of protocols
[<a href="Applied%20Cryptography_split_036.html#r1044" class="calibre5 pcalibre">1044</a>,<a href="Applied%20Cryptography_split_036.html#r1045" class="calibre5 pcalibre">1045</a>,<a href="Applied%20Cryptography_split_036.html#r1047" class="calibre5 pcalibre">1047</a>]. The Protocol Analyzer defines the following actions:</p>

<ul class="calibre13">

<li class="calibre14">Accept (Bob, Alice, <i class="calibre12">M</i>, <i class="calibre12">N</i>). (Bob accepts the message <i class="calibre12">M</i> as from Alice during Bob’s local round <i class="calibre12">N</i>.)
</li>
<li class="calibre14">Learn (Eve, <i class="calibre12">M</i>). (Eve learns <i class="calibre12">M</i>.)
</li>
<li class="calibre14">Send (Alice, Bob, <i class="calibre12">Q</i>, <i class="calibre12">M</i>). (Alice sends <i class="calibre12">M</i> to Bob in response toquery, <i class="calibre12">Q</i>.)
</li>
<li class="calibre14">Request (Bob, Alice, <i class="calibre12">Q</i>, <i class="calibre12">N</i>). (Bob sends <i class="calibre12">Q</i> to Alice during Bob’s local round <i class="calibre12">N</i>.)
</li>

</ul>

<p class="calibre9">From these actions, requirements can be specified. For example:</p>

<ul class="calibre13">

<li class="calibre14">If Bob accepted message <i class="calibre12">M</i> from Alice at some point in the past, then
Eve did not learn <i class="calibre12">M</i> at some point in the past.
</li>
<li class="calibre14">If Bob accepted message <i class="calibre12">M</i> from Alice in Bob’s local round <i class="calibre12">N</i>, then
Alice sent <i class="calibre12">M</i> to Bob as a response to a query in Bob’s local round <i class="calibre12">N</i>.
</li>

</ul>

<p class="calibre9">To use the NRL Protocol Analyzer, a protocol must be specified using the
previous constructs. Then, there are four phases of analysis: defining transition
rules for honest participants, describing operations available to all — honest and
dishonest — participants, describing the basic building blocks of the protocol,
and describing the reduction rules. The point of all this is to show that a given
protocol meets its requirements. Tools like the NRL Protocol Analyzer could
eventually lead to a protocol that can be proven secure.</p>

<p class="calibre9">While much of the work in formal methods involves applying the methods to
existing protocols, there is some push towards using formal methods to design
the protocols in the first place. Some preliminary steps in this direction are
[<a href="Applied%20Cryptography_split_035.html#r711" class="calibre5 pcalibre">711</a>]. The NRL Protocol Analyzer also attempts to do this [<a href="Applied%20Cryptography_split_036.html#r1512" class="calibre5 pcalibre">1512</a>,<a href="Applied%20Cryptography_split_035.html#r222" class="calibre5 pcalibre">222</a>,<a href="Applied%20Cryptography_split_036.html#r1513" class="calibre5 pcalibre">1513</a>].</p>

<p class="calibre9">The application of formal methods to cryptographic protocols is still a fairly
new idea and it’s really hard to figure out where it is headed. At this point, the
weakest link seems to be the formalization process.</p>

<h3 id="3.5" class="calibre7">3.5 Multiple-Key Public-Key Cryptography</h3>

<p class="calibre9">Public-key cryptography uses two keys. A message encrypted with one key
can be decrypted with the other. Usually one key is private and the other is
public. However, let’s assume that Alice has one key and Bob has the other.
Now Alice can encrypt a message so that only Bob can decrypt it, and Bob can
encrypt a message so that only Alice can read it.</p>

<p class="calibre9">This concept was generalized by Colin Boyd [<a href="Applied%20Cryptography_split_035.html#r217" class="calibre5 pcalibre">217</a>]. Imagine a variant of
public-key cryptography with three keys: <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub>, <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub>, and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub>, distributed as shown in Table 3.2.</p>

<table class="data-table1" id="table-3-2">
<caption class="calibre23">TABLE 3.2 - Three-Key Key Distribution</caption>
<tbody class="calibre24"><tr class="calibre25"><td class="calibre36">Alice</td><td class="calibre29"><i class="calibre12">K<sub class="calibre15">A</sub></i></td></tr>
<tr class="calibre25"><td class="calibre37">Bob</td><td class="calibre27"><i class="calibre12">K<sub class="calibre15">B</sub></i></td></tr>
<tr class="calibre25"><td class="calibre37">Carol</td><td class="calibre27"><i class="calibre12">K<sub class="calibre15">C</sub></i></td></tr>
<tr class="calibre25"><td class="calibre37">Dave</td><td class="calibre27"><i class="calibre12">K<sub class="calibre15">A</sub></i> and <i class="calibre12">K<sub class="calibre15">B</sub></i></td></tr>
<tr class="calibre25"><td class="calibre37">Ellen</td><td class="calibre27"><i class="calibre12">K<sub class="calibre15">B</sub></i> and <i class="calibre12">K<sub class="calibre15">C</sub></i></td></tr>
<tr class="calibre25"><td class="calibre38">Frank</td><td class="calibre28"><i class="calibre12">K<sub class="calibre15">C</sub></i> and <i class="calibre12">K<sub class="calibre15">A</sub></i></td></tr>
</tbody></table>

<p class="calibre39">Alice can encrypt a message with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> so that Ellen, with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub>, can decrypt it. So can Bob and Carol in collusion. Bob can encrypt a message so
that Frank can read it, and Carol can encrypt a message so that Dave can read
it. Dave can encrypt a message with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> so that Ellen can read it, with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> so that Frank can read it, or with both <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> so that Carol can read it.
Similarly, Ellen can encrypt a message so that either Alice, Dave, or Frank can
read it. All the possible combinations are summarized in Table 3.3; there are
no other ones.</p>

<table class="data-table1" id="table-3-3">
<caption class="calibre23">TABLE 3.3 - Three-Key Message Encryption</caption>
<tbody class="calibre24"><tr class="calibre25"><th class="calibre26">Must be Decrypted with Keys:</th><th class="calibre26">Encrypted with Keys:</th></tr>
<tr class="calibre25"><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub></td><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td></tr>
<tr class="calibre25"><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub></td><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td></tr>
<tr class="calibre25"><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub></td></tr>
<tr class="calibre25"><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub></td><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td></tr>
<tr class="calibre25"><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td><td class="calibre40"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub></td></tr>
<tr class="calibre25"><td class="calibre41"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub></td><td class="calibre41"><i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub></td></tr>
</tbody></table>

<p class="calibre39">This can be extended to <i class="calibre12">n</i> keys. If a given subset of the keys is used to encrypt the message, then the other keys are required to decrypt the message.</p>

<h4 class="calibre8">Broadcasting a Message</h4>

<p class="calibre9">Imagine that you have 100 operatives out in the field. You want to be able to
send messages to subsets of them, but don’t know which subsets in advance.
You can either encrypt the message separately for each person or give out keys
for every possible combination of people. The first option requires a lot of
messages; the second requires a lot of keys.</p>

<p class="calibre9">Multiple-key cryptography is much easier. We’ll use three operatives: Alice,
Bob, and Carol. You give Alice <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub>, Bob <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub>, and Carol <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub> and
<i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub>. Now you can talk to any subset you want. If you want to send a message
so that only Alice can read it, encrypt it with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub>. When Alice receives the
message, she decrypts it with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and then <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub>. If you want to send a message so that only Bob can read it, encrypt it with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub>; so that only Carol can read it, with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">B</i></sub>. If you want to send a message so that both Alice and Bob can read it, encrypt it with <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">A</i></sub> and <i class="calibre12">K</i><sub class="calibre15"><i class="calibre22">C</i></sub>, and so on.</p>

<p class="calibre9">This might not seem exciting, but with 100 operatives it is quite efficient.
Individual messages mean a shared key with each operative (100 keys total)
and each message. Keys for every possible subset means 2<sup class="calibre19">100</sup> - 2 different
keys (messages to all operatives and messages to no operatives are excluded).
This scheme needs only one encrypted message and 100 different keys. The
drawback of this scheme is that you also have to broadcast which subset of
operatives can read the message, otherwise each operative would have to try
every combination of possible keys looking for the correct one. Even just the
names of the intended recipients may be significant. At least for the
straightforward implementation of this, everyone gets a really large amount of
key data.</p>

<p class="calibre9">There are other techniques for message broadcasting, some of which avoid the
previous problem. These are discussed in <a href="Applied%20Cryptography_split_025.html#22.7" class="calibre5 pcalibre">Section 22.7</a>.</p>

<h3 id="3.6" class="calibre7">3.6 Secret Splitting</h3>

<p class="calibre9">Imagine that you’ve invented a new, extra gooey, extra sweet, cream filling or
a burger sauce that is even more tasteless than your competitors’. This is
important; you have to keep it secret. You could tell only your most trusted
employees the exact mixture of ingredients, but what if one of them defects to
the competition? There goes the secret, and before long every grease palace on
the block will be making burgers with sauce as tasteless as yours.</p>

<p class="calibre9">This calls for <b class="calibre10">secret splitting</b>. There are ways to take a message and divide it up into pieces [<a href="Applied%20Cryptography_split_035.html#r551" class="calibre5 pcalibre">551</a>]. Each piece by itself means nothing, but put them together
and the message appears. If the message is the recipe and each employee has a
piece, then only together can they make the sauce. If any employee resigns
with his single piece of the recipe, his information is useless by itself.</p>

<p class="calibre9">The simplest sharing scheme splits a message between two people. Here’s a
protocol in which Trent can split a message between Alice and Bob:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Trent generates a random-bit string, <i class="calibre32">R</i>, the same length as the
message, <i class="calibre32">M</i>.
</li>
<li class="pcalibre1 calibre30">Trent XORs <i class="calibre32">M</i> with <i class="calibre32">R</i> to generate <i class="calibre32">S</i>.
<p class="math1"><i class="calibre32">M</i> ⊕ <i class="calibre32">R</i> = <i class="calibre32">S</i>
</p>
</li>
<li class="pcalibre1 calibre30">Trent gives <i class="calibre32">R</i> to Alice and <i class="calibre32">S</i> to Bob.
</li>

</ol>

<p class="calibre9">To reconstruct the message, Alice and Bob have only one step to do:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Alice and Bob XOR their pieces together to reconstruct the
message:
<p class="math1"><i class="calibre32">R</i> ⊕ <i class="calibre32">S</i> = <i class="calibre32">M</i>
</p>
</li>

</ol>

<p class="calibre9">This technique, if done properly, is absolutely secure. Each piece, by itself, is
absolutely worthless. Essentially, Trent is encrypting the message with a
one-time pad and giving the ciphertext to one person and the pad to the other
person. <a href="Applied%20Cryptography_split_001.html#1.5" class="calibre5 pcalibre">Section 1.5</a> discusses one-time pads; they have perfect security. No
amount of computing power can determine the message from one of the
pieces.</p>

<p class="calibre9">It is easy to extend this scheme to more people. To split a message among
more than two people, XOR more random-bit strings into the mixture. In this
example, Trent divides up a message into four pieces:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Trent generates three random-bit strings, <i class="calibre32">R</i>, <i class="calibre32">S</i>, and <i class="calibre32">T</i>, the same length as the message, <i class="calibre32">M</i>.
</li>
<li class="pcalibre1 calibre30">Trent XORs <i class="calibre32">M</i> with the three strings to generate <i class="calibre32">U</i>:
<p class="math1"><i class="calibre32">M</i> ⊕ <i class="calibre32">R</i> ⊕ <i class="calibre32">S</i> ⊕ <i class="calibre32">T</i> = <i class="calibre32">U</i>
</p>
</li>
<li class="pcalibre1 calibre30">Trent gives <i class="calibre32">R</i> to Alice, <i class="calibre32">S</i> to Bob, <i class="calibre32">T</i> to Carol, and <i class="calibre32">U</i> to Dave.
</li>

</ol>

<p class="calibre9">Alice, Bob, Carol, and Dave, working together, can reconstruct the message:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Alice, Bob, Carol, and Dave get together and compute:
<p class="math1"><i class="calibre32">R</i> ⊕ <i class="calibre32">S</i> ⊕ <i class="calibre32">T</i> ⊕ <i class="calibre32">U</i> = <i class="calibre32">M</i>
</p>
</li>

</ol>

<p class="calibre9">This is an adjudicated protocol. Trent has absolute power and can do whatever
he wants. He can hand out gibberish and claim that it is a valid piece of the
secret; no one will know it until they try to reconstruct the secret. He can hand
out a piece to Alice, Bob, Carol, and Dave, and later tell everyone that only
Alice, Carol, and Dave are needed to reconstruct the secret, and then fire Bob.
But since this is Trent’s secret to divide up, this isn’t a problem.</p>

<p class="calibre9">However, this protocol has a problem: If any of the pieces gets lost and Trent
isn’t around, so does the message. If Carol, who has a piece of the sauce
recipe, goes to work for the competition and takes her piece with her, the rest
of them are out of luck. She can’t reproduce the recipe, but neither can Alice,
Bob, and Dave working together. Her piece is as critical to the message as
every other piece combined. All Alice, Bob, or Dave know is the length of the
message — nothing more. This is true because <i class="calibre12">R</i>, <i class="calibre12">S</i>, <i class="calibre12">T</i>, <i class="calibre12">U</i>, and <i class="calibre12">M</i> all have the
same length; seeing anyone of them gives the length of <i class="calibre12">M</i>. Remember, <i class="calibre12">M</i> isn’t being split in the normal sense of the word; it is being XORed with random
values.</p>

<h3 id="3.7" class="calibre7">3.7 Secret Sharing</h3>

<p class="calibre9">You’re setting up a launch program for a nuclear missile. You want to make
sure that no single raving lunatic can initiate a launch. You want to make sure
that no two raving lunatics can initiate a launch. You want at least three out of
five officers to be raving lunatics before you allow a launch.</p>

<p class="calibre9">This is easy to solve. Make a mechanical launch controller. Give each of the
five officers a key and require that at least three officers stick their keys in the
proper slots before you’ll allow them to blow up whomever we’re blowing up
this week. (If you’re really worried, make the slots far apart and require the
officers to insert the keys simultaneously — you wouldn’t want an officer who
steals two keys to be able to vaporize Toledo.)</p>

<p class="calibre9">We can get even more complicated. Maybe the general and two colonels are
authorized to launch the missile, but if the general is busy playing golf then
five colonels are required to initiate a launch. Make the launch controller so
that it requires five keys. Give the general three keys and the colonels one
each. The general together with any two colonels can launch the missile; so
can the five colonels. However, a general and one colonel cannot; neither can
four colonels.</p>

<p class="calibre9">A more complicated sharing scheme, called a <b class="calibre10">threshold scheme</b>, can do all of
this and more — mathematically. At its simplest level, you can take any
message (a secret recipe, launch codes, your laundry list, etc.) and divide it
into <i class="calibre12">n</i> pieces, called <b class="calibre10">shadows or shares</b>, such that any <i class="calibre12">m</i> of them can be used to reconstruct the message. More precisely, this is called an <b class="calibre10">(<i class="calibre12">m,n</i></b><b class="calibre10">)-threshold</b> <b class="calibre10">scheme</b>.</p>

<p class="calibre9">With a (3,4)-threshold scheme, Trent can divide his secret sauce recipe among
Alice, Bob, Carol, and Dave, such that any three of them can put their shadows
together and reconstruct the message. If Carol is on vacation, Alice, Bob, and
Dave can do it. If Bob gets run over by a bus, Alice, Carol, and Dave can do it.
However, if Bob gets run over by a bus while Carol is on vacation, Alice and
Dave can’t reconstruct the message by themselves.</p>

<p class="calibre9">General threshold schemes are even more versatile. Any sharing scenario you
can imagine can be modeled. You can divide a message among the people in
your building so that to reconstruct it, you need seven people from the first
floor and five people from the second floor, unless there is someone from the
third floor involved, in which case you only need that person and three people
from the first floor and two people from the second floor, unless there is
someone from the fourth floor involved, in which case you need that person
and one person from the third floor, or that person and two people from the
first floor and one person from the second floor, unless there is...well, you get
the idea.</p>

<p class="calibre9">This idea was invented independently by Adi Shamir [<a href="Applied%20Cryptography_split_036.html#r1414" class="calibre5 pcalibre">1414</a>] and George
Blakley [<a href="Applied%20Cryptography_split_035.html#r182" class="calibre5 pcalibre">182</a>] and studied extensively by Gus Simmons [<a href="Applied%20Cryptography_split_036.html#r1466" class="calibre5 pcalibre">1466</a>]. Several
different algorithms are discussed in <a href="Applied%20Cryptography_split_026.html#23.2" class="calibre5 pcalibre">Section 23.2</a>.</p>

<h4 class="calibre8">Secret Sharing with Cheaters</h4>

<p class="calibre9">There are many ways to cheat with a threshold scheme. Here are just a few of
them.</p>

<p class="calibre9">Scenario 1: Colonels Alice, Bob, and Carol are in a bunker deep below some
isolated field. One day, they get a coded message from the president: “Launch
the missiles. We’re going to eradicate the last vestiges of neural network
research in the country.” Alice, Bob, and Carol reveal their shadows, but Carol
enters a random number. She’s actually a pacifist and doesn’t want the
missiles launched. Since Carol doesn’t enter the correct shadow, the secret
they recover is the wrong secret. The missiles stay in their silos. Even worse,
no one knows why. Alice and Bob, even if they work together, cannot prove
that Carol’s shadow is invalid.</p>

<p class="calibre9">Scenario 2: Colonels Alice and Bob are sitting in the bunker with Mallory.
Mallory has disguised himself as a colonel and none of the others is the wiser.
The same message comes in from the president, and everyone reveals their
shadows. “Bwa-ha-ha!” shouts Mallory. “I faked that message from the
president. Now I know both of your shadows.” He races up the staircase and
escapes before anyone can catch him.</p>

<p class="calibre9">Scenario 3: Colonels Alice, Bob, and Carol are sitting in the bunker with
Mallory, who is again disguised. (Remember, Mallory doesn’t have a valid
shadow.) The same message comes in from the president and everyone reveals
their shadows. Mallory reveals his shadow only after he has heard the other
three. Since only three shadows are needed to reconstruct the secret, he can
quickly create a valid shadow and reveals that. Now, not only does he know
the secret, but no one realizes that he isn’t part of the scheme.</p>

<p class="calibre9">Some protocols that handle these sorts of cheaters are discussed in <a href="Applied%20Cryptography_split_026.html#23.2" class="calibre5 pcalibre">Section 23.2</a>.</p>

<h4 class="calibre8">Secret Sharing without Trent</h4>

<p class="calibre9">A bank wants its vault to open only if three out of five officers enter their keys.
This sounds like a basic (3,5)-threshold scheme, but there’s a catch. No one is
to know the entire secret. There is no Trent to divide the secret up into five
pieces. There are protocols by which the five officers can create a secret and
each get a piece, such that none of the officers knows the secret until they all
reconstruct it. I’m not going to discuss these protocols in this book; see [<a href="Applied%20Cryptography_split_035.html#r756" class="calibre5 pcalibre">756</a>]
for details.</p>

<h4 class="calibre8">Sharing a Secret without Revealing the Shares</h4>

<p class="calibre9">These schemes have a problem. When everyone gets together to reconstruct
their secret, they reveal their shares. This need not be the case. If the shared
secret is a private key (to a digital signature, for example), then <i class="calibre12">n</i> shareholders can each complete a partial signature of the document. After the <i class="calibre12">n</i> th partial
signature, the document has been signed with the shared private key and none
of the shareholders learns any other shares. The point is that the secret can be
reused, and you don’t need a trusted processor to handle it. This concept is
explored further by Yvo Desmedt and Yair Frankel [<a href="Applied%20Cryptography_split_035.html#r483" class="calibre5 pcalibre">483</a>,<a href="Applied%20Cryptography_split_035.html#r484" class="calibre5 pcalibre">484</a>].</p>

<h4 class="calibre8">Verifiable Secret Sharing</h4>

<p class="calibre9">Trent gives Alice, Bob, Carol, and Dave each a share or at least he says he
does. The only way any of them know if they have a valid share is to try to
reconstruct the secret. Maybe Trent sent Bob a bogus share or Bob
accidentally received a bad share through communications error. Verifiable
secret sharing allows each of them to individually verify that they have a valid
share, without having to reconstruct the secret [<a href="Applied%20Cryptography_split_035.html#r558" class="calibre5 pcalibre">558</a>,<a href="Applied%20Cryptography_split_036.html#r1235" class="calibre5 pcalibre">1235</a>].</p>

<h4 class="calibre8">Secret-Sharing Schemes with Prevention</h4>

<p class="calibre9">A secret is divided up among 50 people so that any 10 can get together and
reconstruct the secret. That’s easy. But, can we implement the same
secret-sharing scheme with the added constraint that 20 people can get
together and <i class="calibre12">prevent</i> the others from reconstructing the secret, no matter how
many of them there are? As it turns out, we can [<a href="Applied%20Cryptography_split_035.html#r153" class="calibre5 pcalibre">153</a>].</p>

<p class="calibre9">The math is complicated, but the basic idea is that everyone gets two shares: a
“yes” share and a “no” share. When it comes time to reconstruct the secret,
people submit one of their shares. The actual share they submit depends on
whether they wish the secret reconstructed. If there are <i class="calibre12">m</i> or more “yes” shares and fewer than <i class="calibre12">n</i> “no” shares, the secret can be reconstructed. Otherwise, it
cannot.</p>

<p class="calibre9">Of course, nothing prevents a sufficient number of “yes” people from going
off in a corner without the “no” people (assuming they know who they are)
and reconstructing the secret. But in a situation where everyone submits their
shares into a central computer, this scheme will work.</p>

<h4 class="calibre8">Secret Sharing with Disenrollment</h4>

<p class="calibre9">You’ve set up your secret-sharing system and now you want to fire one of your
shareholders. You could set up a new scheme without that person, but that’s
time-consuming. There are methods for coping with this system. They allow a
new sharing scheme to be activated instantly once one of the participants
becomes untrustworthy [<a href="Applied%20Cryptography_split_036.html#r1004" class="calibre5 pcalibre">1004</a>].</p>

<h3 id="3.8" class="calibre7">3.8 Cryptographic Protection of Databases</h3>

<p class="calibre9">The membership database of an organization is a valuable commodity. On the
one hand, you want to distribute the database to all members. You want them
to communicate with one another, exchange ideas, and invite each other over
for cucumber sandwiches. On the other hand, if you distribute the membership
database to everyone, copies are bound to fall into the hands of insurance
salesmen and other annoying purveyors of junk mail.</p>

<p class="calibre9">Cryptography can ameliorate this problem. We can encrypt the database so
that it is easy to extract the address of a single person but hard to extract a
mailing list of all the members.</p>

<p class="calibre9">The scheme, from [<a href="Applied%20Cryptography_split_035.html#r550" class="calibre5 pcalibre">550</a>,<a href="Applied%20Cryptography_split_035.html#r549" class="calibre5 pcalibre">549</a>], is straightforward. Choose a one-way hash
function and a symmetric encryption algorithm. Each record of the database
has two fields. The index field is the last name of the member, operated on by
the one-way hash function. The data field is the full name and address of the
member, encrypted using the last name as the key. Unless you know the last
name, you can’t decrypt the data field.</p>

<p class="calibre9">Searching a specific last name is easy. First, hash the last name and look for
the hashed value in the index field of the database. If there is a match, then that
last name is in the database. If there are several matches, then there are several
people in the database with the last name. Finally, for each matching entry,
decrypt the full name and address using the last name as the key.</p>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_035.html#r550" class="calibre5 pcalibre">550</a>] the authors use this system to protect a dictionary of 6000 Spanish
verbs. They report minimal performance degradation due to the encryption.
Additional complications in [<a href="Applied%20Cryptography_split_035.html#r549" class="calibre5 pcalibre">549</a>] handle searches on multiple indexes, but the
idea is the same. The primary problem with this system is that it’s impossible
to search for people when you don’t know how to spell their name. You can
try variant spellings until you find the correct one, but it isn’t practical to scan
through everyone whose name begins with “Sch” when looking for
“Schneier.”</p>

<p class="calibre9">This protection isn’t perfect. It is possible for a particularly persistent
insurance salesperson to reconstruct the membership database through
brute-force by trying every possible last name. If he has a telephone database,
he can use it as a list of possible last names. This might take a few weeks of
dedicated number crunching, but it can be done. It makes his job harder and, in
the world of junk mail, “harder” quickly becomes “too expensive.”</p>

<p class="calibre9">Another approach, in [<a href="Applied%20Cryptography_split_035.html#r185" class="calibre5 pcalibre">185</a>], allows statistics to be compiled on encrypted data.</p>

<div class="calibre6" id="calibre_pb_8"></div>
</div>






</body></html>
