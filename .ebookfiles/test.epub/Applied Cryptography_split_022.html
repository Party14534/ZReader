<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="19">Chapter 19 <br class="calibre3"/>
Public-Key Algorithms</h1>

<h3 id="19.1" class="calibre7">19.1 Background</h3>

<p class="calibre9">The concept of public-key cryptography was invented by Whitfield Diffie and
Martin Hellman, and independently by Ralph Merkle. Their contribution to
cryptography was the notion that keys could come in pairs — an encryption key
and a decryption key — and that it could be infeasible to generate one key from
the other (see <a href="Applied%20Cryptography_split_003.html#2.5" class="calibre5 pcalibre">Section 2.5</a>). Diffie and Hellman first presented this concept at
the 1976 National Computer Conference [<a href="Applied%20Cryptography_split_035.html#r495" class="calibre5 pcalibre">495</a>]; a few months later, their
seminal paper “New Directions in Cryptography” was published [<a href="Applied%20Cryptography_split_035.html#r496" class="calibre5 pcalibre">496</a>]. (Due
to a glacial publishing process, Merkle’s first contribution to the field didn’t
appear until 1978 [<a href="Applied%20Cryptography_split_036.html#r1064" class="calibre5 pcalibre">1064</a>].)</p>

<p class="calibre9">Since 1976, numerous public-key cryptography algorithms have been
proposed. Many of these are insecure. Of those still considered secure, many
are impractical. Either they have too large a key or the ciphertext is much
larger than the plaintext.</p>

<p class="calibre9">Only a few algorithms are both secure and practical. These algorithms are
generally based on one of the hard problems discussed in <a href="Applied%20Cryptography_split_014.html#11.2" class="calibre5 pcalibre">Section 11.2</a>. Of
these secure and practical public-key algorithms, some are only suitable for
key distribution. Others are suitable for encryption (and by extension for key
distribution). Still others are only useful for digital signatures. Only three
algorithms work well for both encryption and digital signatures: RSA,
ElGamal, and Rabin. All of these algorithms are slow. They encrypt and
decrypt data much more slowly than symmetric algorithms; usually that’s too
slow to support bulk data encryption.</p>

<p class="calibre9">Hybrid cryptosystems (see <a href="Applied%20Cryptography_split_003.html#2.5" class="calibre5 pcalibre">Section 2.5</a>) speed things up: A symmetric
algorithm with a random session key is used to encrypt the message, and a
public-key algorithm is used to encrypt the random session key.</p>

<h4 class="calibre8">Security of Public-Key Algorithms</h4>

<p class="calibre9">Since a cryptanalyst has access to the public key, he can always choose any
message to encrypt. This means that a cryptanalyst, given <i class="calibre12">C</i> = <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">P</i>), can guess the value of <i class="calibre12">P</i> and easily check his guess. This is a serious problem if the number of possible plaintext messages is small enough to allow exhaustive
search, but can be solved by padding messages with a string of random bits.
This makes identical plaintext messages encrypt to different ciphertext
messages. (For more about this concept, see <a href="Applied%20Cryptography_split_026.html#23.15" class="calibre5 pcalibre">Section 23.15</a>.)</p>

<p class="calibre9">This is especially important if a public-key algorithm is used to encrypt a
session key. Eve can generate a database of all possible session keys encrypted
with Bob’s public key. Sure, this requires a large amount of time and memory,
but for a 40-bit exportable key or a 56-bit DES key, it’s a whole lot less time
and memory than breaking Bob’s public key. Once Eve has generated the
database, she will have his key and can read his mail at will.</p>

<p class="calibre9">Public-key algorithms are designed to resist chosen-plaintext attacks; their
security is based both on the difficulty of deducing the secret key from the
public key and the difficulty of deducing the plaintext from the ciphertext.
However, most public-key algorithms are particularly susceptible to a
chosen-ciphertext attack (see <a href="Applied%20Cryptography_split_001.html#1.1" class="calibre5 pcalibre">Section 1.1</a>).</p>

<p class="calibre9">In systems where the digital signature operation is the inverse of the
encryption operation, this attack is impossible to prevent unless different keys
are used for encryption and signatures.</p>

<p class="calibre9">Consequently, it is important to look at the whole system and not just at the
individual parts. Good public-key protocols are designed so that the various
parties can’t decrypt arbitrary messages generated by other parties — the
proof-of-identity protocols are a good example (see <a href="Applied%20Cryptography_split_006.html#5.2" class="calibre5 pcalibre">Section 5.2</a>).</p>

<h3 id="19.2" class="calibre7">19.2 Knapsack Algorithms</h3>

<p class="calibre9">The first algorithm for generalized public-key encryption was the knapsack
algorithm developed by Ralph Merkle and Martin Hellman [<a href="Applied%20Cryptography_split_035.html#r713" class="calibre5 pcalibre">713</a>,<a href="Applied%20Cryptography_split_036.html#r1074" class="calibre5 pcalibre">1074</a>]. It
could only be used for encryption, although Adi Shamir later adapted the
system for digital signatures [<a href="Applied%20Cryptography_split_036.html#r1413" class="calibre5 pcalibre">1413</a>]. Knapsack algorithms get their security
from the knapsack problem, an <b class="calibre10">NP-complete</b> problem. Although this
algorithm was later found to be insecure, it is worth examining because it
demonstrates how an <b class="calibre10">NP-complete</b> problem can be used for public-key
cryptography.</p>

<p class="calibre9">The knapsack problem is a simple one. Given a pile of items, each with
different weights, is it possible to put some of those items into a knapsack so
that the knapsack weighs a given amount? More formally: Given a set of
values <i class="calibre12">M</i><sub class="calibre15">1</sub>, <i class="calibre12">M</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">M</i><sub class="calibre15">n</sub> , and a sum <i class="calibre12">S, </i> compute the values of <i class="calibre12">b</i><sub class="calibre15">i</sub> such that</p>

<p class="math"><i class="calibre12">S</i> = <i class="calibre12">b</i><sub class="calibre15">1</sub><i class="calibre12">M</i><sub class="calibre15">1</sub> + <i class="calibre12">b</i><sub class="calibre15">2</sub><i class="calibre12">M</i><sub class="calibre15">2</sub> + ... + <i class="calibre12">b</i><sub class="calibre15">n</sub><i class="calibre12">M</i><sub class="calibre15">n</sub>
</p>

<p class="calibre9">The values of <i class="calibre12">b</i><sub class="calibre15">i</sub> can be either zero or one. A one indicates that the item is in the knapsack; a zero indicates that it isn’t.</p>

<p class="calibre9">For example, the items might have weights of 1, 5, 6, 11, 14, and 20. You
could pack a knapsack that weighs 22; use weights 5, 6, and 11. You could not
pack a knapsack that weighs 24. In general, the time required to solve this
problem seems to grow exponentially with the number of items in the pile.</p>

<p class="calibre9">The idea behind the Merkle-Hellman knapsack algorithm is to encode a
message as a solution to a series of knapsack problems. A block of plaintext
equal in length to the number of items in the pile would select the items in the
knapsack (plaintext bits corresponding to the <i class="calibre12">b</i> values), and the ciphertext
would be the resulting sum. Figure 19.1 shows a plaintext encrypted with a
sample knapsack problem.</p>

<div class="figure" id="figure-19-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-19-1.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 19.1</b> Encryption with knapsacks.</i></p>
</div>

<p class="calibre9">The trick is that there are actually two different knapsack problems, one
solvable in linear time and the other believed not to be. The easy knapsack can
be modified to create the hard knapsack. The public key is the hard knapsack,
which can easily be used to encrypt but cannot be used to decrypt messages.
The private key is the easy knapsack, which gives an easy way to decrypt
messages. People who don’t know the private key are forced to try to solve the
hard knapsack problem.</p>

<h4 class="calibre8">Superincreasing Knapsacks</h4>

<p class="calibre9">What is the easy knapsack problem? If the list of weights is a <b class="calibre10">superincreasing</b>
<b class="calibre10">sequence</b>, then the resulting knapsack problem is easy to solve. A
superincreasing sequence is a sequence in which every term is greater than the
sum of all the previous terms. For example, {1, 3, 6, 13, 27, 52} is a
superincreasing sequence, but {1, 3, 4, 9, 15, 25} is not.</p>

<p class="calibre9">The solution to a <b class="calibre10">superincreasing knapsack</b> is easy to find. Take the total
weight and compare it with the largest number in the sequence. If the total
weight is less than the number, then it is not in the knapsack. If the total
weight is greater than or equal to the number, then it is in the knapsack.
Reduce the weight of the knapsack by the value and move to the next largest
number in the sequence. Repeat until finished. If the total weight has been
brought to zero, then there is a solution. If the total weight has not, there isn’t.</p>

<p class="calibre9">For example, consider a total knapsack weight of 70 and a sequence of weights
of {2, 3, 6, 13, 27, 52}. The largest weight, 52, is less than 70, so 52 is in the
knapsack. Subtracting 52 from 70 leaves 18. The next weight, 27, is greater
than 18, so 27 is not in the knapsack. The next weight, 13, is less than 18, so
13 is in the knapsack. Subtracting 13 from 18 leaves 5. The next weight, 6, is
greater than 5, so 6 is not in the knapsack. Continuing this process will show
that both 2 and 3 are in the knapsack and the total weight is brought to 0,
which indicates that a solution has been found. Were this a Merkle-Hellman
knapsack encryption block, the plaintext that resulted from a ciphertext value
of 70 would be 110101.</p>

<p class="calibre9">Non-superincreasing, or normal, knapsacks are hard problems; they have no
known quick algorithm. The only known way to determine which items are in
the knapsack is to methodically test possible solutions until you stumble on the
correct one. The fastest algorithms, taking into account the various heuristics,
grow exponentially with the number of possible weights in the knapsack. Add
one item to the sequence of weights, and it takes twice as long to find the
solution. This is much more difficult than a superincreasing knapsack where, if
you add one more weight to the sequence, it simply takes another operation to
find the solution.</p>

<p class="calibre9">The Merkle-Hellman algorithm is based on this property. The private key is a
sequence of weights for a superincreasing knapsack problem. The public key is
a sequence of weights for a normal knapsack problem with the same solution.
Merkle and Hellman developed a technique for converting a superincreasing
knapsack problem into a normal knapsack problem. They did this using
modular arithmetic.</p>

<h4 class="calibre8">Creating the Public Key from the Private Key</h4>

<p class="calibre9">Without going into the number theory, this is how the algorithm works: To get
a normal knapsack sequence, take a superincreasing knapsack sequence, for
example {2, 3, 6, 13, 27, 52}, and multiply all of the values by a number <i class="calibre12">n, </i>
mod <i class="calibre12">m</i>. The modulus should be a number greater than the sum of all the
numbers in the sequence: for example, 105. The multiplier should have no
factors in common with the modulus: for example, 31. The normal knapsack
sequence would then be</p>

<p class="math-left">2 * 31 mod 105 = 62
3 * 31 mod 105 = 93
6 * 31 mod 105 = 81
13 * 31 mod 105 = 88
27 * 31 mod 105 = 102
52 * 31 mod 105 = 37
</p>

<p class="calibre9">The knapsack would then be {62, 93, 81, 88, 102, 37}.</p>

<p class="calibre9">The superincreasing knapsack sequence is the private key. The normal
knapsack sequence is the public key.</p>

<h4 class="calibre8">Encryption</h4>

<p class="calibre9">To encrypt a binary message, first break it up into blocks equal to the number
of items in the knapsack sequence. Then, allowing a one to indicate the item is
present and a zero to indicate that the item is absent, compute the total weights
of the knapsacks — one for every message block.</p>

<p class="calibre9">For example, if the message were 011000110101101110 in binary, encryption
using the previous knapsack would proceed like this:</p>

<p class="math-left">message = 011000 110101 101110
011000 corresponds to 93 + 81 = 174
110101 corresponds to 62 + 93 + 88 + 37 = 280
101110 corresponds to 62 + 81 + 88 + 102 = 333
</p>

<p class="calibre9">The ciphertext would be</p>

<p class="math-left">174,280,333
</p>

<h4 class="calibre8">Decryption</h4>

<p class="calibre9">A legitimate recipient of this message knows the private key: the original
superincreasing knapsack, as well as the values of <i class="calibre12">n</i> and <i class="calibre12">m</i> used to transform it into a normal knapsack. To decrypt the message, the recipient must first
determine <i class="calibre12">n</i><sup class="calibre19">-1</sup> such that <i class="calibre12">n</i>(<i class="calibre12">n</i><sup class="calibre19">-1</sup>) ≡ 1 (mod <i class="calibre12">m</i>). Multiply each of the ciphertext values by <i class="calibre12">n</i><sup class="calibre19">-1</sup> mod <i class="calibre12">m, </i> and then partition with the private knapsack to get the plaintext values.</p>

<p class="calibre9">In our example, the superincreasing knapsack is {2, 3, 6, 13, 27, 52}, <i class="calibre12">m</i> is
equal to 105, and <i class="calibre12">n</i> is equal to 31. The ciphertext message is 174, 280, 333. In this case <i class="calibre12">n</i><sup class="calibre19">-1</sup> is equal to 61, so the ciphertext values must be multiplied by 61
mod 105.</p>

<p class="math-left">174 * 61 mod 105 = 9 = 3 + 6, which corresponds to 011000
280 * 61 mod 105 = 70 = 2 + 3 + 13 + 52, which corresponds to 110101
333 * 61 mod 105 = 48 = 2 + 6 + 13 + 27, which corresponds to 101110
</p>

<p class="calibre9">The recovered plaintext is 011000 110101 101110.</p>

<h4 class="calibre8">Practical Implementations</h4>

<p class="calibre9">With a knapsack sequence of only six items, it’s not hard to solve the problem
even if it isn’t superincreasing. Real knapsacks should contain at least 250
items. The value for each term in the superincreasing knapsack should be
somewhere between 200 and 400 bits long, and the modulus should be
somewhere between 100 to 200 bits long. Real implementations of the
algorithm use random-sequence generators to produce these values.</p>

<p class="calibre9">With knapsacks like that, it’s futile to try to solve them by brute force. If a
computer could try a million possibilities per second, trying all possible
knapsack values would take over 10<sup class="calibre19">46</sup> years. Even a million machines working
in parallel wouldn’t solve this problem before the sun went nova.</p>

<h4 class="calibre8">Security of Knapsacks</h4>

<p class="calibre9">It wasn’t a million machines that broke the knapsack cryptosystem, but a pair
of cryptographers. First a single bit of plaintext was recovered [<a href="Applied%20Cryptography_split_035.html#r725" class="calibre5 pcalibre">725</a>]. Then,
Shamir showed that knapsacks can be broken in certain circumstances [<a href="Applied%20Cryptography_split_036.html#r1415" class="calibre5 pcalibre">1415</a>,<a href="Applied%20Cryptography_split_036.html#r1416" class="calibre5 pcalibre">1416</a>]. 
There were other results — [<a href="Applied%20Cryptography_split_036.html#r1428" class="calibre5 pcalibre">1428</a>,<a href="Applied%20Cryptography_split_035.html#r38" class="calibre5 pcalibre">38</a>,<a href="Applied%20Cryptography_split_035.html#r754" class="calibre5 pcalibre">754</a>,<a href="Applied%20Cryptography_split_035.html#r516" class="calibre5 pcalibre">516</a>,<a href="Applied%20Cryptography_split_035.html#r488" class="calibre5 pcalibre">488</a>] — but no one could
break the general Merkle-Hellman system. Finally, Shamir and Zippel [<a href="Applied%20Cryptography_split_036.html#r1418" class="calibre5 pcalibre">1418</a>,<a href="Applied%20Cryptography_split_036.html#r1419" class="calibre5 pcalibre">1419</a>,<a href="Applied%20Cryptography_split_036.html#r1421" class="calibre5 pcalibre">1421</a>] 
found flaws in the transformation that allowed them to reconstruct
the superincreasing knapsack from the normal knapsack. The exact arguments
are beyond the scope of this book, but a nice summary of them can be found in
[<a href="Applied%20Cryptography_split_036.html#r1233" class="calibre5 pcalibre">1233</a>,<a href="Applied%20Cryptography_split_036.html#r1244" class="calibre5 pcalibre">1244</a>]. At the conference where the results were presented, the attack
was demonstrated on stage using an Apple II computer [<a href="Applied%20Cryptography_split_035.html#r492" class="calibre5 pcalibre">492</a>,<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>].</p>

<h4 class="calibre8">Knapsack Variants</h4>

<p class="calibre9">Since the original Merkle-Hellman scheme was broken, many other knapsack
systems have been proposed: multiple iterated knapsacks, Graham-Shamir
knapsacks, and others. These have all been analyzed and broken, generally
using the same cryptographic techniques, and litter the cryptographic highway
[<a href="Applied%20Cryptography_split_035.html#r260" class="calibre5 pcalibre">260</a>, <a href="Applied%20Cryptography_split_035.html#r253" class="calibre5 pcalibre">253</a>, <a href="Applied%20Cryptography_split_035.html#r269" class="calibre5 pcalibre">269</a>, <a href="Applied%20Cryptography_split_036.html#r921" class="calibre5 pcalibre">921</a>, <a href="Applied%20Cryptography_split_035.html#r15" class="calibre5 pcalibre">15</a>, <a href="Applied%20Cryptography_split_036.html#r919" class="calibre5 pcalibre">919</a>, <a href="Applied%20Cryptography_split_036.html#r920" class="calibre5 pcalibre">920</a>, <a href="Applied%20Cryptography_split_036.html#r922" class="calibre5 pcalibre">922</a>, <a href="Applied%20Cryptography_split_035.html#r366" class="calibre5 pcalibre">366</a>, <a href="Applied%20Cryptography_split_035.html#r254" class="calibre5 pcalibre">254</a>, <a href="Applied%20Cryptography_split_035.html#r263" class="calibre5 pcalibre">263</a>, <a href="Applied%20Cryptography_split_035.html#r255" class="calibre5 pcalibre">255</a>]. Good overviews
of these systems and their cryptanalyses can be found in [<a href="Applied%20Cryptography_split_035.html#r267" class="calibre5 pcalibre">267</a>,<a href="Applied%20Cryptography_split_035.html#r479" class="calibre5 pcalibre">479</a>,<a href="Applied%20Cryptography_split_035.html#r257" class="calibre5 pcalibre">257</a>,<a href="Applied%20Cryptography_split_035.html#r268" class="calibre5 pcalibre">268</a>].</p>

<p class="calibre9">Other algorithms have been proposed that use ideas similar to those used in
knapsack cryptosystems, but these too have been broken. The Lu-Lee
cryptosystem [<a href="Applied%20Cryptography_split_036.html#r990" class="calibre5 pcalibre">990</a>,<a href="Applied%20Cryptography_split_035.html#r13" class="calibre5 pcalibre">13</a>] was broken in [<a href="Applied%20Cryptography_split_035.html#r20" class="calibre5 pcalibre">20</a>,<a href="Applied%20Cryptography_split_035.html#r614" class="calibre5 pcalibre">614</a>,<a href="Applied%20Cryptography_split_036.html#r873" class="calibre5 pcalibre">873</a>]; a modification [<a href="Applied%20Cryptography_split_035.html#r507" class="calibre5 pcalibre">507</a>] is
also insecure [<a href="Applied%20Cryptography_split_036.html#r1620" class="calibre5 pcalibre">1620</a>]. Attacks on the Goodman-McAuley cryptosystem are in
[<a href="Applied%20Cryptography_split_035.html#r646" class="calibre5 pcalibre">646</a>,<a href="Applied%20Cryptography_split_035.html#r647" class="calibre5 pcalibre">647</a>,<a href="Applied%20Cryptography_split_035.html#r267" class="calibre5 pcalibre">267</a>,<a href="Applied%20Cryptography_split_035.html#r268" class="calibre5 pcalibre">268</a>]. The Pieprzyk cryptosystem [<a href="Applied%20Cryptography_split_036.html#r1246" class="calibre5 pcalibre">1246</a>] can be broken by
similar attacks. The Niemi cryptosystem [<a href="Applied%20Cryptography_split_036.html#r1169" class="calibre5 pcalibre">1169</a>], based on modular knapsacks,
was broken in [<a href="Applied%20Cryptography_split_035.html#r345" class="calibre5 pcalibre">345</a>,<a href="Applied%20Cryptography_split_035.html#r788" class="calibre5 pcalibre">788</a>]. A newer multistage knapsack [<a href="Applied%20Cryptography_split_035.html#r747" class="calibre5 pcalibre">747</a>] has not yet been
broken, but I am not optimistic. Another variant is [<a href="Applied%20Cryptography_split_035.html#r294" class="calibre5 pcalibre">294</a>].</p>

<p class="calibre9">While a variation of the knapsack algorithm is currently secure — the
Chor-Rivest knapsack [<a href="Applied%20Cryptography_split_035.html#r356" class="calibre5 pcalibre">356</a>], despite a “specialized attack” [<a href="Applied%20Cryptography_split_035.html#r743" class="calibre5 pcalibre">743</a>] — the amount
of computation required makes it far less useful than the other algorithms
discussed here. A variant, called the Powerline System, is not secure [<a href="Applied%20Cryptography_split_036.html#r958" class="calibre5 pcalibre">958</a>].
Most important, considering the ease with which all the other variations fell, it
doesn’t seem prudent to trust them.</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">The original Merkle-Hellman algorithm is patented in the United States [<a href="Applied%20Cryptography_split_035.html#r720" class="calibre5 pcalibre">720</a>]
and worldwide (see Table 19.1). Public Key Partners (PKP) licenses the
patent, along with other public-key cryptography patents (see <a href="Applied%20Cryptography_split_029.html#25.5" class="calibre5 pcalibre">Section 25.5</a>).
The U.S. patent will expire on August 19, 1997.</p>

<table class="data-table1" id="table-19-1">
<caption class="calibre67">Table 19.1 - Foreign Merkle-Hellman Knapsack Patents</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Country</th>
<th class="calibre26">Number</th>
<th class="calibre26">Date of Issue</th>
</tr>
<tr class="calibre25"><td class="calibre70">Belgium</td><td class="calibre70">871039</td><td class="calibre70">5 Apr 1979</td></tr>
<tr class="calibre25"><td class="calibre70">Netherlands</td><td class="calibre70">7810063</td><td class="calibre70">10 Apr 1979</td></tr>
<tr class="calibre25"><td class="calibre70">Great Britain</td><td class="calibre70">2006580</td><td class="calibre70">2 May 1979</td></tr>
<tr class="calibre25"><td class="calibre70">Germany</td><td class="calibre70">2843583</td><td class="calibre70">10 May 1979</td></tr>
<tr class="calibre25"><td class="calibre70">Sweden</td><td class="calibre70">7810478</td><td class="calibre70">14 May 1979</td></tr>
<tr class="calibre25"><td class="calibre70">France</td><td class="calibre70">2405532</td><td class="calibre70">8 Jun 1979</td></tr>
<tr class="calibre25"><td class="calibre70">Germany</td><td class="calibre70">2843583</td><td class="calibre70">3 Jun 1982</td></tr>
<tr class="calibre25"><td class="calibre70">Germany</td><td class="calibre70">2857905</td><td class="calibre70">15 Jul 1982</td></tr>
<tr class="calibre25"><td class="calibre70">Canada</td><td class="calibre70">1128159</td><td class="calibre70">20 Jul 1982</td></tr>
<tr class="calibre25"><td class="calibre70">Great Britain</td><td class="calibre70">2006580</td><td class="calibre70">18 Aug 1982</td></tr>
<tr class="calibre71"><td class="calibre72">Switzerland</td><td class="calibre72">63416114</td><td class="calibre72">14 Jan 1983</td></tr>
<tr class="calibre25"><td class="calibre70">Italy</td><td class="calibre70">1099780</td><td class="calibre70">28 Sep 1985</td></tr>
</tbody></table>

<h3 id="19.3" class="calibre7">19.3 RSA</h3>

<p class="calibre9">Soon after Merkle’s knapsack algorithm came the first full-fledged public-key
algorithm, one that works for encryption and digital signatures: RSA [<a href="Applied%20Cryptography_split_036.html#r1328" class="calibre5 pcalibre">1328</a>,<a href="Applied%20Cryptography_split_036.html#r1329" class="calibre5 pcalibre">1329</a>]. 
Of all the public-key algorithms proposed over the years, RSA is by far
the easiest to understand and implement. (Martin Gardner published an early
description of the algorithm in his “Mathematical Games” column in <i class="calibre12">Scientific</i>
 <i class="calibre12">American</i> [<a href="Applied%20Cryptography_split_035.html#r599" class="calibre5 pcalibre">599</a>].) It is also the most popular. Named after the three
inventors — Ron Rivest, Adi Shamir, and Leonard Adleman — it has since
withstood years of extensive cryptanalysis. Although the cryptanalysis neither
proved nor disproved RSA’s security, it does suggest a confidence level in the
algorithm.</p>

<p class="calibre9">RSA gets its security from the difficulty of factoring large numbers. The
public and private keys are functions of a pair of large (100 to 200 digits or
even larger) prime numbers. Recovering the plaintext from the public key and
the ciphertext is conjectured to be equivalent to factoring the product of the
two primes.</p>

<p class="calibre9">To generate the two keys, choose two random large prime numbers, <i class="calibre12">p</i> and <i class="calibre12">q</i>.
For maximum security, choose <i class="calibre12">p</i> and <i class="calibre12">q</i> of equal length. Compute the product:</p>

<p class="math"><i class="calibre12">n</i> = <i class="calibre12">pq</i>
</p>

<p class="calibre9">Then randomly choose the encryption key, <i class="calibre12">e</i>, such that <i class="calibre12">e</i> and (<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1) 
are relatively prime. Finally, use the extended Euclidean algorithm to compute the
decryption key, <i class="calibre12">d</i>, such that</p>

<p class="math"><i class="calibre12">ed</i> ≡ 1 mod (<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1)
</p>

<p class="calibre9">In other words,</p>

<p class="math"><i class="calibre12">d</i> = <i class="calibre12">e</i><sup class="calibre19">-1</sup> mod ((<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1))
</p>

<p class="calibre9">Note that <i class="calibre12">d</i> and <i class="calibre12">n</i> are also relatively prime. The numbers <i class="calibre12">e</i> and <i class="calibre12">n</i> are the public key; the number <i class="calibre12">d</i> is the private key. The two primes, <i class="calibre12">p</i> and <i class="calibre12">q</i>, are no longer needed. They should be discarded, but never revealed.</p>

<p class="calibre9">To encrypt a message <i class="calibre12">m</i>, first divide it into numerical blocks smaller than <i class="calibre12">n</i> (with binary data, choose the largest power of 2 less than <i class="calibre12">n</i>). That is, if both <i class="calibre12">p</i> and <i class="calibre12">q</i> are 100-digit primes, then <i class="calibre12">n</i> will have just under 200 digits and each message block, <i class="calibre12">m</i><sub class="calibre15">i</sub> , should be just under 200 digits long. (If you need to
encrypt a fixed number of blocks, you can pad them with a few zeros on the
left to ensure that they will always be less than <i class="calibre12">n</i>.) The encrypted message, <i class="calibre12">c</i>, will be made up of similarly sized message blocks, <i class="calibre12">c</i><sub class="calibre15">i</sub>, of about the same
length. The encryption formula is simply</p>

<p class="math"><i class="calibre12">c</i><sub class="calibre15">i</sub> = <i class="calibre12">m</i><sup class="calibre19">e</sup><sub class="calibre15">i</sub> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">To decrypt a message, take each encrypted block <i class="calibre12">c</i><sub class="calibre15">i</sub> and compute</p>

<p class="math">m<sub class="calibre15">i</sub> = <i class="calibre12">c</i><sub class="calibre15">i</sub><sup class="calibre19">d</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">Since</p>

<p class="math"><i class="calibre12">c</i><sub class="calibre15">i</sub><sup class="calibre19">d</sup> = (<i class="calibre12">m</i><sub class="calibre15">i</sub><sup class="calibre19">e</sup>)<sup class="calibre19">d</sup> = <i class="calibre12">m</i><sub class="calibre15">i</sub><sup class="calibre19">ed</sup> = <i class="calibre12">m</i><sub class="calibre15">i</sub><sup class="calibre19"><i class="calibre22">k</i>(<i class="calibre22">p</i> - 1)(<i class="calibre22">q</i> - 1) + 1</sup> = <i class="calibre12">m</i><sub class="calibre15">i</sub><i class="calibre12">m</i><sub class="calibre15">i</sub><sup class="calibre19"><i class="calibre22">k</i>(<i class="calibre22">p</i> - 1)(<i class="calibre22">q</i> - 1)</sup> = <i class="calibre12">m</i><sub class="calibre15">i</sub> * 1 = <i class="calibre12">m</i><sub class="calibre15">i</sub> ; all (mod <i class="calibre12">n</i>)
</p>

<p class="calibre9">the formula recovers the message. This is summarized in Table 19.2.</p>

<p id="table-19-2" class="calibre9"><b class="calibre10">Table 19.2 - RSA Encryption</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Public Key:</b></i></p>
<p class="math-left"><i class="calibre12">n </i> product of two primes, <i class="calibre12">p</i> and <i class="calibre12">q</i> (<i class="calibre12">p</i> and <i class="calibre12">q</i> must remain secret) <i class="calibre12">e </i> relatively prime to (<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1)
</p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Private Key:</b></i></p>
<p class="math-left"><i class="calibre12">d = e</i><sup class="calibre19">-1</sup> mod ((<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1))
</p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Encrypting:</b></i></p>
<p class="math-left"><i class="calibre12">c</i> = <i class="calibre12">m<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>
</p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Decrypting:</b></i></p>
<p class="math-left"><i class="calibre12">m</i> = <i class="calibre12">c<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>
</p>
<hr class="calibre63"/>

<p class="calibre9">The message could just as easily have been encrypted with <i class="calibre12">d</i> and decrypted
with <i class="calibre12">e</i>; the choice is arbitrary. I will spare you the number theory that proves why this works; most current texts on cryptography cover it in detail.</p>

<p class="calibre9">A short example will probably go a long way to making this clearer. If <i class="calibre12">p</i> = 47
and <i class="calibre12">q</i> = 71, then</p>

<p class="math"><i class="calibre12">n</i> = <i class="calibre12">pq</i> = 3337
</p>

<p class="calibre9">The encryption key, <i class="calibre12">e</i>, must have no factors in common with</p>

<p class="math">(<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1) = 46 * 70 = 3220
</p>

<p class="calibre9">Choose <i class="calibre12">e</i> (at random) to be 79. In that case</p>

<p class="math"><i class="calibre12">d</i> = <i class="calibre12">79</i><sup class="calibre19">-1</sup> mod 3220 = 1019
</p>

<p class="calibre9">This number was calculated using the extended Euclidean algorithm (see
<a href="Applied%20Cryptography_split_014.html#11.3" class="calibre5 pcalibre">Section 11.3</a>). Publish <i class="calibre12">e</i> and <i class="calibre12">n</i>, and keep <i class="calibre12">d</i> secret. Discard <i class="calibre12">p</i> and <i class="calibre12">q</i>.</p>

<p class="calibre9">To encrypt the message</p>

<p class="math"><i class="calibre12">m</i> = 6882326879666683
</p>

<p class="calibre9">first break it into small blocks. Three-digit blocks work nicely in this case. The
message is split into six blocks, <i class="calibre12">m</i><sub class="calibre15">i</sub>, in which</p>

<p class="math-left"><i class="calibre12">m</i><sub class="calibre15">1</sub> = 688
<i class="calibre12">m</i><sub class="calibre15">2</sub> = 232
<i class="calibre12">m</i><sub class="calibre15">3</sub> = 687
<i class="calibre12">m</i><sub class="calibre15">4</sub> = 966
<i class="calibre12">m</i><sub class="calibre15">5</sub> = 668
<i class="calibre12">m</i><sub class="calibre15">6</sub> = 003
</p>

<p class="calibre9">The first block is encrypted as</p>

<p class="math">688<sup class="calibre19">79</sup> mod 3337 = 1570 = <i class="calibre12">c</i><sub class="calibre15">1</sub>
</p>

<p class="calibre9">Performing the same operation on the subsequent blocks generates an
encrypted message:</p>

<p class="math"><i class="calibre12">c</i> = 1570 2756 2091 2276 2423 158
</p>

<p class="calibre9">Decrypting the message requires performing the same exponentiation using the
decryption key of 1019, so</p>

<p class="math">1570<sup class="calibre19">1019</sup> mod 3337 = 688 = <i class="calibre12">m</i><sub class="calibre15">1</sub>
</p>

<p class="calibre9">The rest of the message can be recovered in this manner.</p>

<h4 class="calibre8">RSA in Hardware</h4>

<p class="calibre9">Much has been written on the subject of hardware implementations of RSA
[<a href="Applied%20Cryptography_split_036.html#r1314" class="calibre5 pcalibre">1314</a>,<a href="Applied%20Cryptography_split_036.html#r1474" class="calibre5 pcalibre">1474</a>,<a href="Applied%20Cryptography_split_036.html#r1456" class="calibre5 pcalibre">1456</a>,<a href="Applied%20Cryptography_split_036.html#r1316" class="calibre5 pcalibre">1316</a>,<a href="Applied%20Cryptography_split_036.html#r1485" class="calibre5 pcalibre">1485</a>,<a href="Applied%20Cryptography_split_036.html#r874" class="calibre5 pcalibre">874</a>,<a href="Applied%20Cryptography_split_036.html#r1222" class="calibre5 pcalibre">1222</a>,<a href="Applied%20Cryptography_split_035.html#r87" class="calibre5 pcalibre">87</a>,<a href="Applied%20Cryptography_split_036.html#r1410" class="calibre5 pcalibre">1410</a>,<a href="Applied%20Cryptography_split_036.html#r1409" class="calibre5 pcalibre">1409</a>,<a href="Applied%20Cryptography_split_036.html#r1343" class="calibre5 pcalibre">1343</a>,<a href="Applied%20Cryptography_split_036.html#r998" class="calibre5 pcalibre">998</a>,<a href="Applied%20Cryptography_split_035.html#r367" class="calibre5 pcalibre">367</a>,<a href="Applied%20Cryptography_split_036.html#r1429" class="calibre5 pcalibre">1429</a>,<a href="Applied%20Cryptography_split_035.html#r523" class="calibre5 pcalibre">523</a>,<a href="Applied%20Cryptography_split_035.html#r772" class="calibre5 pcalibre">772</a>]. 
Good survey articles are [<a href="Applied%20Cryptography_split_035.html#r258" class="calibre5 pcalibre">258</a>,<a href="Applied%20Cryptography_split_036.html#r872" class="calibre5 pcalibre">872</a>]. Many different chips
perform RSA encryption [<a href="Applied%20Cryptography_split_036.html#r1310" class="calibre5 pcalibre">1310</a>,<a href="Applied%20Cryptography_split_035.html#r252" class="calibre5 pcalibre">252</a>,<a href="Applied%20Cryptography_split_036.html#r1101" class="calibre5 pcalibre">1101</a>,<a href="Applied%20Cryptography_split_036.html#r1317" class="calibre5 pcalibre">1317</a>,<a href="Applied%20Cryptography_split_036.html#r874" class="calibre5 pcalibre">874</a>,<a href="Applied%20Cryptography_split_035.html#r69" class="calibre5 pcalibre">69</a>,<a href="Applied%20Cryptography_split_035.html#r737" class="calibre5 pcalibre">737</a>,<a href="Applied%20Cryptography_split_035.html#r594" class="calibre5 pcalibre">594</a>,<a href="Applied%20Cryptography_split_036.html#r1275" class="calibre5 pcalibre">1275</a>,<a href="Applied%20Cryptography_split_036.html#r1563" class="calibre5 pcalibre">1563</a>,<a href="Applied%20Cryptography_split_035.html#r509" class="calibre5 pcalibre">509</a>,<a href="Applied%20Cryptography_split_036.html#r1223" class="calibre5 pcalibre">1223</a>]. 
A partial list of currently available RSA chips, from [<a href="Applied%20Cryptography_split_035.html#r150" class="calibre5 pcalibre">150</a>,<a href="Applied%20Cryptography_split_035.html#r258" class="calibre5 pcalibre">258</a>], is 
listed in Table 19.3. Not all are available on the open market.</p>

<table class="data-table1" id="table-19-3">
<caption class="calibre67">Table 19.3 - Existing RSA Chips</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Company</th>
<th class="calibre26">Clock Speed</th>
<th class="calibre26">Baud Rate Per 512 Bits</th>
<th class="calibre26">Clock Cycles Per 512 Bit Encryption</th>
<th class="calibre26">Technology</th>
<th class="calibre26">Bits per Chip</th>
<th class="calibre26">Number of Transistors</th>
</tr>
<tr class="calibre25"><td class="calibre61">Alpha Techn.</td><td class="calibre70">25 MHz</td><td class="calibre70">13 K</td><td class="calibre70">.98 M</td><td class="calibre70">2 micron</td><td class="calibre70">1024</td><td class="calibre70">180,000</td></tr>
<tr class="calibre25"><td class="calibre61">AT&amp;T</td><td class="calibre70">15 MHz</td><td class="calibre70">19 K</td><td class="calibre70">.4 M</td><td class="calibre70">1.5 micron</td><td class="calibre70">298</td><td class="calibre70">100,000</td></tr>
<tr class="calibre25"><td class="calibre61">British Telecom</td><td class="calibre70">10 MHz</td><td class="calibre70">5.1 K</td><td class="calibre70">1 M</td><td class="calibre70">2.5 micron</td><td class="calibre70">256</td><td class="calibre70">——</td></tr>
<tr class="calibre25"><td class="calibre61">Business Sim. Ltd.</td><td class="calibre70">5 MHz</td><td class="calibre70">3.8 K</td><td class="calibre70">.67 M</td><td class="calibre70">Gate Array</td><td class="calibre70">32</td><td class="calibre70">——</td></tr>
<tr class="calibre25"><td class="calibre61">Calmos Syst. Inc.</td><td class="calibre70">20 MHz</td><td class="calibre70">28 K</td><td class="calibre70">.36 M</td><td class="calibre70">2 micron</td><td class="calibre70">593</td><td class="calibre70">95,000</td></tr>
<tr class="calibre25"><td class="calibre61">CNET</td><td class="calibre70">25 MHz</td><td class="calibre70">5.3 K</td><td class="calibre70">2.3 M</td><td class="calibre70">1 micron</td><td class="calibre70">1024</td><td class="calibre70">100,000</td></tr>
<tr class="calibre25"><td class="calibre61">Cryptech</td><td class="calibre70">14 MHz</td><td class="calibre70">17 K</td><td class="calibre70">.4 M</td><td class="calibre70">Gate Array</td><td class="calibre70">120</td><td class="calibre70">33,000</td></tr>
<tr class="calibre25"><td class="calibre61">Cylink</td><td class="calibre70">30 MHz</td><td class="calibre70">6.8 K</td><td class="calibre70">1.2 M</td><td class="calibre70">1.5 micron</td><td class="calibre70">1024</td><td class="calibre70">150,000</td></tr>
<tr class="calibre25"><td class="calibre61">GEC Marconi</td><td class="calibre70">25 MHz</td><td class="calibre70">10.2 K</td><td class="calibre70">.67 M</td><td class="calibre70">1.4 micron</td><td class="calibre70">512</td><td class="calibre70">160,000</td></tr>
<tr class="calibre25"><td class="calibre61">Pijnenburg</td><td class="calibre70">25 MHz</td><td class="calibre70">50 K</td><td class="calibre70">.256 M</td><td class="calibre70">1 micron</td><td class="calibre70">1024</td><td class="calibre70">400,000</td></tr>
<tr class="calibre71"><td class="calibre78">Sandia</td><td class="calibre72">8 MHz</td><td class="calibre72">10 K</td><td class="calibre72">.4 M</td><td class="calibre72">2 micron</td><td class="calibre72">272</td><td class="calibre72">86,000</td></tr>
<tr class="calibre25"><td class="calibre61">Siemens</td><td class="calibre70">5 MHz</td><td class="calibre70">8.5 K</td><td class="calibre70">.3 M</td><td class="calibre70">1 micron</td><td class="calibre70">512</td><td class="calibre70">60,000</td></tr>
</tbody></table>

<h4 class="calibre8">Speed of RSA</h4>

<p class="calibre9">In hardware, RSA is about 1000 times slower than DES. The fastest VLSI
hardware implementation for RSA with a 512-bit modulus has a throughput of
64 kilobits per second [<a href="Applied%20Cryptography_split_035.html#r258" class="calibre5 pcalibre">258</a>]. There are also chips that perform 1024-bit RSA
encryption. Currently chips are being planned that will approach 1 megabit per
second using a 512-bit modulus; they will probably be available in 1995.
Manufacturers have also implemented RSA in smart cards; these
implementations are slower.</p>

<p class="calibre9">In software, DES is about 100 times faster than RSA. These numbers may
change slightly as technology changes, but RSA will never approach the speed
of symmetric algorithms. Table 19.4 gives sample software speeds of RSA
[<a href="Applied%20Cryptography_split_036.html#r918" class="calibre5 pcalibre">918</a>].</p>

<table class="data-table1" id="table-19-4">
<caption class="calibre67">Table 19.4 - RSA Speeds for Different Modulus Lengths with an 8-bit Public Key (on a SPARC II)</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">
</th><th class="calibre26">512 bits</th>
<th class="calibre26">768 bits</th>
<th class="calibre26">1,024 bits</th>
</tr>
<tr class="calibre25"><td class="calibre70">Encrypt</td><td class="calibre70">0.03 sec</td><td class="calibre70">0.05 sec</td><td class="calibre70">0.08 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Decrypt</td><td class="calibre70">0.16 sec</td><td class="calibre70">0.48 sec</td><td class="calibre70">0.93 sec</td></tr>
<tr class="calibre71"><td class="calibre72">Sign</td><td class="calibre72">0.16 sec</td><td class="calibre72">0.52 sec</td><td class="calibre72">0.97 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Verify</td><td class="calibre70">0.02 sec</td><td class="calibre70">0.07 sec</td><td class="calibre70">0.08 sec</td></tr>
</tbody></table>

<h4 class="calibre8">Software Speedups</h4>

<p class="calibre9">RSA encryption goes much faster if you’re smart about choosing a value of <i class="calibre12">e</i>.
The three most common choices are 3, 17, and 65537 (2<sup class="calibre19">16</sup> + 1). (The binary
representation of 65537 has only two ones, so it takes only 17 multiplications
to exponentiate.) X.509 recommends 65537 [<a href="Applied%20Cryptography_split_035.html#r304" class="calibre5 pcalibre">304</a>], PEM recommends 3 [<a href="Applied%20Cryptography_split_035.html#r76" class="calibre5 pcalibre">76</a>],
and PKCS #1 (see <a href="Applied%20Cryptography_split_028.html#24.14" class="calibre5 pcalibre">Section 24.14</a>) recommends 3 or 65537 [<a href="Applied%20Cryptography_split_036.html#r1345" class="calibre5 pcalibre">1345</a>]. There are
no security problems with using any of these three values for <i class="calibre12">e</i> (assuming you
pad messages with random values — see later section), even if a whole group of
users uses the same value for <i class="calibre12">e</i>.</p>

<p class="calibre9">Private key operations can be speeded up with the Chinese remainder theorem
if you save the values of <i class="calibre12">p</i> and <i class="calibre12">q</i>, and additional values such as <i class="calibre12">d</i> mod (<i class="calibre12">p</i> - 1), <i class="calibre12">d</i> mod (<i class="calibre12">q</i> - 1), and <i class="calibre12">q</i><sup class="calibre19">-1</sup> mod <i class="calibre12">p</i> [<a href="Applied%20Cryptography_split_036.html#r1283" class="calibre5 pcalibre">1283</a>,<a href="Applied%20Cryptography_split_036.html#r1276" class="calibre5 pcalibre">1276</a>]. These additional numbers can easily be calculated from the private and public keys.</p>

<h4 class="calibre8">Security of RSA</h4>

<p class="calibre9">The security of RSA depends wholly on the problem of factoring large
numbers. Technically, that’s a lie. It is <i class="calibre12">conjectured</i> that the security of RSA depends on the problem of factoring large numbers. It has never been
mathematically proven that you need to factor <i class="calibre12">n</i> to calculate <i class="calibre12">m</i> from <i class="calibre12">c</i> and <i class="calibre12">e</i>. It is conceivable that an entirely different way to cryptanalyze RSA might be
discovered. However, if this new way allows the cryptanalyst to deduce <i class="calibre12">d</i>, it
could also be used as a new way to factor large numbers. I wouldn’t worry
about it too much.</p>

<p class="calibre9">It is also possible to attack RSA by guessing the value of (<i class="calibre12">p</i> - 1)(<i class="calibre12">q</i> - 1). This attack is no easier than factoring <i class="calibre12">n</i> [<a href="Applied%20Cryptography_split_036.html#r1616" class="calibre5 pcalibre">1616</a>].</p>

<p class="calibre9">For the ultraskeptical, some RSA variants have been proved to be as difficult
as factoring (see <a href="#19.5" class="calibre5 pcalibre">Section 19.5</a>). Also look at [<a href="Applied%20Cryptography_split_035.html#r36" class="calibre5 pcalibre">36</a>], which shows that recovering
even certain bits of information from an RSA-encrypted ciphertext is as hard
as decrypting the entire message.</p>

<p class="calibre9">Factoring <i class="calibre12">n</i> is the most obvious means of attack. Any adversary will have the
public key, <i class="calibre12">e</i>, and the modulus, <i class="calibre12">n</i>. To find the decryption key, <i class="calibre12">d</i>, he has to factor <i class="calibre12">n</i>. <a href="Applied%20Cryptography_split_014.html#11.4" class="calibre5 pcalibre">Section 11.4</a> discusses the current state of factoring technology.
Currently, a 129-decimal-digit modulus is at the edge of factoring technology.
So, <i class="calibre12">n</i> must be larger than that. Read <a href="Applied%20Cryptography_split_009.html#7.2" class="calibre5 pcalibre">Section 7.2</a> on public key length.</p>

<p class="calibre9">It is certainly possible for a cryptanalyst to try every possible <i class="calibre12">d</i> until he
stumbles on the correct one. This brute-force attack is even less efficient than
trying to factor <i class="calibre12">n</i>.</p>

<p class="calibre9">From time to time, people claim to have found easy ways to break RSA, but to
date no such claim has held up. For example, in 1993 a draft paper by William
Payne proposed a method based on Fermat’s little theorem [<a href="Applied%20Cryptography_split_036.html#r1234" class="calibre5 pcalibre">1234</a>].
Unfortunately, this method is also slower than factoring the modulus.</p>

<p class="calibre9">There’s another worry. Most common algorithms for computing primes <i class="calibre12">p</i> and
 <i class="calibre12">q</i> are probabilistic; what happens if <i class="calibre12">p</i> or <i class="calibre12">q</i> is composite? Well, first you can make the odds of that happening as small as you want. And if it does happen,
the odds are that encryption and decryption won’t work properly — you’ll
notice right away. There are a few numbers, called Carmichael numbers,
which certain probabilistic primality algorithms will fail to detect. These are
exceedingly rare, but they are insecure [<a href="Applied%20Cryptography_split_035.html#r746" class="calibre5 pcalibre">746</a>]. Honestly, I wouldn’t worry
about it.</p>

<h4 class="calibre8">Chosen Ciphertext Attack against RSA</h4>

<p class="calibre9">Some attacks work against the implementation of RSA. These are not attacks
against the basic algorithm, but against the protocol. It’s important to realize
that it’s not enough to use RSA. Details matter.</p>

<p class="calibre9"><i class="calibre12">Scenario 1:</i> Eve, listening in on Alice’s communications, manages to collect a
ciphertext message, <i class="calibre12">c</i>, encrypted with RSA in her public key. Eve wants to be
able to read the message. Mathematically, she wants <i class="calibre12">m</i>, in which</p>

<p class="math"><i class="calibre12">m</i> = <i class="calibre12">c<sup class="calibre19">d</sup></i>
</p>

<p class="calibre9">To recover <i class="calibre12">m</i>, she first chooses a random number, <i class="calibre12">r</i>, such that <i class="calibre12">r</i> is less than <i class="calibre12">n</i>.
She gets Alice’s public key, <i class="calibre12">e</i>. Then she computes</p>

<p class="math-left"><i class="calibre12">x</i> = <i class="calibre12">r<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>
<i class="calibre12">y</i> = <i class="calibre12">xc</i> mod <i class="calibre12">n</i>
<i class="calibre12">t</i> = <i class="calibre12">r</i><sup class="calibre19">-1</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">If <i class="calibre12">x</i> = <i class="calibre12">r<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>, then <i class="calibre12">r</i> = <i class="calibre12">x<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>.</p>

<p class="calibre9">Now, Eve gets Alice to sign <i class="calibre12">y</i> with her private key, thereby decrypting <i class="calibre12">y</i>.
(Alice has to sign the message, not the hash of the message.) Remember, Alice
has never seen <i class="calibre12">y</i> before. Alice sends Eve</p>

<p class="math"><i class="calibre12">u</i> = <i class="calibre12">y<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">Now, Eve computes</p>

<p class="math"><i class="calibre12">tu</i> mod <i class="calibre12">n</i> = <i class="calibre12">r</i><sup class="calibre19">-1</sup><i class="calibre12">y</i><sup class="calibre19">d</sup> mod <i class="calibre12">n</i> = <i class="calibre12">r</i><sup class="calibre19">-1</sup><i class="calibre12">x<sup class="calibre19">d</sup>c<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i> = <i class="calibre12">c<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i> = <i class="calibre12">m</i>
</p>

<p class="calibre9">Eve now has <i class="calibre12">m</i>.</p>

<p class="calibre9"><i class="calibre12">Scenario 2:</i> Trent is a computer notary public. If Alice wants a document
notarized, she sends it to Trent. Trent signs it with an RSA digital signature
and sends it back. (No one-way hash functions are used here; Trent encrypts
the entire message with his private key.)</p>

<p class="calibre9">Mallory wants Trent to sign a message he otherwise wouldn’t. Maybe it has a
phony timestamp; maybe it purports to be from another person. Whatever the
reason, Trent would never sign it if he had a choice. Let’s call this message <i class="calibre12">m’</i>.</p>

<p class="calibre9">First, Mallory chooses an arbitrary value <i class="calibre12">x</i> and computes <i class="calibre12">y</i> = <i class="calibre12">x<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>. 
He can easily get <i class="calibre12">e; </i> it’s Trent’s public key and must be public to verify his signatures.
Then he computes <i class="calibre12">m</i> = <i class="calibre12">ym’</i> mod <i class="calibre12">n</i>, and sends <i class="calibre12">m</i> to Trent to sign. Trent returns <i class="calibre12">m’<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>. Now Mallory calculates (<i class="calibre12">m<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>)<i class="calibre12">x</i><sup class="calibre19">-1</sup> mod <i class="calibre12">n</i>, which equals <i class="calibre12">n’<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i> and is the signature of <i class="calibre12">m’</i>.</p>

<p class="calibre9">Actually, Mallory can use several methods to accomplish these same things
[<a href="Applied%20Cryptography_split_035.html#r423" class="calibre5 pcalibre">423</a>,<a href="Applied%20Cryptography_split_035.html#r458" class="calibre5 pcalibre">458</a>,<a href="Applied%20Cryptography_split_035.html#r486" class="calibre5 pcalibre">486</a>]. The weakness they all exploit is that exponentiation preserves
the multiplicative structure of the input. That is:</p>

<p class="math">(<i class="calibre12">xm</i>)<sup class="calibre19">d</sup> mod <i class="calibre12">n</i> = <i class="calibre12">x<sup class="calibre19">d</sup>m<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>
</p>

<p class="calibre9"><i class="calibre12">Scenario 3:</i> Eve wants Alice to sign <i class="calibre12">m</i><sub class="calibre15">3</sub> . She generates two messages, <i class="calibre12">m</i><sub class="calibre15">1</sub> and <i class="calibre12">m</i><sub class="calibre15">2</sub>, such that</p>

<p class="math"><i class="calibre12">m</i><sub class="calibre15">3</sub> ≡ <i class="calibre12">m</i><sub class="calibre15">1</sub><i class="calibre12">m</i><sub class="calibre15">2</sub> (mod <i class="calibre12">n</i>)
</p>

<p class="calibre9">If Eve can get Alice to sign <i class="calibre12">m</i><sub class="calibre15">1</sub> and <i class="calibre12">m</i><sub class="calibre15">2</sub>, she can calculate <i class="calibre12">m</i><sub class="calibre15">3</sub>:</p>

<p class="math">m<sub class="calibre15">3</sub><sup class="calibre19">d</sup> = (<i class="calibre12">m</i><sub class="calibre15">1</sub><sup class="calibre19">d</sup> mod <i class="calibre12">n</i>)(<i class="calibre12">m</i><sub class="calibre15">2</sub><sup class="calibre19">d</sup> mod <i class="calibre12">n</i>)
</p>


<p class="calibre9">Moral: Never use RSA to sign a random document presented to you by a
stranger. Always use a one-way hash function first. The ISO 9796 block
format prevents this attack.</p>

<h4 class="calibre8">Common Modulus Attack on RSA</h4>

<p class="calibre9">A possible RSA implementation gives everyone the same <i class="calibre12">n</i>, but different
values for the exponents <i class="calibre12">e</i> and <i class="calibre12">d</i>. Unfortunately, this doesn’t work. The most obvious problem is that if the same message is ever encrypted with two
different exponents (both having the same modulus), and those two exponents
are relatively prime (which they generally would be), then the plaintext can be
recovered without either of the decryption exponents [<a href="Applied%20Cryptography_split_036.html#r1457" class="calibre5 pcalibre">1457</a>].</p>

<p class="calibre9">Let <i class="calibre12">m</i> be the plaintext message. The two encryption keys are <i class="calibre12">e</i><sub class="calibre15">1</sub> and <i class="calibre12">e</i><sub class="calibre15">2</sub>. The common modulus is <i class="calibre12">n</i>. The two ciphertext messages are:</p>

<p class="math-left"><i class="calibre12">c</i><sub class="calibre15">1</sub> = <i class="calibre12">m</i><sup class="calibre19">e<sub class="calibre16">1</sub></sup> mod <i class="calibre12">n</i>
<i class="calibre12">c</i><sub class="calibre15">2</sub> = <i class="calibre12">m</i><sup class="calibre19">e<sub class="calibre16">2</sub></sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">The cryptanalyst knows <i class="calibre12">n, e</i><sub class="calibre15">1</sub>, <i class="calibre12">e</i><sub class="calibre15">2</sub>, <i class="calibre12">c</i><sub class="calibre15">1</sub>, and <i class="calibre12">c</i><sub class="calibre15">2</sub>. Here’s how he recovers <i class="calibre12">m</i>.</p>

<p class="calibre9">Since <i class="calibre12">e</i><sub class="calibre15">1</sub> and <i class="calibre12">e</i><sub class="calibre15">2</sub> are relatively prime, the extended Euclidean algorithm can find <i class="calibre12">r</i> and <i class="calibre12">s</i>, such that</p>

<p class="math"><i class="calibre12">r</i>e<sub class="calibre15">1</sub> + <i class="calibre12">s</i>e<sub class="calibre15">2</sub> = 1
</p>

<p class="calibre9">Assuming <i class="calibre12">r</i> is negative (either <i class="calibre12">r</i> or <i class="calibre12">s</i> has to be, so just call the negative one <i class="calibre12">r</i>), then the extended Euclidean algorithm can be used again to calculate <i class="calibre12">c</i><sub class="calibre15">1</sub><sup class="calibre19">-1</sup>. Then</p>

<p class="math">(c<sub class="calibre15">1</sub><sup class="calibre19">-1</sup>)<sup class="calibre19"><i class="calibre22">r</i></sup> * <i class="calibre12">C</i><sub class="calibre15">2</sub><sup class="calibre19">s</sup> = <i class="calibre12">m</i> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">There are two other, more subtle, attacks against this type of system. One
attack uses a probabilistic method for factoring <i class="calibre12">n</i>. The other uses a
deterministic algorithm for calculating someone’s secret key without factoring
the modulus. Both attacks are described in detail in [<a href="Applied%20Cryptography_split_035.html#r449" class="calibre5 pcalibre">449</a>].</p>

<p class="calibre9">Moral: Don’t share a common <i class="calibre12">n</i> among a group of users.</p>

<h4 class="calibre8">Low Encryption Exponent Attack against RSA</h4>

<p class="calibre9">RSA encryption and signature verification are faster if you use a low value for
<i class="calibre12">e</i>, but that can also be insecure [<a href="Applied%20Cryptography_split_035.html#r704" class="calibre5 pcalibre">704</a>]. If you encrypt <i class="calibre12">e</i>(<i class="calibre12">e</i> + 1)/2 linearly dependent messages with different public keys having the same value of <i class="calibre12">e</i>,
there is an attack against the system. If there are fewer than that many
messages, or if the messages are unrelated, there is no problem. If the
messages are identical, then <i class="calibre12">e</i> messages are enough. The easiest solution is to pad 
messages with independent random values. This also ensures that <i class="calibre12">m<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i> ≠ <i class="calibre12">m<sup class="calibre19">e</sup></i>. 
Most real-world RSA implementations — PEM and PGP (see <a href="Applied%20Cryptography_split_028.html#24.10" class="calibre5 pcalibre">Sections 24.10</a> and <a href="Applied%20Cryptography_split_028.html#24.12" class="calibre5 pcalibre">24.12</a>), 
for example — do this.</p>

<p class="calibre9">Moral: Pad messages with random values before encrypting them; make sure
<i class="calibre12">m</i> is about the same size as <i class="calibre12">n</i>.</p>

<h4 class="calibre8">Low Decryption Exponent Attack against RSA</h4>

<p class="calibre9">Another attack, this one by Michael Wiener, will recover <i class="calibre12">d</i>, when <i class="calibre12">d</i> is up to one quarter the size of <i class="calibre12">n</i> and <i class="calibre12">e</i> is less than <i class="calibre12">n</i> [<a href="Applied%20Cryptography_split_036.html#r1596" class="calibre5 pcalibre">1596</a>]. This rarely occurs if <i class="calibre12">e</i> and <i class="calibre12">d</i> are chosen at random, and cannot occur if <i class="calibre12">e</i> has a small value.</p>

<p class="calibre9">Moral: Choose a large value for <i class="calibre12">d</i>.</p>

<h4 class="calibre8">Lessons Learned</h4>

<p class="calibre9">Judith Moore lists several restrictions on the use of RSA, based on the success
of these attacks [<a href="Applied%20Cryptography_split_036.html#r1114" class="calibre5 pcalibre">1114</a>,<a href="Applied%20Cryptography_split_036.html#r1115" class="calibre5 pcalibre">1115</a>]:</p>

<ul class="calibre13">

<li class="calibre14">Knowledge of one encryption/decryption pair of exponents for a
given modulus enables an attacker to factor the modulus.
</li>
<li class="calibre14">Knowledge of one encryption/decryption pair of exponents for a
given modulus enables an attacker to calculate other
encryption/decryption pairs without having to factor <i class="calibre12">n</i>.
</li>
<li class="calibre14">A common modulus should not be used in a protocol using RSA in a
communications network. (This should be obvious from the previous
two points.)
</li>
<li class="calibre14">Messages should be padded with random values to prevent attacks on
low encryption exponents.
</li>
<li class="calibre14">The decryption exponent should be large.
</li>

</ul>

<p class="calibre9">Remember, it is not enough to have a secure cryptographic algorithm. The
entire cryptosystem must be secure, and the cryptographic protocol must be
secure. A failure in any of those three areas makes the overall system insecure.</p>

<h4 class="calibre8">Attack on Encrypting and Signing with RSA</h4>

<p class="calibre9">It makes sense to sign a message before encrypting it (see <a href="Applied%20Cryptography_split_003.html#2.7" class="calibre5 pcalibre">Section 2.7</a>), but not
everyone follows this practice. With RSA, there is an attack against protocols
that encrypt before signing [<a href="Applied%20Cryptography_split_035.html#r48" class="calibre5 pcalibre">48</a>].</p>

<p class="calibre9">Alice wants to send a message to Bob. First she encrypts it with Bob’s public
key; then she signs it with her private key. Her encrypted and signed message
looks like:</p>

<p class="math">(<i class="calibre12">m</i><sup class="calibre19">e<sub class="calibre16">B</sub></sup> mod <i class="calibre12">n</i><sub class="calibre15">B</sub>)<sup class="calibre19">d<sub class="calibre16">A</sub></sup> mod <i class="calibre12">n</i><sub class="calibre15">A</sub>
</p>

<p class="calibre9">Here’s how Bob can claim that Alice sent him <i class="calibre12">m’</i> and not <i class="calibre12">m</i>. Realize that since Bob knows the factorization of <i class="calibre12">n</i><sub class="calibre15">B</sub> (it’s his modulus), he can calculate discrete logarithms with respect to <i class="calibre12">n</i><sub class="calibre15">B</sub>. Therefore, all he has to do is to find an <i class="calibre12">x</i> such that</p>

<p class="math"><i class="calibre12">m’<sup class="calibre19">x</sup></i> = <i class="calibre12">m</i> mod <i class="calibre12">n</i><sub class="calibre15">B</sub>
</p>

<p class="calibre9">Then, if he can publish <i class="calibre12">xe</i> B as his new public exponent and keep <i class="calibre12">n</i><sub class="calibre15">B</sub> as his modulus, 
he can claim that Alice sent him message <i class="calibre12">m’</i> encrypted in this new exponent.</p>

<p class="calibre9">This is a particularly nasty attack in some circumstances. Note that hash
functions don’t solve the problem. However, forcing a fixed encryption
exponent for every user does.</p>

<h4 class="calibre8">Standards</h4>

<p class="calibre9">RSA is a <i class="calibre12">de facto</i> standard in much of the world. The ISO almost, but not
quite, created an RSA digital-signature standard; RSA is in an information
annex to ISO 9796 [<a href="Applied%20Cryptography_split_035.html#r762" class="calibre5 pcalibre">762</a>]. The French banking community standardized on
RSA [<a href="Applied%20Cryptography_split_035.html#r525" class="calibre5 pcalibre">525</a>], as have the Australians [<a href="Applied%20Cryptography_split_036.html#r1498" class="calibre5 pcalibre">1498</a>]. The United States currently has no
standard for public-key encryption, because of pressure from the NSA and
patent issues. Many U.S. companies use PKCS (see <a href="Applied%20Cryptography_split_028.html#24.14" class="calibre5 pcalibre">Section 24.14</a>), written by
RSA Data Security, Inc. A draft ANSI banking standard specifies RSA [<a href="Applied%20Cryptography_split_035.html#r61" class="calibre5 pcalibre">61</a>].</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">The RSA algorithm is patented in the United States [<a href="Applied%20Cryptography_split_036.html#r1330" class="calibre5 pcalibre">1330</a>], but not in any
other country. PKP licenses the patent, along with other public-key
cryptography patents (see <a href="Applied%20Cryptography_split_029.html#25.5" class="calibre5 pcalibre">Section 25.5</a>). The U.S. patent will expire on
September 20, 2000.</p>

<h3 id="19.4" class="calibre7">19.4 Pohlig-Hellman</h3>

<p class="calibre9">The Pohlig-Hellman encryption scheme [<a href="Applied%20Cryptography_split_036.html#r1253" class="calibre5 pcalibre">1253</a>] is similar to RSA. It is not a
symmetric algorithm, because different keys are used for encryption and
decryption. It is not a public-key scheme, because the keys are easily derivable
from each other; both the encryption and decryption keys must be kept secret.</p>

<p class="calibre9">Like RSA,</p>

<p class="math"><i class="calibre12">C</i> = <i class="calibre12">P<sup class="calibre19">e</sup></i> mod <i class="calibre12">n</i>
<i class="calibre12">P</i> = <i class="calibre12">C<sup class="calibre19">d</sup></i> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">where</p>

<p class="math"><i class="calibre12">ed</i> ≡ 1 (mod some complicated number)
</p>

<p class="calibre9">Unlike RSA, <i class="calibre12">n</i> is not defined in terms of two large primes, it must remain part of the secret key. If someone had <i class="calibre12">e</i> and <i class="calibre12">n</i>, they could calculate <i class="calibre12">d</i>. Without knowledge of <i class="calibre12">e</i> or <i class="calibre12">d</i>, an adversary would be forced to calculate</p>

<p class="math"><i class="calibre12">e</i> = <i class="calibre12">log</i><sub class="calibre15">P</sub>C mod <i class="calibre12">n</i>
</p>

<p class="calibre9">We have already seen that this is a hard problem.</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">The Pohlig-Hellman algorithm is patented in the United States [<a href="Applied%20Cryptography_split_035.html#r722" class="calibre5 pcalibre">722</a>] and also
in Canada. PKP licenses the patent, along with other public-key cryptography
patents (see <a href="Applied%20Cryptography_split_029.html#25.5" class="calibre5 pcalibre">Section 25.5</a>).</p>

<h3 id="19.5" class="calibre7">19.5 Rabin</h3>

<p class="calibre9">Rabin’s scheme [<a href="Applied%20Cryptography_split_036.html#r1283" class="calibre5 pcalibre">1283</a>,<a href="Applied%20Cryptography_split_036.html#r1601" class="calibre5 pcalibre">1601</a>] gets its security from the difficulty of finding
square roots modulo a composite number. This problem is equivalent to
factoring. Here is one implementation of this scheme.</p>

<p class="calibre9">First choose two primes, <i class="calibre12">p</i> and <i class="calibre12">q</i>, both congruent to 3 mod 4. These primes are the private key; the product <i class="calibre12">n</i> = <i class="calibre12">pq</i> is the public key.</p>

<p class="calibre9">To encrypt a message, <i class="calibre12">M</i> (<i class="calibre12">M</i> must be less than <i class="calibre12">n</i>), simply compute</p>

<p class="math"><i class="calibre12">C</i> = <i class="calibre12">M</i><sup class="calibre19">2</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">Decrypting the message is just as easy, but slightly more annoying. Since the
receiver knows <i class="calibre12">p</i> and <i class="calibre12">q</i>, he can solve the two congruences using the Chinese remainder theorem. Compute</p>

<p class="math-left"><i class="calibre12">m</i><sub class="calibre15">1</sub> = <i class="calibre12">C</i><sup class="calibre19">(<i class="calibre22">p</i> + 1)/4</sup> mod <i class="calibre12">p</i>
<i class="calibre12">m</i><sub class="calibre15">2</sub> = (<i class="calibre12">p</i> - <i class="calibre12">C</i><sup class="calibre19">(<i class="calibre22">p</i>+ 1)/4</sup>) mod <i class="calibre12">p</i>
<i class="calibre12">m</i><sub class="calibre15">3</sub> = <i class="calibre12">C</i><sup class="calibre19">(<i class="calibre22">q</i> + 1)/4</sup> mod <i class="calibre12">q</i>
<i class="calibre12">m</i><sub class="calibre15">4</sub> = (<i class="calibre12">q</i> - <i class="calibre12">C</i><sup class="calibre19">(<i class="calibre22">q</i> + 1)/4</sup>) mod <i class="calibre12">q</i>
</p>

<p class="calibre9">Then choose an integer <i class="calibre12">a</i> = <i class="calibre12">q</i>(<i class="calibre12">q</i><sup class="calibre19">-1</sup> mod <i class="calibre12">p</i>) and a integer <i class="calibre12">b</i> = <i class="calibre12">p</i>(<i class="calibre12">p</i><sup class="calibre19">-1</sup> mod <i class="calibre12">q</i>). The four possible solutions are:</p>

<p class="math-left"><i class="calibre12">M</i><sub class="calibre15">1</sub> = (<i class="calibre12">am</i><sub class="calibre15">1</sub> + <i class="calibre12">bm</i><sub class="calibre15">3</sub>) mod <i class="calibre12">n</i>
<i class="calibre12">M</i><sub class="calibre15">2</sub> = (<i class="calibre12">am</i><sub class="calibre15">1</sub> + <i class="calibre12">bm</i><sub class="calibre15">4</sub>) mod <i class="calibre12">n</i>
<i class="calibre12">M</i><sub class="calibre15">3</sub> = (<i class="calibre12">am</i><sub class="calibre15">2</sub> + <i class="calibre12">bm</i><sub class="calibre15">3</sub>) mod <i class="calibre12">n</i>
<i class="calibre12">M</i><sub class="calibre15">4</sub> = (<i class="calibre12">am</i><sub class="calibre15">2</sub> + <i class="calibre12">bm</i><sub class="calibre15">4</sub>) mod <i class="calibre12">n</i>
</p>

<p class="calibre9">One of those four results, <i class="calibre12">M</i><sub class="calibre15">1</sub>, <i class="calibre12">M</i><sub class="calibre15">2</sub>, <i class="calibre12">M</i><sub class="calibre15">3</sub>, or <i class="calibre12">M</i><sub class="calibre15">4</sub>, equals <i class="calibre12">M</i>. If the message is English text, it should be easy to choose the correct <i class="calibre12">M</i><sub class="calibre15">i</sub>. On the other hand, if the message is a random-bit stream (say, for key generation or a digital
signature), there is no way to determine which <i class="calibre12">M</i><sub class="calibre15">i</sub> is correct. One way to solve this problem is to add a known header to the message before encrypting.</p>

<h4 class="calibre8">Williams</h4>

<p class="calibre9">Hugh Williams redefined Rabin’s schemes to eliminate these shortcomings
[<a href="Applied%20Cryptography_split_036.html#r1601" class="calibre5 pcalibre">1601</a>]. In his scheme, <i class="calibre12">p</i> and <i class="calibre12">q</i> are selected such that</p>

<p class="math-left"><i class="calibre12">p</i> ≡ 3 mod 8
<i class="calibre12">q</i> ≡ 7 mod 8
</p>

<p class="calibre9">and</p>

<p class="math-left"><i class="calibre12">N</i> = <i class="calibre12">pq</i>
</p>

<p class="calibre9">Also, there is a small integer, <i class="calibre12">S</i>, such that J(<i class="calibre12">S,N</i>) = -1. (J is the Jacobi symbol — see <a href="Applied%20Cryptography_split_014.html#11.3" class="calibre5 pcalibre">Section 11.3</a>). <i class="calibre12">N</i> and <i class="calibre12">S</i> are public. The secret key is <i class="calibre12">k</i>, such that</p>

<p class="math"><i class="calibre12">k</i> = 1/2 * (1/4 * (<i class="calibre12">p</i> - 1) * (<i class="calibre12">q</i> - 1) + 1)
</p>

<p class="calibre9">To encrypt a message <i class="calibre12">M</i>, compute <i class="calibre12">c</i><sub class="calibre15">1</sub> such that J(<i class="calibre12">M,N</i>) = (-1)<sup class="calibre19"><i class="calibre22">c</i><sub class="calibre16">1</sub></sup>. Then, compute <i class="calibre12">M’</i> = (<i class="calibre12">S</i><sup class="calibre19">c<sub class="calibre16">1</sub></sup> * <i class="calibre12">M</i>) mod <i class="calibre12">N</i>. Like Rabin’s scheme, <i class="calibre12">C</i> = <i class="calibre12">M’</i><sup class="calibre19">2</sup> mod <i class="calibre12">N</i>. And <i class="calibre12">c</i><sub class="calibre15">2</sub> = <i class="calibre12">M’</i>
mod 2. The final ciphertext message is the triple:</p>

<p class="math">(<i class="calibre12">C, c</i><sub class="calibre15">1</sub>, <i class="calibre12">c</i><sub class="calibre15">2</sub>)
</p>

<p class="calibre9">To decrypt <i class="calibre12">C</i>, the receiver computes <i class="calibre12">M</i>" using</p>

<p class="math"><i class="calibre12">C<sup class="calibre19">k</sup></i> ≡ ±<i class="calibre12">M</i>" (mod <i class="calibre12">N</i>)
</p>

<p class="calibre9">The proper sign of <i class="calibre12">M</i>" is given by <i class="calibre12">c</i><sub class="calibre15">2</sub>. Finally,</p>

<p class="math"><i class="calibre12">M</i> = (<i class="calibre12">S</i><sup class="calibre19"><i class="calibre22">c</i><sub class="calibre16">1</sub></sup> * (-1)<sup class="calibre19"><i class="calibre22">c</i><sub class="calibre16">1</sub></sup> * <i class="calibre12">M</i>") mod <i class="calibre12">N</i>
</p>

<p class="calibre9">Williams refined this scheme further in [<a href="Applied%20Cryptography_split_036.html#r1603" class="calibre5 pcalibre">1603</a>,<a href="Applied%20Cryptography_split_036.html#r1604" class="calibre5 pcalibre">1604</a>,<a href="Applied%20Cryptography_split_036.html#r1605" class="calibre5 pcalibre">1605</a>]. Instead of
squaring the plaintext message, cube it. The large primes must be congruent to
1 mod 3; otherwise the public and private keys are the same. Even better, there
is only one unique decryption for each encryption.</p>

<p class="calibre9">Both Rabin and Williams have an advantage over RSA in that they are
provably as secure as factoring. However, they are completely insecure against
a chosen-ciphertext attack. If you are going to use these schemes in instances
where an attacker can mount this attack (for example, as a digital signature
algorithm where an attacker can choose messages to be signed), be sure to use
a one-way hash function before signing. Rabin suggested another way of
defeating this attack: Append a different random string to each message before
hashing and signing. Unfortunately, once you add a one-way hash function to
the system it is no longer provably as secure as factoring [<a href="Applied%20Cryptography_split_035.html#r628" class="calibre5 pcalibre">628</a>], although
adding hashing cannot weaken the system in any practical sense.</p>

<p class="calibre9">Other Rabin variants are [<a href="Applied%20Cryptography_split_036.html#r972" class="calibre5 pcalibre">972</a>,<a href="Applied%20Cryptography_split_036.html#r909" class="calibre5 pcalibre">909</a>,<a href="Applied%20Cryptography_split_035.html#r696" class="calibre5 pcalibre">696</a>,<a href="Applied%20Cryptography_split_035.html#r697" class="calibre5 pcalibre">697</a>,<a href="Applied%20Cryptography_split_036.html#r1439" class="calibre5 pcalibre">1439</a>,<a href="Applied%20Cryptography_split_036.html#r989" class="calibre5 pcalibre">989</a>]. A two-dimensional
variant is in [<a href="Applied%20Cryptography_split_036.html#r866" class="calibre5 pcalibre">866</a>,<a href="Applied%20Cryptography_split_036.html#r889" class="calibre5 pcalibre">889</a>].</p>

<h3 id="19.6" class="calibre7">19.6 ElGamal</h3>

<p class="calibre9">The ElGamal scheme [<a href="Applied%20Cryptography_split_035.html#r518" class="calibre5 pcalibre">518</a>,<a href="Applied%20Cryptography_split_035.html#r519" class="calibre5 pcalibre">519</a>] can be used for both digital signatures and
encryption; it gets its security from the difficulty of calculating discrete
logarithms in a finite field.</p>

<p class="calibre9">To generate a key pair, first choose a prime, <i class="calibre12">p</i>, and two random numbers, <i class="calibre12">g</i> and <i class="calibre12">x</i>, such that both <i class="calibre12">g</i> and <i class="calibre12">x</i> are less than <i class="calibre12">p</i>. Then calculate</p>

<p class="math"><i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">The public key is <i class="calibre12">y, g</i> and <i class="calibre12">p</i>. Both <i class="calibre12">g</i> and <i class="calibre12">p</i> can be shared among a group of users. The private key is <i class="calibre12">x</i>.</p>

<h4 class="calibre8">ElGamal Signatures</h4>

<p class="calibre9">To sign a message, <i class="calibre12">M</i>, first choose a random number, <i class="calibre12">k</i>, such that <i class="calibre12">k</i> is relatively prime to <i class="calibre12">p</i> - 1. Then compute</p>

<p class="math"><i class="calibre12">a</i> = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">and use the extended Euclidean algorithm to solve for <i class="calibre12">b</i> in the following
equation:</p>

<p class="math"><i class="calibre12">M</i> = (<i class="calibre12">xa</i> + <i class="calibre12">kb</i>) mod (<i class="calibre12">p</i> - 1)
</p>

<p class="calibre9">The signature is the pair: <i class="calibre12">a</i> and <i class="calibre12">b</i>. The random value, <i class="calibre12">k</i>, must be kept secret.</p>

<p class="calibre9">To verify a signature, confirm that</p>

<p class="math"><i class="calibre12">y<sup class="calibre19">a</sup>a<sup class="calibre19">b</sup></i> mod <i class="calibre12">p</i> = <i class="calibre12">g<sup class="calibre19">M</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">Each ElGamal signature or encryption requires a new value of <i class="calibre12">k</i>, and that value must be chosen randomly. If Eve ever recovers a <i class="calibre12">k</i> that Alice used, she can
recover Alice’s private key, <i class="calibre12">x</i>. If Eve ever gets two messages signed or
encrypted using the same <i class="calibre12">k</i>, even if she doesn’t know what it is, she can
recover <i class="calibre12">x</i>.</p>

<p class="calibre9">This is summarized in Table 19.5.</p>


<p id="table-19-5" class="calibre9"><b class="calibre10">Table 19.5 - ElGamal Signatures</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Public Key:</b></i></p>

<p class="math-left"><i class="calibre12">p </i> prime (can be shared among a group of users)
<i class="calibre12">g</i> &lt; <i class="calibre12">p</i> (can be shared among a group of users)
<i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Private Key:</b></i></p>

<p class="math-left"><i class="calibre12">x</i> &lt; <i class="calibre12">p</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Signing:</b></i></p>

<p class="math-left"><i class="calibre12">k </i> choose at random, relatively prime to <i class="calibre12">p</i> - 1
<i class="calibre12">a </i>(signature) = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
<i class="calibre12">b </i>(signature) such that <i class="calibre12">M</i> = (<i class="calibre12">xa</i> + <i class="calibre12">kb</i>) mod (<i class="calibre12">p</i> - 1)
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Verifying:</b></i></p>

<p class="math-left">Accept as valid if <i class="calibre12">y<sup class="calibre19">a</sup>a<sup class="calibre19">b</sup></i> mod <i class="calibre12">p</i> = <i class="calibre12">g<sup class="calibre19">M</sup></i> mod <i class="calibre12">p</i>
</p>

<hr class="calibre63"/>

<p class="calibre9">For example, choose <i class="calibre12">p</i> = 11 and <i class="calibre12">g</i> = 2. Choose private key <i class="calibre12">x</i> = 8. Calculate</p>

<p class="math"><i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i> = 2<sup class="calibre19">8</sup> mod 11 = 3
</p>

<p class="calibre9">The public key is <i class="calibre12">y</i> = 3, <i class="calibre12">g</i> = 2 and <i class="calibre12">p</i> = 11.</p>

<p class="calibre9">To authenticate <i class="calibre12">M</i> = 5, first choose a random number <i class="calibre12">k</i> = 9. Confirm that gcd(9, 10) = 1. Compute</p>

<p class="math"><i class="calibre12">a</i> = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i> = 2<sup class="calibre19">9</sup> mod 11 = 6
</p>

<p class="calibre9">and use the extended Euclidean algorithm to solve for <i class="calibre12">b:</i></p>

<p class="math-left"><i class="calibre12">M</i> = (<i class="calibre12">ax</i> + <i class="calibre12">kb</i>) mod (<i class="calibre12">p</i> - 1)
5 = (8 * 6 + 9 * b) mod 10
</p>

<p class="calibre9">The solution is <i class="calibre12">b</i> = 3, and the signature is the pair: <i class="calibre12">a</i> = 6 and <i class="calibre12">b</i> = 3.</p>

<p class="calibre9">To verify a signature, confirm that</p>

<p class="math-left"><i class="calibre12">y<sup class="calibre19">a</sup>a<sup class="calibre19">b</sup></i> mod <i class="calibre12">p</i> = <i class="calibre12">g<sup class="calibre19">M</sup></i> mod <i class="calibre12">p</i>
3<sup class="calibre19">6</sup> 6<sup class="calibre19">3</sup> mod 11 = 2<sup class="calibre19">5</sup> mod 11
</p>

<p class="calibre9">A variant of ElGamal for signatures is in [<a href="Applied%20Cryptography_split_036.html#r1377" class="calibre5 pcalibre">1377</a>]. Thomas Beth invented a
variant of the ElGamal scheme suitable for proofs of identity [<a href="Applied%20Cryptography_split_035.html#r146" class="calibre5 pcalibre">146</a>]. There are
variants for password authentication [<a href="Applied%20Cryptography_split_035.html#r312" class="calibre5 pcalibre">312</a>], and for key exchange [<a href="Applied%20Cryptography_split_035.html#r773" class="calibre5 pcalibre">773</a>]. And
there are thousands more (see <a href="Applied%20Cryptography_split_023.html#20.4" class="calibre5 pcalibre">Section 20.4</a>).</p>

<h4 class="calibre8">ElGamal Encryption</h4>

<p class="calibre9">A modification of ElGamal can encrypt messages. To encrypt message <i class="calibre12">M</i>, first
choose a random <i class="calibre12">k</i>, such that <i class="calibre12">k</i> is relatively prime to <i class="calibre12">p</i> - 1. Then compute</p>

<p class="math-left"><i class="calibre12">a</i> = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
<i class="calibre12">b</i> = <i class="calibre12">y<sup class="calibre19">k</sup>M</i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">The pair, <i class="calibre12">a</i> and <i class="calibre12">b</i>, is the ciphertext. Note that the ciphertext is twice the size of the plaintext.</p>

<p class="calibre9">To decrypt <i class="calibre12">a</i> and <i class="calibre12">b</i>, compute</p>

<p class="math"><i class="calibre12">M</i> = <i class="calibre12">b</i>/<i class="calibre12">a<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">Since <i class="calibre12">a<sup class="calibre19">x</sup></i> ≡ <i class="calibre12">g<sup class="calibre19">kx</sup></i> (mod <i class="calibre12">p</i>), and <i class="calibre12">b</i>/<i class="calibre12">a<sup class="calibre19">x</sup></i> ≡ <i class="calibre12">y<sup class="calibre19">k</sup>M</i>/<i class="calibre12">a<sup class="calibre19">x</sup></i> ≡ <i class="calibre12">g<sup class="calibre19">xk</sup>M/g<sup class="calibre19">xk</sup></i> ≡ <i class="calibre12">M</i> (mod <i class="calibre12">p</i>), this all works (see Table 19.6). This is really the same as Diffie-Hellman key
exchange (see <a href="Applied%20Cryptography_split_025.html#22.1" class="calibre5 pcalibre">Section 22.1</a>), except that <i class="calibre12">y</i> is part of the key, and the encryption is multiplied by <i class="calibre12">y<sup class="calibre19">k</sup></i>.</p>

<p id="table-19-6" class="calibre9"><b class="calibre10">Table 19.6 - ElGamal Encryption</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Public Key:</b></i></p>

<p class="math-left"><i class="calibre12">p </i> prime (can be shared among a group of users)
<i class="calibre12">g</i> &lt; <i class="calibre12">p</i> (can be shared among a group of users)
<i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Private Key:</b></i></p>

<p class="math-left"><i class="calibre12">x</i> &lt; <i class="calibre12">p</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Encrypting:</b></i></p>

<p class="math-left"><i class="calibre12">k</i> choose at random, relatively prime to <i class="calibre12">p</i> - 1.
<i class="calibre12">a</i> (ciphertext) = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
<i class="calibre12">b</i> (ciphertext) = <i class="calibre12">y<sup class="calibre19">k</sup>M</i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Decrypting:</b></i></p>

<p class="math-left"><i class="calibre12">M</i> (plaintext) = <i class="calibre12">b</i>/<i class="calibre12">a<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>
</p>

<hr class="calibre63"/>

<h4 class="calibre8">Speed</h4>

<p class="calibre9">Table 19.7 gives sample software speeds of ElGamal [<a href="Applied%20Cryptography_split_036.html#r918" class="calibre5 pcalibre">918</a>].</p>

<table class="data-table1" id="table-19-7">
<caption class="calibre67">Table 19.7 - ElGamal Speeds for Different Modulus Lengths with a 160-bit Exponent (on a SPARC II)</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">
</th><th class="calibre26">512 bits</th>
<th class="calibre26">768 bits</th>
<th class="calibre26">1024 bits</th>
</tr>
<tr class="calibre25"><td class="calibre70">Encrypt</td><td class="calibre70">0.33 sec</td><td class="calibre70">0.80 sec</td><td class="calibre70">1.09 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Decrypt</td><td class="calibre70">0.24 sec</td><td class="calibre70">0.58 sec</td><td class="calibre70">0.77 sec</td></tr>
<tr class="calibre71"><td class="calibre72">Sign</td><td class="calibre72">0.25 sec</td><td class="calibre72">0.47 sec</td><td class="calibre72">0.63 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Verify</td><td class="calibre70">1.37 sec</td><td class="calibre70">5.12 sec</td><td class="calibre70">9.30 sec</td></tr>
</tbody></table>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">ElGamal is unpatented. But, before you go ahead and implement the
algorithm, realize that PKP feels that this algorithm is covered under the
Diffie-Hellman patent [<a href="Applied%20Cryptography_split_035.html#r718" class="calibre5 pcalibre">718</a>]. However, the Diffie-Hellman patent will expire
on April 29, 1997, making ElGamal the first public-key cryptography
algorithm suitable for encryption and digital signatures unencumbered by
patents in the United States. I can hardly wait.</p>

<h3 id="19.7" class="calibre7">19.7 McEliece</h3>

<p class="calibre9">In 1978 Robert McEliece developed a public-key cryptosystem based on
algebraic coding theory [<a href="Applied%20Cryptography_split_036.html#r1041" class="calibre5 pcalibre">1041</a>]. The algorithm makes use of the existence of a
class of error-correcting codes, known as <b class="calibre10">Goppa codes</b>. His idea was to
construct a Goppa code and disguise it as a general linear code. There is a fast
algorithm for decoding Goppa codes, but the general problem of finding a
code word of a given weight in a linear binary code is <b class="calibre10">NP-complete</b>. A good
description of this algorithm can be found in [<a href="Applied%20Cryptography_split_036.html#r1233" class="calibre5 pcalibre">1233</a>]; see also [<a href="Applied%20Cryptography_split_036.html#r1562" class="calibre5 pcalibre">1562</a>].
Following is just a quick summary.</p>

<p class="calibre9">Let <i class="calibre12">d</i><sub class="calibre15">H</sub>(<i class="calibre12">x,y</i>) denote the Hamming distance between <i class="calibre12">x</i> and <i class="calibre12">y</i>. The numbers <i class="calibre12">n, k</i> and <i class="calibre12">t</i> are system parameters.</p>

<p class="calibre9">The private key has three parts: <i class="calibre12">G’</i> is a <i class="calibre12">k</i> * <i class="calibre12">n</i> generator matrix for a Goppa code that can correct <i class="calibre12">t</i> errors. <i class="calibre12">P</i> is an <i class="calibre12">n</i> * <i class="calibre12">n</i> permutation matrix. <i class="calibre12">S</i> is a <i class="calibre12">k</i> * <i class="calibre12">k</i> nonsingular matrix.</p>

<p class="calibre9">The public key is a <i class="calibre12">k</i> * <i class="calibre12">n</i> matrix <i class="calibre12">G: G</i> = <i class="calibre12">SG’P</i>.</p>

<p class="calibre9">Plaintext messages are strings of <i class="calibre12">k</i> bits, in the form of <i class="calibre12">k</i>-element vectors over GF(2).</p>

<p class="calibre9">To encrypt a message, choose a random <i class="calibre12">n</i>-element vector over GF(2), <i class="calibre12">z</i>, with Hamming distance less than or equal to <i class="calibre12">t</i>.</p>

<p class="math"><i class="calibre12">c</i> = <i class="calibre12">mG</i> + <i class="calibre12">z</i>
</p>

<p class="calibre9">To decrypt the ciphertext, first compute <i class="calibre12">c’</i> = <i class="calibre12">cP</i><sup class="calibre19">-1</sup>. Then, using the decoding algorithm for the Goppa code, find <i class="calibre12">m’</i> such that <i class="calibre12">d</i><sub class="calibre15">H</sub>(<i class="calibre12">m’ G, c’</i>) is less than or equal to <i class="calibre12">t</i>. Finally, compute <i class="calibre12">m</i> = <i class="calibre12">m’S</i><sup class="calibre19">-1</sup>.</p>

<p class="calibre9">In his original paper, McEliece suggested that <i class="calibre12">n</i> = 1024, <i class="calibre12">t</i> = 50, and <i class="calibre12">k</i> = 524.
These are the minimum values required for security.</p>

<p class="calibre9">Although the algorithm was one of the first public-key algorithms, and there
were no successful cryptanalytic results against the algorithm, it has never
gained wide acceptance in the cryptographic community. The scheme is two to
three orders of magnitude faster than RSA, but has some problems. The public
key is enormous: 2<sup class="calibre19">19</sup> bits long. The data expansion is large: The ciphertext is
twice as long as the plaintext.</p>

<p class="calibre9">Some attempts at cryptanalysis of this system can be found in [<a href="Applied%20Cryptography_split_035.html#r8" class="calibre5 pcalibre">8</a>,<a href="Applied%20Cryptography_split_036.html#r943" class="calibre5 pcalibre">943</a>,<a href="Applied%20Cryptography_split_036.html#r1559" class="calibre5 pcalibre">1559</a>,<a href="Applied%20Cryptography_split_035.html#r306" class="calibre5 pcalibre">306</a>]. 
None of these were successful in the general case, although the similarity
between the McEliece algorithm and knapsacks worried some.</p>

<p class="calibre9">In 1991, two Russian cryptographers claimed to have broken the McEliece
system with some parameters [<a href="Applied%20Cryptography_split_036.html#r882" class="calibre5 pcalibre">882</a>]. Their paper contained no evidence to
substantiate their claim, and most cryptographers discount the result. Another
Russian attack, one that cannot be used directly against the McEliece system,
is in [<a href="Applied%20Cryptography_split_036.html#r1447" class="calibre5 pcalibre">1447</a>,<a href="Applied%20Cryptography_split_036.html#r1448" class="calibre5 pcalibre">1448</a>]. Extensions to McEliece can be found in [<a href="Applied%20Cryptography_split_035.html#r424" class="calibre5 pcalibre">424</a>,<a href="Applied%20Cryptography_split_036.html#r1227" class="calibre5 pcalibre">1227</a>,<a href="Applied%20Cryptography_split_036.html#r976" class="calibre5 pcalibre">976</a>].</p>

<h4 class="calibre8">Other Algorithms Based on Linear Error-Correcting Codes</h4>

<p class="calibre9">The Niederreiter algorithm [<a href="Applied%20Cryptography_split_036.html#r1167" class="calibre5 pcalibre">1167</a>] is closely related to the McEliece algorithm,
and assumes that the public key is a random parity-check matrix of an
error-correcting code. The private key is an efficient decoding algorithm for
this matrix.</p>

<p class="calibre9">Another algorithm, used for identification and digital signatures, is based on
syndrome decoding [<a href="Applied%20Cryptography_split_036.html#r1501" class="calibre5 pcalibre">1501</a>]; see [<a href="Applied%20Cryptography_split_035.html#r306" class="calibre5 pcalibre">306</a>] for comments. An algorithm based on
error-correcting codes [<a href="Applied%20Cryptography_split_036.html#r1621" class="calibre5 pcalibre">1621</a>] is insecure [<a href="Applied%20Cryptography_split_035.html#r698" class="calibre5 pcalibre">698</a>,<a href="Applied%20Cryptography_split_035.html#r33" class="calibre5 pcalibre">33</a>,<a href="Applied%20Cryptography_split_035.html#r31" class="calibre5 pcalibre">31</a>,<a href="Applied%20Cryptography_split_036.html#r1560" class="calibre5 pcalibre">1560</a>,<a href="Applied%20Cryptography_split_035.html#r32" class="calibre5 pcalibre">32</a>].</p>

<h3 id="19.8" class="calibre7">19.8 Elliptic Curve Cryptosystems</h3>

<p class="calibre9">Elliptic curves have been studied for many years and there is an enormous
amount of literature on the subject. In 1985, Neal Koblitz and V. S. Miller
independently proposed using them for public-key cryptosystems [<a href="Applied%20Cryptography_split_036.html#r867" class="calibre5 pcalibre">867</a>,<a href="Applied%20Cryptography_split_036.html#r1095" class="calibre5 pcalibre">1095</a>].
They did not invent a new cryptographic algorithm with elliptic curves over
finite fields, but they implemented existing public-key algorithms, like
Diffie-Hellman, using elliptic curves.</p>

<p class="calibre9">Elliptic curves are interesting because they provide a way of constructing
“elements” and “rules of combining” that produce groups. These groups have
enough familiar properties to build cryptographic algorithms, but they don’t
have certain properties that may facilitate cryptanalysis. For example, there is
no good notion of “smooth” with elliptic curves. That is, there is no set of
small elements in terms of which a random element has a good chance of
being expressed by a simple algorithm. Hence, index calculus discrete
logarithm algorithms do not work. See [<a href="Applied%20Cryptography_split_036.html#r1095" class="calibre5 pcalibre">1095</a>] for more details.</p>

<p class="calibre9">Elliptic curves over the finite field GF(2<sup class="calibre19"><i class="calibre22">n</i></sup>) are particularly interesting. The arithmetic processors for the underlying field are easy to construct and are
relatively simple to implement for <i class="calibre12">n</i> in the range of 130 to 200. They have the potential to provide faster public-key cryptosystems with smaller key sizes.
Many public-key algorithms, like Diffie-Hellman, ElGamal, and Schnorr, can
be implemented in elliptic curves over finite fields.</p>

<p class="calibre9">The mathematics here are complex and beyond the scope of this book. Those
interested in this topic are invited to read the two references previously
mentioned, and the excellent book by Alfred Menezes [<a href="Applied%20Cryptography_split_036.html#r1059" class="calibre5 pcalibre">1059</a>]. Two analogues
of RSA work in elliptic curves [<a href="Applied%20Cryptography_split_036.html#r890" class="calibre5 pcalibre">890</a>,<a href="Applied%20Cryptography_split_035.html#r454" class="calibre5 pcalibre">454</a>]. Other papers are 
[<a href="Applied%20Cryptography_split_035.html#r23" class="calibre5 pcalibre">23</a>, <a href="Applied%20Cryptography_split_035.html#r119" class="calibre5 pcalibre">119</a>, <a href="Applied%20Cryptography_split_036.html#r1062" class="calibre5 pcalibre">1062</a>, <a href="Applied%20Cryptography_split_036.html#r869" class="calibre5 pcalibre">869</a>, <a href="Applied%20Cryptography_split_035.html#r152" class="calibre5 pcalibre">152</a>, <a href="Applied%20Cryptography_split_036.html#r871" class="calibre5 pcalibre">871</a>, <a href="Applied%20Cryptography_split_036.html#r892" class="calibre5 pcalibre">892</a>, <a href="Applied%20Cryptography_split_035.html#r25" class="calibre5 pcalibre">25</a>, <a href="Applied%20Cryptography_split_036.html#r895" class="calibre5 pcalibre">895</a>, <a href="Applied%20Cryptography_split_035.html#r353" class="calibre5 pcalibre">353</a>, <a href="Applied%20Cryptography_split_036.html#r1061" class="calibre5 pcalibre">1061</a>, <a href="Applied%20Cryptography_split_035.html#r26" class="calibre5 pcalibre">26</a>, <a href="Applied%20Cryptography_split_036.html#r913" class="calibre5 pcalibre">913</a>, <a href="Applied%20Cryptography_split_036.html#r914" class="calibre5 pcalibre">914</a>, <a href="Applied%20Cryptography_split_036.html#r915" class="calibre5 pcalibre">915</a>]. Elliptic curve
cryptosystems with small key lengths are discussed in [<a href="Applied%20Cryptography_split_035.html#r701" class="calibre5 pcalibre">701</a>]. Next Computer
Inc.’s Fast Elliptic Encryption (FEE) algorithm also uses elliptic curves [<a href="Applied%20Cryptography_split_035.html#r388" class="calibre5 pcalibre">388</a>].
FEE has the nice feature that the private key can be any easy-to-remember
string. There are proposed public-key cryptosystems using hyperelliptic curves
[<a href="Applied%20Cryptography_split_036.html#r868" class="calibre5 pcalibre">868</a>,<a href="Applied%20Cryptography_split_036.html#r870" class="calibre5 pcalibre">870</a>,<a href="Applied%20Cryptography_split_036.html#r1441" class="calibre5 pcalibre">1441</a>,<a href="Applied%20Cryptography_split_036.html#r1214" class="calibre5 pcalibre">1214</a>].</p>

<h3 id="19.9" class="calibre7">19.9 LUC</h3>

<p class="calibre9">Some cryptographers have developed generalizations of RSA that use various
permutation polynomials instead of exponentiation. A variation called
Kravitz-Reed, using irreducible binary polynomials [<a href="Applied%20Cryptography_split_036.html#r898" class="calibre5 pcalibre">898</a>], is insecure [<a href="Applied%20Cryptography_split_035.html#r451" class="calibre5 pcalibre">451</a>,<a href="Applied%20Cryptography_split_035.html#r589" class="calibre5 pcalibre">589</a>]. 
Winfried Müller and Wilfried Nöbauer use Dickson polynomials [<a href="Applied%20Cryptography_split_036.html#r1127" class="calibre5 pcalibre">1127</a>,<a href="Applied%20Cryptography_split_036.html#r1128" class="calibre5 pcalibre">1128</a>,<a href="Applied%20Cryptography_split_036.html#r965" class="calibre5 pcalibre">965</a>]. 
Rudolph Lidl and Müller generalized this approach in [<a href="Applied%20Cryptography_split_036.html#r966" class="calibre5 pcalibre">966</a>,<a href="Applied%20Cryptography_split_036.html#r1126" class="calibre5 pcalibre">1126</a>]
(a variant is called the Réidi scheme), and Nöbauer looked at its security in
[<a href="Applied%20Cryptography_split_036.html#r1172" class="calibre5 pcalibre">1172</a>,<a href="Applied%20Cryptography_split_036.html#r1173" class="calibre5 pcalibre">1173</a>]. (Comments on prime generation with Lucas functions are in
[<a href="Applied%20Cryptography_split_036.html#r969" class="calibre5 pcalibre">969</a>,<a href="Applied%20Cryptography_split_036.html#r967" class="calibre5 pcalibre">967</a>,<a href="Applied%20Cryptography_split_036.html#r968" class="calibre5 pcalibre">968</a>,<a href="Applied%20Cryptography_split_035.html#r598" class="calibre5 pcalibre">598</a>].) Despite all of this prior art, a group of researchers from
New Zealand managed to patent this scheme in 1993, calling it LUC [<a href="Applied%20Cryptography_split_036.html#r1486" class="calibre5 pcalibre">1486</a>,<a href="Applied%20Cryptography_split_035.html#r521" class="calibre5 pcalibre">521</a>,<a href="Applied%20Cryptography_split_036.html#r1487" class="calibre5 pcalibre">1487</a>].</p>

<p class="calibre9">The <i class="calibre12">n</i>th Lucas number, <i class="calibre12">V</i><sub class="calibre15">n</sub>(<i class="calibre12">P</i>,1), is defined as</p>

<p class="math"><i class="calibre12">V</i><sub class="calibre15">n</sub>(<i class="calibre12">P</i>, 1) = <i class="calibre12">PV</i><sub class="calibre15">n-1</sub> (<i class="calibre12">P</i>, 1) - <i class="calibre12">V</i><sub class="calibre15">n - 2</sub> (<i class="calibre12">P</i>,1)
</p>

<p class="calibre9">There’s a lot more theory to Lucas numbers; I’m ignoring all of it. A good
theoretical treatment of Lucas sequences is in [<a href="Applied%20Cryptography_split_036.html#r1307" class="calibre5 pcalibre">1307</a>,<a href="Applied%20Cryptography_split_036.html#r1308" class="calibre5 pcalibre">1308</a>]. A particularly nice
description of the mathematics of LUC is in [<a href="Applied%20Cryptography_split_036.html#r1494" class="calibre5 pcalibre">1494</a>,<a href="Applied%20Cryptography_split_035.html#r708" class="calibre5 pcalibre">708</a>].</p>
	
<p class="calibre9">In any case, to generate a public-key/private-key key pair, first choose two
large primes, <i class="calibre12">p</i> and <i class="calibre12">q</i>. Calculate <i class="calibre12">n</i>, the product of <i class="calibre12">p</i> and <i class="calibre12">q</i>. The encryption key, <i class="calibre12">e</i>, is a random number that is relatively prime to <i class="calibre12">p</i> - 1, <i class="calibre12">q</i> - 1, <i class="calibre12">p</i> + 1, and <i class="calibre12">q</i> + 1.</p>

<p class="calibre9">There are four possible decryption keys,</p>

<p class="math-left"><i class="calibre12">d</i> = <i class="calibre12">e</i><sup class="calibre19">-1</sup> mod (lcm((<i class="calibre12">p</i> + 1), (<i class="calibre12">q</i> + 1)))
<i class="calibre12">d</i> = <i class="calibre12">e</i><sup class="calibre19">-1</sup> mod (lcm((<i class="calibre12">p</i> + 1), (<i class="calibre12">q</i> - 1)))
<i class="calibre12">d</i> = <i class="calibre12">e</i><sup class="calibre19">-1</sup> mod (lcm((<i class="calibre12">p</i> - 1), (<i class="calibre12">q</i> + 1)))
<i class="calibre12">d</i> = <i class="calibre12">e</i><sup class="calibre19">-1</sup> mod (lcm((<i class="calibre12">p</i> - 1), (<i class="calibre12">q</i> - 1)))
</p>

<p class="calibre9">where lcm is the least common multiple.</p>

<p class="calibre9">The public key is <i class="calibre12">d</i> and <i class="calibre12">n; </i> the private key is <i class="calibre12">e</i> and <i class="calibre12">n</i>. Discard <i class="calibre12">p</i> and <i class="calibre12">q</i>.</p>

<p class="calibre9">To encrypt a message, <i class="calibre12">P</i> (<i class="calibre12">P</i> must be less than <i class="calibre12">n</i>), calculate</p>

<p class="math"><i class="calibre12">C</i> = <i class="calibre12">V</i><sub class="calibre15">e</sub>(<i class="calibre12">P</i>, 1) (mod <i class="calibre12">n</i>)
</p>

<p class="calibre9">And to decrypt:</p>

<p class="math"><i class="calibre12">P</i> = <i class="calibre12">V</i><sub class="calibre15">d</sub>(<i class="calibre12">P</i>, 1) (mod <i class="calibre12">n</i>), with the proper <i class="calibre12">d</i>
</p>

<p class="calibre9">At best, LUC is no more secure than RSA. And recent, still-unpublished
results show how to break LUC in at least some implementations. I just don’t
trust it.</p>

<h3 id="19.10" class="calibre7">19.10 Finite Automaton Public-Key Cryptosystems</h3>

<p class="calibre9">Chinese cryptographer Tao Renji has developed a public-key algorithm based
on finite automata [<a href="Applied%20Cryptography_split_036.html#r1301" class="calibre5 pcalibre">1301</a>,<a href="Applied%20Cryptography_split_036.html#r1302" class="calibre5 pcalibre">1302</a>,<a href="Applied%20Cryptography_split_036.html#r1303" class="calibre5 pcalibre">1303</a>,<a href="Applied%20Cryptography_split_036.html#r1300" class="calibre5 pcalibre">1300</a>,<a href="Applied%20Cryptography_split_036.html#r1304" class="calibre5 pcalibre">1304</a>,<a href="Applied%20Cryptography_split_035.html#r666" class="calibre5 pcalibre">666</a>]. Just as it is hard to
factor the product of two large primes, it is also hard to factor the composition
of two finite automata. This is especially so if one or both of them is nonlinear.</p>

<p class="calibre9">Much of this research took place in China in the 1980s and was published in
Chinese. Renji is starting to write in English. His main result was that certain
nonlinear automata (the quasilinear automata) possess weak inverses if, and
only if, they have a certain echelon matrix structure. This property disappears
if they are composed with another automaton (even a linear one). In the
public-key algorithm, the secret key is an invertible quasilinear automaton and
a linear automaton, and the corresponding public key can be derived by
multiplying them out term by term. Data is encrypted by passing it through the
public automaton, and decrypted by passing it through the inverses of its
components (in some cases provided they have been set to a suitable initial
state). This scheme works for both encryption and digital signatures.</p>

<p class="calibre9">The performance of such systems can be summed up by saying that like
McEliece’s system, they run much faster than RSA, but require longer keys.
The keylength thought to give similar security to 512-bit RSA is 2792 bits, and
to 1024-bit RSA is 4152 bits. For the former case, the system encrypts data at
20, 869 bytes/sec and decrypts data at 17, 117 bytes/sec, running on a 33 Mhz
80486.</p>

<p class="calibre9">Renji has published three algorithms. The first is FAPKC0. This is a weak
system which uses linear components, and is primarily illustrative. Two
serious systems, FAPKC1 and FAPKC2, use one linear and one nonlinear
component each. The latter is more complex, and was developed in order to
support identity-based operation.</p>

<p class="calibre9">As for their strength, quite a lot of work has been done on them in China
(where there are now over 30 institutes publishing cryptography and security
papers). One can see from the considerable Chinese language literature that the
problem has been studied.</p>

<p class="calibre9">One possible attraction of FAPKC1 and FAPKC2 is that they are not
encumbered by any U.S. patents. Thus, once the Diffie-Hellman patent expires
in 1997, they will unquestionably be in the public domain.</p>

<div class="calibre6" id="calibre_pb_44"></div>
</div>






</body></html>
