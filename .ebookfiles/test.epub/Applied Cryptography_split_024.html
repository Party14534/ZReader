<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="21">Chapter 21 <br class="calibre3"/>
Identification Schemes</h1>

<h3 id="21.1" class="calibre7">21.1 Feige-Fiat-Shamir</h3>

<p class="calibre9">Amos Fiat’s and Adi Shamir’s authentication and digital signature scheme is
discussed in [<a href="Applied%20Cryptography_split_035.html#r566" class="calibre5 pcalibre">566</a>,<a href="Applied%20Cryptography_split_035.html#r567" class="calibre5 pcalibre">567</a>]. Uriel Feige, Fiat, and Shamir modified the algorithm to
a zero-knowledge proof of identity [<a href="Applied%20Cryptography_split_035.html#r544" class="calibre5 pcalibre">544</a>,<a href="Applied%20Cryptography_split_035.html#r545" class="calibre5 pcalibre">545</a>]. This is the best-known
zero-knowledge proof of identity.</p>

<p class="calibre9">On July 9, 1986 the three authors submitted a U.S. patent application [<a href="Applied%20Cryptography_split_036.html#r1427" class="calibre5 pcalibre">1427</a>].
Because of its potential military applications, the application was reviewed by
the military. Occasionally the Patent Office responds not with a patent, but
with something called a secrecy order. On January 6, 1987, three days before
the end of their six-month period, the Patent Office imposed that order at the
request of the Army. They stated that “...the disclosure or publication of the
subject matter...would be detrimental to the national security....” The authors
were ordered to notify all Americans to whom the research had been disclosed
that unauthorized disclosure could lead to two years’ imprisonment, a $10,000
fine, or both. Furthermore, the authors had to inform the Commissioner of
Patents and Trademarks of all foreign citizens to whom the information had
been disclosed.</p>

<p class="calibre9">This was ludicrous. All through the second half of 1986, the authors had
presented the work at conferences throughout Israel, Europe, and the United
States. The authors weren’t even American citizens, and all the work had been
done at the Weizmann Institute in Israel.</p>

<p class="calibre9">Word spread through the academic community and the press. Within two days
the secrecy order was rescinded; Shamir and others believe that the NSA
pulled strings to rescind the order, although they officially had no comment.
Further details of this bizarre story are in [<a href="Applied%20Cryptography_split_036.html#r936" class="calibre5 pcalibre">936</a>].</p>

<h4 class="calibre8">Simplified Feige-Fiat-Shamir Identification Scheme</h4>

<p class="calibre9">Before issuing any private keys, the arbitrator chooses a random modulus, <i class="calibre12">n</i>,
which is the product of two large primes. In real life, <i class="calibre12">n</i> should be at least 512
bits long and probably closer to 1024 bits. This <i class="calibre12">n</i> can be shared among a group of provers. (Choosing a Blum integer makes computation easier, but it is not
required for security.)</p>

<p class="calibre9">To generate Peggy’s public and private keys, a trusted arbitrator chooses a
number, <i class="calibre12">v, </i> where <i class="calibre12">v</i> is a quadratic residue mod <i class="calibre12">n. </i> In other words, choose <i class="calibre12">v</i> such that <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ <i class="calibre12">v</i> (mod <i class="calibre12">n</i>) has a solution and <i class="calibre12">v</i><sup class="calibre19">-1</sup> mod <i class="calibre12">n</i> exists. This <i class="calibre12">v</i> is Peggy’s public key. Then calculate the smallest <i class="calibre12">s</i> for which <i class="calibre12">s</i> ≡ sqrt (<i class="calibre12">v</i><sup class="calibre19">-1</sup>) (mod <i class="calibre12">n</i>). This is Peggy’s private key.</p>

<p class="calibre9">The identification protocol can now proceed.</p>

<ol class="calibre17">

<li class="calibre14">Peggy picks a random <i class="calibre12">r, </i> where <i class="calibre12">r</i> is less then <i class="calibre12">n. </i> She then computes <i class="calibre12">x</i>
= <i class="calibre12">r</i><sup class="calibre19">2</sup> mod <i class="calibre12">n, </i> and sends <i class="calibre12">x</i> to Victor.
</li>
<li class="calibre14">Victor sends Peggy a random bit, <i class="calibre12">b. </i>
</li>
<li class="calibre14">If <i class="calibre12">b</i> = 0, then Peggy sends Victor <i class="calibre12">r. </i> If <i class="calibre12">b</i> = 1, then Peggy sends Victor <i class="calibre12">y</i> = <i class="calibre12">r</i> * <i class="calibre12">s</i> mod <i class="calibre12">n. </i>
</li>
<li class="calibre14">If <i class="calibre12">b</i> = 0, Victor verifies that <i class="calibre12">x</i> = <i class="calibre12">r</i><sup class="calibre19">2</sup> mod <i class="calibre12">n, </i> proving that Peggy knows sqrt (<i class="calibre12">x</i>). If <i class="calibre12">b</i> = 1, Victor verifies that <i class="calibre12">x</i> = <i class="calibre12">y</i><sup class="calibre19">2</sup> * <i class="calibre12">v</i> mod <i class="calibre12">n, </i> proving that Peggy knows sqrt (<i class="calibre12">v</i><sup class="calibre19">-1</sup>).
</li>

</ol>

<p class="calibre9">This is a single round — called an <b class="calibre10">accreditation</b> — of the protocol. Peggy and
Victor repeat this protocol <i class="calibre12">t</i> times, until Victor is convinced that Peggy knows <i class="calibre12">s. </i> It’s a cut-and-choose protocol. If Peggy doesn’t know <i class="calibre12">s, </i> she can pick <i class="calibre12">r</i> such that she can fool Victor if he sends her a 0, or she can pick <i class="calibre12">r</i> such that she can fool Victor if he sends her a 1. She can’t do both. The odds of her fooling
Victor once are 50 percent. The odds of her fooling him <i class="calibre12">t</i> times are 1 in 2<sup class="calibre19">t</sup>.</p>

<p class="calibre9">Another way for Victor to attack the protocol would be trying to impersonate
Peggy. He could initiate the protocol with another verifier, Valerie. In step (1),
instead of choosing a random <i class="calibre12">r, </i> he would just reuse an old <i class="calibre12">r</i> that he saw Peggy use. However, the odds of Valerie choosing the same value for <i class="calibre12">b</i> in step (2)
that Victor did in the protocol with Peggy are 1 in 2. So, the odds of his
fooling Valerie are 50 percent. The odds of his fooling her <i class="calibre12">t</i> times are 1 in 2<sup class="calibre19">t</sup>.</p>

<p class="calibre9">For this to work, Peggy must not reuse an <i class="calibre12">r, </i> ever. If she did, and Victor sent Peggy the other random bit in step (2), then he would have both of Peggy’s
responses. Then, from even one of these, he can calculate <i class="calibre12">s</i> and it’s all over for Peggy.</p>

<h4 class="calibre8">Feige-Fiat-Shamir Identification Scheme</h4>

<p class="calibre9">In their papers [<a href="Applied%20Cryptography_split_035.html#r544" class="calibre5 pcalibre">544</a>,<a href="Applied%20Cryptography_split_035.html#r545" class="calibre5 pcalibre">545</a>], Feige, Fiat and Shamir show how parallel
construction can increase the number of accreditations per round and reduce
Peggy and Victor’s interactions.</p>

<p class="calibre9">First generate <i class="calibre12">n</i> as in the previous example, the product of two large primes.
To generate Peggy’s public and private keys, first choose <i class="calibre12">k</i> different numbers: 
<i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>,..., <i class="calibre12">v</i><sub class="calibre15">k</sub>, where each <i class="calibre12">v</i><sub class="calibre15">i</sub> 
is a quadratic residue mod <i class="calibre12">n. </i> In other words, choose <i class="calibre12">v</i><sub class="calibre15">i</sub> such that 
<i class="calibre12">x</i><sup class="calibre19">2</sup> = <i class="calibre12">v</i><sub class="calibre15">i</sub> mod <i class="calibre12">n</i> has a solution and 
<i class="calibre12">v</i><sub class="calibre15">i</sub><sup class="calibre19">-1</sup> mod <i class="calibre12">n</i> exists. This string, <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub>, 
is the public key. Then calculate the smallest <i class="calibre12">s</i><sub class="calibre15">i</sub> such that <i class="calibre12">s</i><sub class="calibre15">i</sub> = sqrt (<i class="calibre12">v</i><sub class="calibre15">i</sub><sup class="calibre19">-1</sup>) mod <i class="calibre12">n. </i> 
This string, <i class="calibre12">s</i><sub class="calibre15">1</sub>, <i class="calibre12">s</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">s</i><sub class="calibre15">k</sub>, is the private key.</p>

<p class="calibre9">And the protocol is:</p>

<ol class="calibre17">

<li class="calibre14">Peggy picks a random <i class="calibre12">r, </i> when <i class="calibre12">r</i> is less than <i class="calibre12">n. </i> She then computes <i class="calibre12">x</i>
= <i class="calibre12">r</i><sup class="calibre19">2</sup> mod <i class="calibre12">n, </i> and sends <i class="calibre12">x</i> to Victor.
</li>
<li class="calibre14">Victor sends Peggy a random binary string <i class="calibre12">k-</i>bits long: <i class="calibre12">b</i><sub class="calibre15">1</sub>, <i class="calibre12">b</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">b</i><sub class="calibre15">k</sub>.
</li>
<li class="calibre14">Peggy computes <i class="calibre12">y</i> = <i class="calibre12">r</i> * (<i class="calibre12">s</i><sub class="calibre15">1</sub><sup class="calibre19"><i class="calibre22">b</i><sub class="calibre16">1</sub></sup> * <i class="calibre12">s</i><sub class="calibre15">2</sub><sup class="calibre19">b<sub class="calibre16">2</sub></sup> * ... * <i class="calibre12">s</i><sub class="calibre15">k</sub><sup class="calibre19">b<sub class="calibre16">k</sub></sup>) mod <i class="calibre12">n. </i> (She
multiplies together whichever values of <i class="calibre12">s</i><sub class="calibre15">i</sub> that correspond to <i class="calibre12">b</i><sub class="calibre15">i</sub> = 1. If Victor’s first bit is a 1, then <i class="calibre12">s</i><sub class="calibre15">1</sub> is part of the product; if Victor’s first bit is a 0, then <i class="calibre12">s</i><sub class="calibre15">1</sub> is not part of the product, and so on.) She sends <i class="calibre12">y</i> to Victor.
</li>
<li class="calibre14">Victor verifies that <i class="calibre12">x</i> = <i class="calibre12">y</i><sup class="calibre19">2</sup> * (<i class="calibre12">v</i><sub class="calibre15">1</sub><sup class="calibre19"><i class="calibre22">b</i><sub class="calibre16">1</sub></sup> * <i class="calibre12">v</i><sub class="calibre15">2</sub><sup class="calibre19">b<sub class="calibre16">2</sub></sup> * ... * <i class="calibre12">v</i><sub class="calibre15">k</sub><sup class="calibre19">b<sub class="calibre16">k</sub></sup>) mod <i class="calibre12">n. </i> (He
multiplies together the values of <i class="calibre12">v</i><sub class="calibre15">i</sub> based on the random binary string. If
his first bit is a 1, then <i class="calibre12">v</i><sub class="calibre15">1</sub> is part of the product; if his first bit is a 0, then <i class="calibre12">v</i><sub class="calibre15">1</sub> is not part of the product, and so on.)
</li>

</ol>

<p class="calibre9">Peggy and Victor repeat this protocol <i class="calibre12">t</i> times, until Victor is convinced that
Peggy knows <i class="calibre12">s</i><sub class="calibre15">1</sub>, <i class="calibre12">s</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">s</i><sub class="calibre15">k</sub>.</p>

<p class="calibre9">The chance that Peggy can fool Victor is 1 in 2<sup class="calibre19">kt</sup>. The authors recommend a 1
in 220 chance of a cheater fooling Victor and suggest that <i class="calibre12">k</i> = 5 and <i class="calibre12">t</i> = 4. If you are more paranoid, increase these numbers.</p>

<h4 class="calibre8">An Example</h4>

<p class="calibre9">Let’s look at this protocol in action with small numbers.</p>

<p class="calibre9">If <i class="calibre12">n</i> = 35 (the two primes are 5 and 7), then the possible quadratic residues are:</p>

<p class="math-left">1: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 1 (mod 35) has the solutions: <i class="calibre12">x</i> = 1, 6, 29, or 34.
4: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 4 (mod 35) has the solutions: <i class="calibre12">x</i> = 2, 12, 23, or 33.
9: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 9 (mod 35) has the solutions: <i class="calibre12">x</i> = 3, 17, 18, or 32.
11: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 11 (mod 35) has the solutions: <i class="calibre12">x</i> = 9, 16, 19, or 26.
14: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 14 (mod 35) has the solutions: <i class="calibre12">x</i> = 7 or 28.
15: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 15 (mod 35) has the solutions: <i class="calibre12">x</i> = 15 or 20.
16: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 16 (mod 35) has the solutions: <i class="calibre12">x</i> = 4, 11, 24, or 31.
21: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 21 (mod 35) has the solutions: <i class="calibre12">x</i> = 14 or 21.
25: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 25 (mod 35) has the solutions: <i class="calibre12">x</i> = 5 or 30.
29: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 29 (mod 35) has the solutions: <i class="calibre12">x</i> = 8, 13, 22 or 27.
30: <i class="calibre12">x</i><sup class="calibre19">2</sup> ≡ 30 (mod 35) has the solutions: <i class="calibre12">x</i> = 10 or 25.
</p>

<p class="calibre9">The inverses (mod 35) and their square roots are:</p>

<pre class="calibre20"><i class="calibre22">v</i>    <i class="calibre22">v</i><sup class="calibre19">-1</sup>  <i class="calibre22">s</i> = sqrt(<i class="calibre22">v</i><sup class="calibre19">-1</sup>)
 1    1    1
 4    9    3
 9    4    2
11   16    4
16   11    9
29   29    8
</pre>

<p class="calibre9">Note that 14, 15, 21, 25, and 30 do not have inverses mod 35, because they are
not relatively prime to 35. This makes sense, because there should be (5 - 1) *
(7 - 1)/4 quadratic residues mod 35 relatively prime to 35: That is gcd(<i class="calibre12">x, </i> 35) =
1 (see <a href="Applied%20Cryptography_split_014.html#11.3" class="calibre5 pcalibre">Section 11.3</a>).</p>

<p class="calibre9">So, Peggy gets the public key consisting of <i class="calibre12">k</i> = 4 values: {4,11,16,29}. The
corresponding private key is {3,4,9,8}. Here’s one round of the protocol.</p>

<ol class="calibre17">

<li class="calibre14">Peggy chooses a random <i class="calibre12">r</i> = 16, computes 16<sup class="calibre19">2</sup> mod 35 = 11, and
sends it to Victor.
</li>
<li class="calibre14">Victor sends Peggy a random binary string {1,1,0,1}.
</li>
<li class="calibre14">Peggy computes 16 * ((3<sup class="calibre19">1</sup>) * (4<sup class="calibre19">1</sup>) * (9<sup class="calibre19">0</sup>) * (8<sup class="calibre19">1</sup>)) mod 35 = 31 and
sends it to Victor.
</li>
<li class="calibre14">Victor verifies that 3<sup class="calibre19">12</sup> * ((4<sup class="calibre19">1</sup>) * (11<sup class="calibre19">1</sup>) * (16<sup class="calibre19">0</sup>) * (29<sup class="calibre19">1</sup>)) mod 35 = 11.
</li>

</ol>

<p class="calibre9">Peggy and Victor repeat the protocol <i class="calibre12">t</i> times, each time with a different
random <i class="calibre12">r, </i> until Victor is satisfied.</p>

<p class="calibre9">With small values like these, there’s no real security. But when <i class="calibre12">n</i> is 512 bits long or more, Victor cannot learn anything about Peggy’s secret key except the
fact that she knows it.</p>

<h4 class="calibre8">Enhancements</h4>

<p class="calibre9">It is possible to embed identification information into the protocol. Assume
that <i class="calibre12">I</i> is a binary string representing Peggy’s identification: her name, address, social security number, hat size, preferred brand of soft drink, and other
personal information. Use a one-way hash function <i class="calibre12">H</i>(<i class="calibre12">x</i>) to compute <i class="calibre12">H</i>(<i class="calibre12">I,j</i>), where <i class="calibre12">j</i> is a small number concatenated onto <i class="calibre12">I. </i> Find a set of <i class="calibre12">j</i>s where <i class="calibre12">H</i>(<i class="calibre12">I,j</i>) is a quadratic residue mod <i class="calibre12">n. </i> These <i class="calibre12">H</i>(<i class="calibre12">I,j</i>)s become <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub> (the <i class="calibre12">j</i>s need not be quadratic residues). Peggy’s public key is now <i class="calibre12">I</i> and the list of <i class="calibre12">j</i>s. She sends <i class="calibre12">I</i> and the list of <i class="calibre12">j</i>s to Victor before step (1) of the protocol (or perhaps Victor downloads them from a public bulletin board someplace), and Victor generates
 <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub> from <i class="calibre12">H</i>(<i class="calibre12">I,j</i>).</p>

<p class="calibre9">Now, after Victor successfully completes the protocol with Peggy, he is
assured that Trent, who knows the factorization of the modulus, has certified
the association between <i class="calibre12">I</i> and Peggy by giving her the square roots of the <i class="calibre12">v</i><sub class="calibre15">i</sub> derived from <i class="calibre12">I. </i> (See <a href="Applied%20Cryptography_split_006.html#5.2" class="calibre5 pcalibre">Section 5.2</a> for background information.)</p>

<p class="calibre9">Feige, Fiat, and Shamir include the following implementation remarks
[<a href="Applied%20Cryptography_split_035.html#r544" class="calibre5 pcalibre">544</a>,<a href="Applied%20Cryptography_split_035.html#r545" class="calibre5 pcalibre">545</a>]:</p>

<p class="quote">For nonperfect hash functions, it may be advisable to randomize <i class="calibre12">I</i>
by concatenating it with a long random string, <i class="calibre12">R. </i> This string is
chosen by the arbitrator and is revealed to Victor along with <i class="calibre12">I. </i>
<br class="calibre3"/><br class="calibre3"/>
In typical implementations, <i class="calibre12">k</i> should be between 1 and 18. Larger
values of <i class="calibre12">k</i> can reduce the time and communication complexity by
reducing the number of rounds.
<br class="calibre3"/><br class="calibre3"/>
The value <i class="calibre12">n</i> should be at least 512 bits long. (Of course, there has
been considerable progress in factoring since then.)
<br class="calibre3"/><br class="calibre3"/>
If each user chooses his own <i class="calibre12">n</i> and publishes it in a public key
file, they can dispense with the arbitrator. However, this RSA-like
variant makes the scheme considerably less convenient.</p>

<h4 class="calibre8">Fiat-Shamir Signature Scheme</h4>

<p class="calibre9">Turning this identification scheme into a signature scheme is basically a matter
of turning Victor into a hash function. The primary benefit of the Fiat-Shamir
digital signature scheme over RSA is speed: Fiat-Shamir requires only 1
percent to 4 percent of the modular multiplications of RSA. For this protocol,
we’ll bring back Alice and Bob.</p>

<p class="calibre9">The setup is the same as the identification scheme. Choose <i class="calibre12">n</i> to be the product of two large primes. Generate the public key, <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub>, and the private key, <i class="calibre12">s</i><sub class="calibre15">1</sub>, <i class="calibre12">s</i><sub class="calibre15">2</sub>,..., <i class="calibre12">s</i><sub class="calibre15">k</sub>, such that <i class="calibre12">s</i><sub class="calibre15">i</sub> = sqrt(<i class="calibre12">v<sub class="calibre15">i</sub></i><sup class="calibre19">-1</sup>) mod <i class="calibre12">n. </i></p>

<ol class="calibre17">

<li class="calibre14">Alice picks <i class="calibre12">t</i> random integers between 1 and <i class="calibre12">n: r</i><sub class="calibre15">1</sub>, <i class="calibre12">r</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">r</i><sub class="calibre15">t</sub>, and computes <i class="calibre12">x</i><sub class="calibre15">1</sub>, <i class="calibre12">x</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">x</i><sub class="calibre15">t</sub> such that <i class="calibre12">x</i><sub class="calibre15">i</sub> = <i class="calibre12">r</i><sub class="calibre15">i</sub><sup class="calibre19">2</sup> mod <i class="calibre12">n. </i>
</li>
<li class="calibre14">Alice hashes the concatenation of the message and the string of <i class="calibre12">x</i><sub class="calibre15">i</sub> is to generate a bit stream: <i class="calibre12">H</i>(<i class="calibre12">m, x</i><sub class="calibre15">1</sub>, <i class="calibre12">x</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">x</i><sub class="calibre15">t</sub>). She uses the first <i class="calibre12">k</i> * <i class="calibre12">t</i> bits of this string as values of <i class="calibre12">b</i><sub class="calibre15">ij</sub>, where <i class="calibre12">i</i> goes from 1 to <i class="calibre12">t, </i> and <i class="calibre12">j</i> goes from 1 to <i class="calibre12">k. </i>
</li>
<li class="calibre14">Alice computes <i class="calibre12">y</i><sub class="calibre15">1</sub>, <i class="calibre12">y</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">y</i><sub class="calibre15">t</sub>, where
<p class="math">y<sub class="calibre15">i</sub> = <i class="calibre12">r</i><sub class="calibre15">i</sub> * (<i class="calibre12">s</i><sub class="calibre15">1</sub><sup class="calibre19">b<sub class="calibre16">i2</sub></sup> * <i class="calibre12">s</i><sub class="calibre15">2</sub><sup class="calibre19">b<sub class="calibre16">i2</sub></sup> * ... * <i class="calibre12">s</i><sub class="calibre15">k</sub><sup class="calibre19">b<sub class="calibre16">ik</sub></sup> ) mod <i class="calibre12">n</i>
</p>
(For each <i class="calibre12">i, </i> she multiplies together the values of the <i class="calibre12">s</i><sub class="calibre15">j</sub> based on the random <i class="calibre12">b</i><sub class="calibre15">i,j</sub> values. If <i class="calibre12">b</i><sub class="calibre15">i,1</sub> is a 1, then <i class="calibre12">s</i><sub class="calibre15">1</sub> is multiplied; if <i class="calibre12">b</i><sub class="calibre15">i,1</sub> is a 0, then <i class="calibre12">s</i><sub class="calibre15">1</sub> is not multiplied.)
</li>
<li class="calibre14">Alice sends Bob <i class="calibre12">m, </i> all the bit values of <i class="calibre12">b</i><sub class="calibre15">i,j</sub>, and all the values of <i class="calibre12">y</i><sub class="calibre15">i</sub>.
He already has Alice’s public key: <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub>.
</li>
<li class="calibre14">Bob computes <i class="calibre12">z</i><sub class="calibre15">1</sub>, <i class="calibre12">z</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">z</i><sub class="calibre15">t</sub>, where
<p class="math">z<sub class="calibre15">i</sub> = <i class="calibre12">y</i><sub class="calibre15">i</sub><sup class="calibre19">2</sup> * (<i class="calibre12">v</i><sub class="calibre15">1</sub><sup class="calibre19">b<sub class="calibre16">i1</sub></sup> * <i class="calibre12">v</i><sub class="calibre15">2</sub><sup class="calibre19">b<sub class="calibre16">i2</sub></sup> * ... * <i class="calibre12">v</i><sub class="calibre15">k</sub><sup class="calibre19">b<sub class="calibre16">ik</sub></sup>) mod <i class="calibre12">n</i>
</p>
(Again, Bob multiplies based on the <i class="calibre12">b</i><sub class="calibre15">i,j</sub> values.) Also note that <i class="calibre12">z</i><sub class="calibre15">i</sub> should be equal to <i class="calibre12">x</i><sub class="calibre15">i</sub>.
</li>
<li class="calibre14">Bob verifies that the first <i class="calibre12">k</i> * <i class="calibre12">t</i> bits of <i class="calibre12">H</i>(<i class="calibre12">m, z</i><sub class="calibre15">1</sub>, <i class="calibre12">z</i><sub class="calibre15">2</sub>,..., <i class="calibre12">z</i><sub class="calibre15">t</sub>) are the <i class="calibre12">b</i><sub class="calibre15">i,j</sub> values that Alice sent him.
</li>

</ol>

<p class="calibre9">As with the identification scheme, the security of this signature scheme is
proportional to 1/2<sup class="calibre19">kt</sup>. It also depends on the difficulty of factoring <i class="calibre12">n. </i> Fiat and
Shamir pointed out that forging a signature is easier when the complexity of
factoring <i class="calibre12">n</i> is considerably lower than 2<sup class="calibre19">kt</sup>. And, because of birthday-type
attacks (see <a href="Applied%20Cryptography_split_021.html#18.1" class="calibre5 pcalibre">Section 18.1</a>), they recommend that <i class="calibre12">k</i> * <i class="calibre12">t</i> be increased from 20 to at least 72. They suggest <i class="calibre12">k</i> = 9 and <i class="calibre12">t</i> = 8.</p>

<h4 class="calibre8">Improved Fiat-Shamir Signature Scheme</h4>

<p class="calibre9">Silvio Micali and Adi Shamir improved the Fiat-Shamir protocol in [<a href="Applied%20Cryptography_split_036.html#r1088" class="calibre5 pcalibre">1088</a>].
They chose <i class="calibre12">v</i><sub class="calibre15">1</sub>, <i class="calibre12">v</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">v</i><sub class="calibre15">k</sub> to be the first <i class="calibre12">k</i> prime numbers. So</p>

<p class="math"><i class="calibre12">v</i><sub class="calibre15">1</sub> = 2, <i class="calibre12">v</i><sub class="calibre15">2</sub> = 3, <i class="calibre12">v</i><sub class="calibre15">3</sub> = 5, and so on.
</p>

<p class="calibre9">This is the public key.</p>

<p class="calibre9">The private key, <i class="calibre12">s</i><sub class="calibre15">1</sub>, <i class="calibre12">s</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">s</i><sub class="calibre15">k</sub> is a random square root, determined by</p>

<p class="math"><i class="calibre12">s</i><sub class="calibre15">i</sub> = sqrt(<i class="calibre12">v</i><sub class="calibre15">i</sub><sup class="calibre19">-1</sup>) mod <i class="calibre12">n</i>
</p>

<p class="calibre9">In this version, every person must have a different <i class="calibre12">n. </i> The modification makes it easier to verify signatures. The time required to generate signatures, and the
security of those signatures, is unaffected.</p>

<h4 class="calibre8">Other Enhancements</h4>

<p class="calibre9">There is also an <i class="calibre12">N-</i>party identification scheme, based on the Fiat-Shamir
algorithm [<a href="Applied%20Cryptography_split_035.html#r264" class="calibre5 pcalibre">264</a>]. Two other improvements to the Fiat-Shamir scheme are
proposed in [<a href="Applied%20Cryptography_split_036.html#r1218" class="calibre5 pcalibre">1218</a>]. Another variant is [<a href="Applied%20Cryptography_split_036.html#r1368" class="calibre5 pcalibre">1368</a>].</p>

<h4 class="calibre8">Ohta-Okamoto Identification Scheme</h4>

<p class="calibre9">This protocol is a modification of the Feige-Fiat-Shamir identification scheme
and gets its security from the difficulty of factoring [<a href="Applied%20Cryptography_split_036.html#r1198" class="calibre5 pcalibre">1198</a>,<a href="Applied%20Cryptography_split_036.html#r1199" class="calibre5 pcalibre">1199</a>]. The same
authors also wrote a multisignature scheme (see <a href="Applied%20Cryptography_split_026.html#23.1" class="calibre5 pcalibre">Section 23.1</a>), by which a
number of different people can sequentially sign a message [<a href="Applied%20Cryptography_split_036.html#r1200" class="calibre5 pcalibre">1200</a>]. This
scheme has been proposed for smart-card implementation [<a href="Applied%20Cryptography_split_036.html#r850" class="calibre5 pcalibre">850</a>].</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">Fiat-Shamir is patented [<a href="Applied%20Cryptography_split_036.html#r1427" class="calibre5 pcalibre">1427</a>]. Anyone interested in licensing the algorithm
should contact <code class="calibre18">Yeda Research and Development, The Weizmann Institute of
Science, Rehovot 76100, Israel</code>.</p>

<h3 id="21.2" class="calibre7">21.2 Guillou-Quisquater</h3>

<p class="calibre9">Feige-Fiat-Shamir was the first practical identity-based protocol. It minimized
computation by increasing the number of iterations and accreditations per
iteration. For some implementations, like smart cards, this is less than ideal.
Exchanges with the outside world are time-consuming, and the storage
required for each accreditation can strain the limited resources of the card.</p>

<p class="calibre9">Louis Guillou and Jean-Jacques Quisquater developed a zero-knowledge
identification algorithm more suited to applications like these [<a href="Applied%20Cryptography_split_035.html#r670" class="calibre5 pcalibre">670</a>,<a href="Applied%20Cryptography_split_036.html#r1280" class="calibre5 pcalibre">1280</a>]. The
exchanges between Peggy and Victor and the parallel accreditations in each
exchange are both kept to an absolute minimum: There is only one exchange
of one accreditation for each proof. For the same level of security, the
computation required by Guillou-Quisquater is greater than by
Feige-Fiat-Shamir by a factor of three. And like Feige-Fiat-Shamir, this
identification algorithm can be converted to a digital signature algorithm.</p>

<h4 class="calibre8">Guillou-Quisquater Identification Scheme</h4>

<p class="calibre9">Peggy is a smart card who wants to prove her identity to Victor. Peggy’s
identity consists of a set of credentials: a data string consisting of the card’s
name, validity period, a bank account number, and whatever else the
application warrants. This bit string is called <i class="calibre12">J. </i> (Actually, the credentials can be a longer string and hashed to a <i class="calibre12">J</i> value. This complexity does not modify
the protocol in any way.) This is analogous to the public key. Other public
information, shared by all “Peggys” who could use this application, is an
exponent <i class="calibre12">v</i> and a modulus <i class="calibre12">n, </i> where <i class="calibre12">n</i> is the product of two secret primes. The private key is <i class="calibre12">B, </i> calculated such that <i class="calibre12">JB</i><sup class="calibre19">v</sup> ≡ 1 (mod <i class="calibre12">n</i>).</p>

<p class="calibre9">Peggy sends Victor her credentials, <i class="calibre12">J. </i> Now, she wants to prove to Victor that those credentials are hers. To do this, she has to convince Victor that she
knows <i class="calibre12">B. </i> Here’s the protocol:</p>

<ol class="calibre17">

<li class="calibre14">Peggy picks a random integer <i class="calibre12">r, </i> such that <i class="calibre12">r</i> is between 1 and <i class="calibre12">n</i> - 1.
She computes <i class="calibre12">T</i> = <i class="calibre12">r</i><sup class="calibre19">v</sup> mod <i class="calibre12">n</i> and sends it to Victor.
</li>
<li class="calibre14">Victor picks a random integer, <i class="calibre12">d, </i> such that <i class="calibre12">d</i> is between zero and <i class="calibre12">v</i> -
1. He sends <i class="calibre12">d</i> to Peggy.
</li>
<li class="calibre14">Peggy computes <i class="calibre12">D</i> = <i class="calibre12">rB</i><sup class="calibre19">d</sup> mod <i class="calibre12">n, </i> and sends it to Victor.
</li>
<li class="calibre14">Victor computes <i class="calibre12">T</i>´ = <i class="calibre12">D</i><sup class="calibre19">v</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> mod <i class="calibre12">n. </i> If <i class="calibre12">T</i> ≡ <i class="calibre12">T</i>´ (mod <i class="calibre12">n</i>), then the authentication succeeds.
</li>

</ol>

<p class="calibre9">The math isn’t that complex:</p>

<p class="math"><i class="calibre12">T</i>´ = <i class="calibre12">D</i><sup class="calibre19">v</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> = (<i class="calibre12">rB</i><sup class="calibre19">d</sup>)<sup class="calibre19">v</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> = <i class="calibre12">r</i><sup class="calibre19">v</sup>B<sup class="calibre19">dv</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> = <i class="calibre12">r</i><sup class="calibre19">v</sup>(<i class="calibre12">JB</i><sup class="calibre19">v</sup>)<sup class="calibre19">d</sup> = <i class="calibre12">r</i><sup class="calibre19">v</sup> ≡ <i class="calibre12">T</i> (mod <i class="calibre12">n</i>)
</p>

<p class="calibre9">since <i class="calibre12">B</i> was constructed to satisfy</p>

<p class="math"><i class="calibre12">JB</i><sup class="calibre19">v</sup> ≡ 1 (mod <i class="calibre12">n</i>)
</p>

<h4 class="calibre8">Guillou-Quisquater Signature Scheme</h4>

<p class="calibre9">This identification can be converted to a signature scheme, also suited for
smart-card implementation [<a href="Applied%20Cryptography_split_035.html#r671" class="calibre5 pcalibre">671</a>,<a href="Applied%20Cryptography_split_035.html#r672" class="calibre5 pcalibre">672</a>].</p>

<p class="calibre9">The public and private key setup is the same as before. Here’s the protocol:</p>

<ol class="calibre17">

<li class="calibre14">Alice picks a random integer <i class="calibre12">r, </i> such that <i class="calibre12">r</i> is between 1 and <i class="calibre12">n</i> - 1.
She computes <i class="calibre12">T</i> = <i class="calibre12">r</i><sup class="calibre19">v</sup> mod <i class="calibre12">n. </i>
</li>
<li class="calibre14">Alice computes <i class="calibre12">d</i> = <i class="calibre12">H</i>(<i class="calibre12">M,T</i>), where <i class="calibre12">M</i> is the message being signed and <i class="calibre12">H</i>(<i class="calibre12">x</i>) is a one-way hash function. The <i class="calibre12">d</i> produced by the hash function must be between 0 and <i class="calibre12">v</i> - 1 [<a href="Applied%20Cryptography_split_036.html#r1280" class="calibre5 pcalibre">1280</a>]. If the output of the hash
function is not within this range, it must be reduced modulo <i class="calibre12">v. </i>
</li>
<li class="calibre14">Alice computes <i class="calibre12">D</i> = <i class="calibre12">rB</i><sup class="calibre19">d</sup> mod <i class="calibre12">n. </i> The signature consists of the message, <i class="calibre12">M, </i> the two calculated values, <i class="calibre12">d</i> and <i class="calibre12">D, </i> and her credentials, <i class="calibre12">J. </i>
She sends this signature to Bob.
</li>
<li class="calibre14">Bob computes <i class="calibre12">T</i>´ = <i class="calibre12">D</i><sup class="calibre19">v</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> mod <i class="calibre12">n. </i> He then computes <i class="calibre12">d</i>´ = <i class="calibre12">H</i>(<i class="calibre12">M,T</i>´). If <i class="calibre12">d</i> = <i class="calibre12">d</i>´, then Alice must know <i class="calibre12">B</i> and the signature is valid.
</li>

</ol>

<h4 class="calibre8">Multiple Signatures</h4>

<p class="calibre9">What if many people want to sign the same document? The easy solution has
each of them signing separately, but this signature scheme can do better than
that. Here Alice and Bob sign the same document and Carol verifies the
signatures, but any number of people can be involved in the signature process.
As before, Alice and Bob have their own unique <i class="calibre12">J</i> and <i class="calibre12">B</i> values: (<i class="calibre12">J</i><sub class="calibre15">A</sub>, <i class="calibre12">B</i><sub class="calibre15">A</sub>) and (<i class="calibre12">J</i><sub class="calibre15">B</sub>, <i class="calibre12">B</i><sub class="calibre15">B</sub>). The values <i class="calibre12">n</i> and <i class="calibre12">v</i> are common to the system.</p>

<ol class="calibre17">

<li class="calibre14">Alice picks a random integer, <i class="calibre12">r</i><sub class="calibre15">A</sub>, such that <i class="calibre12">r</i><sub class="calibre15">A</sub> is between 1 and <i class="calibre12">n</i> -
1. She computes <i class="calibre12">T</i>
A = <i class="calibre12">r</i><sub class="calibre15">A</sub><sup class="calibre19">v</sup> mod <i class="calibre12">n</i> and sends <i class="calibre12">T</i><sub class="calibre15">A</sub> to Bob.
</li>
<li class="calibre14">Bob picks a random integer, <i class="calibre12">r</i><sub class="calibre15">B</sub>, such that <i class="calibre12">r</i><sub class="calibre15">B</sub> is between 1 and <i class="calibre12">n</i> - 1.
He computes <i class="calibre12">T</i><sub class="calibre15">B</sub> = <i class="calibre12">r</i><sub class="calibre15">B</sub><sup class="calibre19">v</sup> mod <i class="calibre12">n</i> and sends <i class="calibre12">T</i><sub class="calibre15">B</sub> to Alice.
</li>
<li class="calibre14">Alice and Bob each compute <i class="calibre12">T</i> = (<i class="calibre12">T</i><sub class="calibre15">A</sub><i class="calibre12">T</i><sub class="calibre15">B</sub>) mod <i class="calibre12">n. </i>
</li>
<li class="calibre14">Alice and Bob each compute <i class="calibre12">d</i> = <i class="calibre12">H</i>(<i class="calibre12">M,T</i>), where <i class="calibre12">M</i> is the message being signed and <i class="calibre12">H</i>(<i class="calibre12">x</i>) is a one-way hash function. The <i class="calibre12">d</i> produced by the hash function must be between 0 and <i class="calibre12">v</i> - 1 [<a href="Applied%20Cryptography_split_036.html#r1280" class="calibre5 pcalibre">1280</a>]. If the output of
the hash function is not within this range, it must be reduced modulo <i class="calibre12">v. </i>
</li>
<li class="calibre14">Alice computes <i class="calibre12">D</i><sub class="calibre15">A</sub> = <i class="calibre12">r</i><sub class="calibre15">A</sub><i class="calibre12">B</i><sub class="calibre15">A</sub><sup class="calibre19">d</sup> mod <i class="calibre12">n</i> and sends <i class="calibre12">D</i><sub class="calibre15">A</sub> to Bob.
</li>
<li class="calibre14">Bob computes <i class="calibre12">D</i><sub class="calibre15">B</sub> = <i class="calibre12">r</i><sub class="calibre15">B</sub><i class="calibre12">B</i><sub class="calibre15">B</sub><sup class="calibre19">d</sup> mod <i class="calibre12">n</i> and sends <i class="calibre12">D</i><sub class="calibre15">B</sub> to Alice.
</li>
<li class="calibre14">Alice and Bob each compute <i class="calibre12">D</i> = <i class="calibre12">D</i><sub class="calibre15">A</sub><i class="calibre12">D</i><sub class="calibre15">B</sub> mod <i class="calibre12">n. </i> The signature consists of the message, <i class="calibre12">M, </i> the two calculated values, <i class="calibre12">d</i> and <i class="calibre12">D, </i> and both of their credentials: <i class="calibre12">J</i><sub class="calibre15">A</sub> and <i class="calibre12">J</i><sub class="calibre15">B</sub>.
</li>
<li class="calibre14">Carol computes <i class="calibre12">J</i> = <i class="calibre12">J</i><sub class="calibre15">A</sub><i class="calibre12">J</i><sub class="calibre15">B</sub> mod <i class="calibre12">n. </i>
</li>
<li class="calibre14">Carol computes <i class="calibre12">T</i>´ = <i class="calibre12">D</i><sup class="calibre19">v</sup><i class="calibre12">J</i><sup class="calibre19">d</sup> mod <i class="calibre12">n. </i> She then computes <i class="calibre12">d</i>´ = <i class="calibre12">H</i>(<i class="calibre12">M,T</i>´).
If <i class="calibre12">d</i> ≡ <i class="calibre12">d</i>´, then the multiple signature is valid.
</li>

</ol>

<p class="calibre9">This protocol can be extended to any number of people. For multiple people to
sign, they all multiply their individual <i class="calibre12">T</i><sub class="calibre15">i</sub> values together in step (3), and their individual <i class="calibre12">D</i><sub class="calibre15">i</sub> values together in step (7). To verify a multiple signature,
multiply all the signers <i class="calibre12">J</i><sub class="calibre15">i</sub> values together in step (8). Either all the signatures are valid or there is at least one invalid signature.</p>

<h3 id="21.3" class="calibre7">21.3 Schnorr</h3>

<p class="calibre9">Claus Schnorr’s authentication and signature scheme [<a href="Applied%20Cryptography_split_036.html#r1396" class="calibre5 pcalibre">1396</a>,<a href="Applied%20Cryptography_split_036.html#r1397" class="calibre5 pcalibre">1397</a>] gets its
security from the difficulty of calculating discrete logarithms. To generate a
key pair, first choose two primes, <i class="calibre12">p</i> and <i class="calibre12">q, </i> such that <i class="calibre12">q</i> is a prime factor of <i class="calibre12">p</i> - 1.
Then, choose an <i class="calibre12">a</i> not equal to 1, such that <i class="calibre12">a</i><sup class="calibre19">q</sup> ≡ 1 (mod <i class="calibre12">p</i>). All these numbers can be common to a group of users and can be freely published.</p>

<p class="calibre9">To generate a particular public-key/private-key key pair, choose a random
number less than <i class="calibre12">q. </i> This is the private key, <i class="calibre12">s. </i> Then calculate <i class="calibre12">v</i> = <i class="calibre12">a</i><sup class="calibre19">-s</sup> mod <i class="calibre12">p. </i>
This is the public key.</p>

<h4 class="calibre8">Authentication Protocol</h4>

<ol class="calibre17">

<li class="calibre14">Peggy picks a random number, <i class="calibre12">r, </i> less than <i class="calibre12">q, </i> and computes <i class="calibre12">x</i> = <i class="calibre12">a</i><sup class="calibre19">r</sup> mod <i class="calibre12">p. </i> This is the preprocessing stage and can be done long before
Victor is present.
</li>
<li class="calibre14">Peggy sends <i class="calibre12">x</i> to Victor.
</li>
<li class="calibre14">Victor sends Peggy a random number, <i class="calibre12">e, </i> between 0 and 2<sup class="calibre19">t</sup> - 1. (I’ll discuss <i class="calibre12">t</i> in a moment.)
</li>
<li class="calibre14">Peggy computes <i class="calibre12">y</i> = (<i class="calibre12">r</i> + <i class="calibre12">se</i>) mod <i class="calibre12">q</i> and sends <i class="calibre12">y</i> to Victor.
</li>
<li class="calibre14">Victor verifies that <i class="calibre12">x</i> = <i class="calibre12">a</i><sup class="calibre19">y</sup><i class="calibre12">v</i><sup class="calibre19">e</sup> mod <i class="calibre12">p. </i>
</li>

</ol>

<p class="calibre9">The security is based on the parameter <i class="calibre12">t. </i> The difficulty of breaking the
algorithm is about 2<sup class="calibre19">t</sup>. Schnorr recommended that <i class="calibre12">p</i> be about 512 bits, <i class="calibre12">q</i> be about 140 bits, and <i class="calibre12">t</i> be 72.</p>

<h4 class="calibre8">Digital Signature Protocol</h4>

<p class="calibre9">Schnorr can also be used as a digital signature protocol on a message, <i class="calibre12">M. </i> The public-key/private-key key pair is the same, but we’re now adding a one-way
hash function, <i class="calibre12">H</i>(<i class="calibre12">M</i>).</p>

<ol class="calibre17">

<li class="calibre14">Alice picks a random number, <i class="calibre12">r, </i> less than <i class="calibre12">q, </i> and computes <i class="calibre12">x</i> = <i class="calibre12">a</i><sup class="calibre19">r</sup> mod <i class="calibre12">p. </i> This computation is the preprocessing stage.
</li>
<li class="calibre14">Alice concatenates <i class="calibre12">M</i> and <i class="calibre12">x, </i> and hashes the result:
<p class="math"><i class="calibre12">e</i> = <i class="calibre12">H</i>(<i class="calibre12">M,x</i>)
</p>
</li>
<li class="calibre14">Alice computes <i class="calibre12">y</i> = (<i class="calibre12">r</i> + <i class="calibre12">se</i>) mod <i class="calibre12">q. </i> The signature is <i class="calibre12">e</i> and <i class="calibre12">y; </i> she sends these to Bob.
</li>
<li class="calibre14">Bob computes <i class="calibre12">x</i>´ = <i class="calibre12">a</i><sup class="calibre19">y</sup><i class="calibre12">v</i><sup class="calibre19">e</sup> mod <i class="calibre12">p. </i> He then confirms that the concatenation of <i class="calibre12">M</i> and <i class="calibre12">x</i>´ hashes to <i class="calibre12">e. </i>
<p class="math"><i class="calibre12">e</i> = <i class="calibre12">H</i>(<i class="calibre12">M,x</i>´)
</p>
If it does, he accepts the signature as valid.
</li>

</ol>

<p class="calibre9">In his paper, Schnorr cites these novel features of his algorithm:</p>

<p class="quote">Most of the computation for signature generation can be
completed in a preprocessing stage, independent of the message
being signed. Hence, it can be done during idle time and not
affect the signature speed. An attack against this preprocessing
stage is discussed in [<a href="Applied%20Cryptography_split_035.html#r475" class="calibre5 pcalibre">475</a>], but I don’t think it’s practical.
<br class="calibre3"/><br class="calibre3"/>
For the same level of security, the length of signatures is less for
Schnorr than for RSA. For example, with a 140-bit <i class="calibre12">q, </i> signatures
are only 212-bits long, less than half the length of RSA
signatures. Schnorr’s signatures are also much shorter than
ElGamal signatures.</p>

<p class="calibre9">Of course, practical considerations may make even fewer bits suitable for a
given scheme: For example, an identification scheme where the cheater must
perform an on-line attack in only a few seconds, versus a signature scheme
where the cheater can calculate for years off-line to come up with a forgery.</p>

<p class="calibre9">A modification of this algorithm, by Ernie Brickell and Kevin McCurley,
enhances its security [<a href="Applied%20Cryptography_split_035.html#r265" class="calibre5 pcalibre">265</a>].</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">Schnorr is patented in the United States [<a href="Applied%20Cryptography_split_036.html#r1398" class="calibre5 pcalibre">1398</a>] and in many other countries. In
1993, PKP acquired the worldwide rights to the patent (see <a href="Applied%20Cryptography_split_029.html#25.5" class="calibre5 pcalibre">Section 25.5</a>). The
U.S. patent expires on February 19, 2008.</p>

<h3 id="21.4" class="calibre7">21.4 Converting Identification Schemes to Signature Schemes</h3>

<p class="calibre9">There is a standard method of converting an identification scheme into a
signature scheme: Replace Victor with a one-way hash function. The message
is not hashed before it is signed; instead the hashing is incorporated into the
signing algorithm. In principle, this can be done with any identification
scheme.</p>

<div class="calibre6" id="calibre_pb_48"></div>
</div>






</body></html>
