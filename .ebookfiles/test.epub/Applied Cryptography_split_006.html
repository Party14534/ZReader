<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="5">Chapter 5 <br class="calibre3"/>
Advanced Protocols</h1>

<h3 id="5.1" class="calibre7">5.1 Zero-Knowledge Proofs</h3>

<p class="calibre9">Here’s another story:</p>

<ul class="split1">

<li class="calibre35">Alice: “I know the password to the Federal Reserve System
computer, the ingredients in McDonald’s secret sauce, and the
contents of Volume 4 of Knuth.”</li>

<li class="calibre35">Bob: “No, you don’t.”</li>

<li class="calibre35">Alice: “Yes, I do.”</li>

<li class="calibre35">Bob: “Do not!”</li>

<li class="calibre35">Alice: “Do too!”</li>

<li class="calibre35">Bob: “Prove it!”</li>

<li class="calibre35">Alice: “All right. I’ll tell you.” She whispers in Bob’s ear.</li>

<li class="calibre35">Bob: “That’s interesting. Now I know it, too. I’m going to tell <i class="calibre12">The Washington Post</i>.”</li>

<li class="calibre35">Alice: “Oops.”</li>

</ul>

<p class="calibre9">Unfortunately, the usual way for Alice to prove something to Bob is for Alice
to tell him. But then he knows it, too. Bob can then tell anyone else he wants
to and Alice can do nothing about it. (In the literature, different characters are
often used in these protocols. Peggy is usually cast as the prover and Victor is
the verifier. These names appear in the upcoming examples, instead of Alice
and Bob.)</p>

<p class="calibre9">Using one-way functions, Peggy could perform a <b class="calibre10">zero-knowledge proof</b>
[<a href="Applied%20Cryptography_split_035.html#r626" class="calibre5 pcalibre">626</a>]. This protocol proves to Victor that Peggy does have a piece of
information, but it does not give Victor any way to know what the information
is.</p>

<p class="calibre9">These proofs take the form of interactive protocols. Victor asks Peggy a series
of questions. If Peggy knows the secret, she can answer all the questions
correctly. If she does not, she has some chance — 50 percent in the following
examples — of answering correctly. After 10 or so questions, Victor will be
convinced that Peggy knows the secret. Yet none of the questions or answers
gives Victor any information about Peggy’s information — only about her
knowledge of it.</p>

<h4 class="calibre8">Basic Zero-Knowledge Protocol</h4>

<p class="calibre9">Jean-Jacques Quisquater and Louis Guillou explain zero-knowledge with a
story about a cave [<a href="Applied%20Cryptography_split_036.html#r1281" class="calibre5 pcalibre">1281</a>]. The cave, illustrated in Figure 5.1, has a secret.
Someone who knows the magic words can open the secret door between C and
D. To everyone else, both passages lead to dead ends.</p>

<div class="figure" id="figure-5-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-5-1.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 5.1</b> The zero-knowledge cave.</i></p>
</div>

<p class="calibre9">Peggy knows the secret of the cave. She wants to prove her knowledge to
Victor, but she doesn’t want to reveal the magic words. Here’s how she
convinces him:</p>

<ol class="calibre17">

<li class="calibre14">Victor stands at point A.
</li>
<li class="calibre14">Peggy walks all the way into the cave, either to point C or point D.
</li>
<li class="calibre14">After Peggy has disappeared into the cave, Victor walks to point B.
</li>
<li class="calibre14">Victor shouts to Peggy, asking her either to:
<ol class="calibre43">
<li class="calibre14">come out of the left passage or</li>
<li class="calibre14">come out of the right passage.</li>
</ol>
</li>
<li class="calibre14">Peggy complies, using the magic words to open the secret door if
she has to.
</li>
<li class="calibre14">Peggy and Victor repeat steps (1) through (5) <i class="calibre12">n</i> times.
</li>

</ol>

<p class="calibre9">Assume that Victor has a camcorder and records everything he sees. He
records Peggy disappearing into the cave, he records when he shouts out where
he wants Peggy to come out from, and he records Peggy coming out. He
records all <i class="calibre12">n</i> trials. If he showed this recording to Carol, would she believe that Peggy knew the magic words to open the door? No. What if Peggy and Victor
had agreed beforehand what Victor would call out, and Peggy would make
sure that she went into that path. Then she could come out where Victor asked
her every time, without knowing the magic words. Or maybe they couldn’t do
that. Peggy would go into one of the passages and Victor would call out a
random request. If Victor guessed right, great; if he didn’t, they would edit that
trial out of the camcorder recording. Either way, Victor can get a recording
showing exactly the same sequence of events as in a real proof where Peggy
knew the magic words.</p>

<p class="calibre9">This shows two things. One, it is impossible for Victor to convince a third
party of the proof’s validity. And two, it proves that the protocol is
zero-knowledge. In the case where Peggy did not know the magic words,
Victor will obviously not learn anything from watching the recording. But
since there is no way to distinguish a real recording from a faked recording,
Victor cannot learn anything from the real proof — it must be zero knowledge.</p>

<p class="calibre9">The technique used in this protocol is called <b class="calibre10">cut and choose</b>, because of its
similarity to the classic protocol for dividing anything fairly:</p>

<ol class="calibre17">

<li class="calibre14">Alice cuts the thing in half.
</li>
<li class="calibre14">Bob chooses one of the halves for himself.
</li>
<li class="calibre14">Alice takes the remaining half.
</li>

</ol>

<p class="calibre9">It is in Alice’s best interest to divide fairly in step (1), because Bob will choose
whichever half he wants in step (2). Michael Rabin was the first person to use
the cut-and-choose technique in cryptography [<a href="Applied%20Cryptography_split_036.html#r1282" class="calibre5 pcalibre">1282</a>]. The concepts of
<b class="calibre10">interactive protocol</b> and zero-knowledge were formalized later [<a href="Applied%20Cryptography_split_035.html#r626" class="calibre5 pcalibre">626</a>,<a href="Applied%20Cryptography_split_035.html#r627" class="calibre5 pcalibre">627</a>].</p>

<p class="calibre9">The cut-and-choose protocol works because there is no way Peggy can
repeatedly guess which side Victor will ask her to come out of. If Peggy
doesn’t know the secret, she can only come out the way she came in. She has a
50 percent chance of guessing which side Victor will ask in each round
(sometimes called an <b class="calibre10">accreditation</b>) of the protocol, so she has a 50 percent
chance of fooling him. The chance of her fooling him in two rounds is 25
percent, and the chance of her fooling him all <i class="calibre12">n</i> times is 1 in 2<sup class="calibre19">n</sup>. After 16
rounds, Peggy has a 1 in 65,536 chance of fooling Victor. Victor can safely
assume that if all 16 of Peggy’s proofs are valid, then she must know the secret
words to open the door between points C and D. (The cave analogy isn’t
perfect. Peggy can simply walk in one side and out the other; there’s no need
for any cut-and-choose protocol. However, mathematical zero knowledge
requires it.)</p>

<p class="calibre9">Assume that Peggy knows some information, and furthermore that the
information is the solution to a hard problem. The basic zero-knowledge
protocol consists of several rounds.</p>

<ol class="calibre17">

<li class="calibre14">Peggy uses her information and a random number to transform the
hard problem into another hard problem, one that is isomorphic to the
original problem. She then uses her information and the random number
to solve this new instance of the hard problem.
</li>
<li class="calibre14">Peggy commits to the solution of the new instance, using a
bit-commitment scheme.
</li>
<li class="calibre14">Peggy reveals to Victor the new instance. Victor cannot use this
new problem to get any information about the original instance or its
solution.
</li>
<li class="calibre14">Victor asks Peggy either to:
<ol class="calibre43">
<li class="calibre14">prove to him that the old and new instances are isomorphic
(i.e., two different solutions to two related problems), or</li>
<li class="calibre14">open the solution she committed to in step (2) and prove that
it is a solution to the new instance.</li>
</ol>
</li>
<li class="calibre14">Peggy complies.
</li>
<li class="calibre14">Peggy and Victor repeat steps (1) through (5) <i class="calibre12">n</i> times.
</li>

</ol>

<p class="calibre9">Remember the camcorder in the cave protocol? You can do the same thing
here. Victor can make a transcript of the exchange between him and Peggy. He
cannot use this transcript to convince Carol, because he can always collude
with Peggy to build a simulator that fakes Peggy’s knowledge. This argument
can be used to prove that the proof is zero-knowledge.</p>

<p class="calibre9">The mathematics behind this type of proof is complicated. The problems and
the random transformation must be chosen carefully, so that Victor does not
get any information about the solution to the original problem, even after many
iterations of the protocol. Not all hard problems can be used for
zero-knowledge proofs, but a lot of them can.</p>

<h4 class="calibre8">Graph Isomorphism</h4>

<p class="calibre9">An example might go a long way to explain this concept; this one comes from
graph theory [<a href="Applied%20Cryptography_split_035.html#r619" class="calibre5 pcalibre">619</a>,<a href="Applied%20Cryptography_split_035.html#r622" class="calibre5 pcalibre">622</a>]. A graph is a network of lines connecting different
points. If two graphs are identical except for the names of the points, they are
called <b class="calibre10">isomorphic</b>. For an extremely large graph, finding whether two graphs
are isomorphic can take centuries of computer time; it’s one of those <b class="calibre10">NP-complete</b> problems 
discussed in <a href="Applied%20Cryptography_split_014.html#11.1" class="calibre5 pcalibre">Section 11.1</a>.</p>

<p class="calibre9">Assume that Peggy knows the isomorphism between the two graphs, <i class="calibre12">G</i><sub class="calibre15">1</sub> and
 <i class="calibre12">G</i><sub class="calibre15">2</sub>. The following protocol will convince Victor of Peggy’s knowledge:</p>

<ol class="calibre17">

<li class="calibre14">Peggy randomly permutes <i class="calibre12">G</i><sub class="calibre15">1</sub> to produce another graph, <i class="calibre12">H</i>, that is isomorphic to <i class="calibre12">G</i><sub class="calibre15">1</sub>. Because Peggy knows the isomorphism between <i class="calibre12">H</i>
and <i class="calibre12">G</i><sub class="calibre15">1</sub>, she also knows the isomorphism between <i class="calibre12">H</i> and <i class="calibre12">G</i><sub class="calibre15">2</sub>. For anyone else, finding an isomorphism between <i class="calibre12">G</i><sub class="calibre15">1</sub> and <i class="calibre12">H</i> or between <i class="calibre12">G</i><sub class="calibre15">2</sub> and <i class="calibre12">H</i> is just as hard as finding an isomorphism between <i class="calibre12">G</i><sub class="calibre15">1</sub> and <i class="calibre12">G</i><sub class="calibre15">2</sub>.
</li>
<li class="calibre14">Peggy sends <i class="calibre12">H</i> to Victor.
</li>
<li class="calibre14">Victor asks Peggy either to:
<ol class="calibre43">
<li class="calibre14">prove that <i class="calibre12">H</i> and <i class="calibre12">G</i><sub class="calibre15">1</sub> are isomorphic, or</li>
<li class="calibre14">prove that <i class="calibre12">H</i> and <i class="calibre12">G</i><sub class="calibre15">2</sub> are isomorphic.</li>
</ol>
</li>
<li class="calibre14">Peggy complies. She either:
<ol class="calibre43">
<li class="calibre14">proves that <i class="calibre12">H</i> and <i class="calibre12">G</i><sub class="calibre15">1</sub> are isomorphic, without proving that <i class="calibre12">H</i>
and <i class="calibre12">G</i><sub class="calibre15">2</sub> are isomorphic, or</li>
<li class="calibre14">proves that <i class="calibre12">H</i> and <i class="calibre12">G</i><sub class="calibre15">2</sub> are isomorphic, without proving that <i class="calibre12">H</i>
and <i class="calibre12">G</i><sub class="calibre15">1</sub> are isomorphic.</li>
</ol>
</li>
<li class="calibre14">Peggy and Victor repeat steps (1) through (4) <i class="calibre12">n</i> times.
</li>

</ol>

<p class="calibre9">If Peggy does not know an isomorphism between <i class="calibre12">G</i><sub class="calibre15">1</sub> and <i class="calibre12">G</i><sub class="calibre15">2</sub>, she cannot create graph <i class="calibre12">H</i> which is isomorphic to both. She can create a graph that is either
isomorphic to <i class="calibre12">G</i><sub class="calibre15">1</sub> or one that is isomorphic to <i class="calibre12">G</i><sub class="calibre15">2</sub>. Like the previous example, she has only a 50 percent chance of guessing which proof Victor will ask her
to perform in step (3).</p>

<p class="calibre9">This protocol doesn’t give Victor any useful information to aid him in figuring
out an isomorphism between <i class="calibre12">G</i><sub class="calibre15">1</sub> and <i class="calibre12">G</i><sub class="calibre15">2</sub>. Because Peggy generates a new graph <i class="calibre12">H</i> for each round of the protocol, he can get no information no matter how
many rounds they go through the protocol. He won’t be able to figure out an
isomorphism between <i class="calibre12">G</i><sub class="calibre15">1</sub> and <i class="calibre12">G</i><sub class="calibre15">2</sub> from Peggy’s answers.</p>

<p class="calibre9">In each round, Victor receives a new random permutation of <i class="calibre12">H</i>, along with an
isomorphism between <i class="calibre12">H</i> and either <i class="calibre12">G</i><sub class="calibre15">1</sub> or <i class="calibre12">G</i><sub class="calibre15">2</sub>. Victor could just as well have generated this by himself. Because Victor can create a simulation of the
protocol, it can be proven to be zero-knowledge.</p>

<h4 class="calibre8">Hamiltonian Cycles</h4>

<p class="calibre9">A variant of this example was first presented by Manuel Blum [<a href="Applied%20Cryptography_split_035.html#r196" class="calibre5 pcalibre">196</a>]. Peggy
knows a circular, continuous path along the lines of a graph that passes
through each point exactly once. This is called a <b class="calibre10">Hamiltonian cycle</b>. Finding a
Hamiltonian cycle is another hard problem. Peggy has this piece of
information — she probably got it by creating the graph with a certain
Hamiltonian cycle — and this is what she wants to convince Victor that she
knows.</p>

<p class="calibre9">Peggy knows the Hamiltonian cycle of a graph, <i class="calibre12">G</i>. Victor knows <i class="calibre12">G</i>, but not the Hamiltonian cycle. Peggy wants to prove to Victor that she knows this
Hamiltonian cycle without revealing it. This is how she does it:</p>

<ol class="calibre17">

<li class="calibre14">Peggy randomly permutes <i class="calibre12">G</i>. She moves the points around and
changes their labels to make a new graph, <i class="calibre12">H</i>. Since <i class="calibre12">G</i> and <i class="calibre12">H</i> are topologically isomorphic (i.e., the same graph), if she knows the
Hamiltonian cycle of <i class="calibre12">G</i> then she can easily find the Hamiltonian cycle
of <i class="calibre12">H</i>. If she didn’t create <i class="calibre12">H</i> herself, determining the isomorphism
between two graphs would be another hard problem; it could also take
centuries of computer time. She then encrypts <i class="calibre12">H</i> to get <i class="calibre12">H´</i>. (This has to be a probabilistic encryption of each line in <i class="calibre12">H</i>, that is, an encrypted 0 or
an encrypted 1 for each line in <i class="calibre12">H</i>.)
</li>
<li class="calibre14">Peggy gives Victor a copy of <i class="calibre12">H´</i>.
</li>
<li class="calibre14">Victor asks Peggy either to:
<ol class="calibre43">
<li class="calibre14">prove to him that <i class="calibre12">H´</i> is an encryption of an isomorphic copy
of <i class="calibre12">G</i>, or</li>
<li class="calibre14">show him a Hamiltonian cycle for <i class="calibre12">H</i>.</li>
</ol>
</li>
<li class="calibre14">Peggy complies. She either:
<ol class="calibre43">
<li class="calibre14">proves that <i class="calibre12">H´</i> is an encryption of an isomorphic copy of <i class="calibre12">G</i> by revealing the permutations and decrypting everything, without
showing a Hamiltonian cycle for either <i class="calibre12">G</i> or <i class="calibre12">H</i>, or</li>
<li class="calibre14">shows a Hamiltonian cycle for <i class="calibre12">H</i> by decrypting only those
lines that constitute a Hamiltonian cycle, without proving that <i class="calibre12">G</i>
and <i class="calibre12">H</i> are topologically isomorphic.</li>
</ol>
</li>
<li class="calibre14">Peggy and Victor repeat steps (1) through (4) <i class="calibre12">n</i> times.
</li>

</ol>

<p class="calibre9">If Peggy is honest, she can provide either proof in step (4) to Victor. However,
if she does not know a Hamiltonian cycle for <i class="calibre12">G</i>, she cannot create an
encrypted graph <i class="calibre12">H´</i> which can meet both challenges. The best she can do is to
create a graph that is either isomorphic to <i class="calibre12">G</i> or one that has the same number
of points and lines and a valid Hamiltonian cycle. While she has a 50 percent
chance of guessing which proof Victor will ask her to perform in step (3),
Victor can repeat the protocol enough times to convince himself that Peggy
knows a Hamiltonian cycle for <i class="calibre12">G</i>.</p>

<h4 class="calibre8">Parallel Zero-Knowledge Proofs</h4>

<p class="calibre9">The basic zero-knowledge protocol involves <i class="calibre12">n</i> exchanges between Peggy and
Victor. Why not do them all in parallel:</p>

<ol class="calibre17">

<li class="calibre14">Peggy uses her information and <i class="calibre12">n</i> random numbers to transform the
hard problem into <i class="calibre12">n</i> different isomorphic problems. She then uses her
information and the random numbers to solve the <i class="calibre12">n</i> new hard problems.
</li>
<li class="calibre14">Peggy commits to the solution of the <i class="calibre12">n</i> new hard problems.
</li>
<li class="calibre14">Peggy reveals to Victor the <i class="calibre12">n</i> new hard problems. Victor cannot use these new problems to get any information about the original problems
or its solutions.
</li>
<li class="calibre14">For each of the <i class="calibre12">n</i> new hard problems, Victor asks Peggy either to:
<ol class="calibre43">
<li class="calibre14">prove to him that the old and new problems are isomorphic, or</li>
<li class="calibre14">open the solution she committed to in step (2) and prove that
it is a solution to the new problem.</li>
</ol>
</li>
<li class="calibre14">Peggy complies for each of the <i class="calibre12">n</i> new hard problems.
</li>

</ol>

<p class="calibre9">Unfortunately, it’s not that simple. This protocol does not have the same
zero-knowledge properties as the previous protocol. In step (4), Victor can
choose the challenges as a one-way hash of all the values committed to in the
second step, thus making the transcript nonsimulatable. It is still
zero-knowledge, but of a different sort. It seems to be secure in practice, but
no one knows how to prove it. We do know that in certain circumstances,
certain protocols for certain problems can be run in parallel while retaining
their zero-knowledge property [<a href="Applied%20Cryptography_split_035.html#r247" class="calibre5 pcalibre">247</a>,<a href="Applied%20Cryptography_split_035.html#r106" class="calibre5 pcalibre">106</a>,<a href="Applied%20Cryptography_split_035.html#r546" class="calibre5 pcalibre">546</a>,<a href="Applied%20Cryptography_split_035.html#r616" class="calibre5 pcalibre">616</a>].</p>

<h4 class="calibre8">Noninteractive Zero-Knowledge Proofs</h4>

<p class="calibre9">Carol can’t be convinced because the protocol is interactive, and she is not
involved in the interaction. To convince Carol, and anyone else who may be
interested, we need a noninteractive protocol.</p>

<p class="calibre9">Protocols have been invented for noninteractive zero-knowledge proofs
[<a href="Applied%20Cryptography_split_035.html#r477" class="calibre5 pcalibre">477</a>,<a href="Applied%20Cryptography_split_035.html#r198" class="calibre5 pcalibre">198</a>,<a href="Applied%20Cryptography_split_035.html#r478" class="calibre5 pcalibre">478</a>,<a href="Applied%20Cryptography_split_035.html#r197" class="calibre5 pcalibre">197</a>]. These protocols do not require any interaction; Peggy could
publish them and thereby prove to anyone who takes the time to check that the
proof is valid.</p>

<p class="calibre9">The basic protocol is similar to the parallel zero-knowledge proof, but a
one-way hash function takes the place of Victor:</p>

<ol class="calibre17">

<li class="calibre14">Peggy uses her information and <i class="calibre12">n</i> random numbers to transform the
hard problem into <i class="calibre12">n</i> different isomorphic problems. She then uses her
information and the random numbers to solve the <i class="calibre12">n</i> new hard problems.
</li>
<li class="calibre14">Peggy commits to the solution of the <i class="calibre12">n</i> new hard problems.
</li>
<li class="calibre14">Peggy uses all of these commitments together as a single input to a
one-way hash function. (After all, the commitments are nothing more
than bit strings.) She then saves the first <i class="calibre12">n</i> bits of the output of this
one-way hash function.
</li>
<li class="calibre14">Peggy takes the <i class="calibre12">n</i> bits generated in step (3). For each <i class="calibre12">i</i>th new hard problem in turn, she takes the <i class="calibre12">i</i>th bit of those <i class="calibre12">n</i> bits and:
<ol class="calibre43">
<li class="calibre14">if it is a 0, she proves that the old and new problems are
isomorphic, or</li>
<li class="calibre14">if it is a 1, she opens the solution she committed to in step (2)
and proves that it is a solution to the new problem.</li>
</ol>
</li>
<li class="calibre14">Peggy publishes all the commitments from step (2) as well as the
solutions in step (4).
</li>
<li class="calibre14">Victor or Carol or whoever else is interested, verifies that steps (1)
through (5) were executed properly.
</li>

</ol>

<p class="calibre9">This is amazing: Peggy can publish some data that contains no information
about her secret, but can be used to convince anyone of the secret’s existence.
The protocol can also be used for digital signature schemes, if the challenge is
set as a one-way hash of both the initial messages and the message to be signed.</p>

<p class="calibre9">This works because the one-way hash function acts as an unbiased random-bit
generator. For Peggy to cheat, she has to be able to predict the output of the
one-way hash function. (Remember, if she doesn’t know the solution to the hard
problem, she can do either (a) or (b) of step (4), but not both.) If she somehow
knew what the one-way hash function would ask her to do, then she could cheat.
However, there is no way for Peggy to force the one-way function to produce
certain bits or to guess which bits it will produce. The one-way function is, in
effect, Victor’s surrogate in the protocol — randomly choosing one of two proofs
in step (4).</p>

<p class="calibre9">In a noninteractive protocol, there must be many more iterations of the
challenge/reply sequence. Peggy, not Victor, picks the hard problems using
random numbers. She can pick different problems, hence different commitment
vectors, till the hash function produces something she likes. In an interactive
protocol, 10 iterations — a probability of 1 in 2<sup class="calibre19">10</sup> (1 in 1024) that Peggy can
cheat — may be fine. However, that’s not enough for noninteractive
zero-knowledge proofs. Remember that Mallory can always do either (a) or (b)
of step (4). He can try to guess which he will be asked to do, go through steps
(1) through (3), and see if he guessed right. If he didn’t, he can try
again — repeatedly. Making 1024 guesses is easy on a computer. To prevent this
brute-force attack, noninteractive protocols need 64 iterations, or even 128
iterations, to be valid.</p>

<p class="calibre9">This is the whole point of using a one-way hash function: Peggy cannot predict
the output of the hash function because she cannot predict its input. The
commitments which are used as the input are only known after she solves the
new problems.</p>

<h4 class="calibre8">Generalities</h4>

<p class="calibre9">Blum proved that any mathematical theorem can be converted into a graph such
that the proof of that theorem is equivalent to proving a Hamiltonian cycle in the
graph. The general case that any <b class="calibre10">NP</b> statement has a zero-knowledge proof,
assuming one-way functions and therefore good encryption algorithms, was
proved in [<a href="Applied%20Cryptography_split_035.html#r620" class="calibre5 pcalibre">620</a>]. Any mathematical proof can be converted into a
zero-knowledge proof. Using this technique, a researcher can prove to the world
that he knows the proof of a particular theorem without revealing what that
solution is. Blum could have published these results without revealing them.</p>

<p class="calibre9">There are also <b class="calibre10">minimum-disclosure proofs</b> [<a href="Applied%20Cryptography_split_035.html#r590" class="calibre5 pcalibre">590</a>]. In a minimum-disclosure
proof, the following properties hold:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Peggy cannot cheat Victor. If Peggy does not know the proof, her
chances of convincing Victor that she knows the proof are negligible.
</li>
<li class="pcalibre1 calibre30">Victor cannot cheat Peggy. He doesn’t get the slightest hint of the
proof, apart from the fact that Peggy knows the proof. In particular,
Victor cannot demonstrate the proof to anyone else without proving it
himself from scratch.
</li>

</ol>

<p class="calibre9">Zero-knowledge proofs have an additional condition:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Victor learns nothing from Peggy that he could not learn by himself
without Peggy, apart from the fact that Peggy knows the proof.
</li>

</ol>

<p class="calibre9">There is considerable mathematical difference between proofs that are only
minimum-disclosure and those that are zero-knowledge. That distinction is
beyond the scope of this book, but more sophisticated readers are welcome to
peruse the references. The concepts were introduced in [<a href="Applied%20Cryptography_split_035.html#r626" class="calibre5 pcalibre">626</a>,<a href="Applied%20Cryptography_split_035.html#r619" class="calibre5 pcalibre">619</a>,<a href="Applied%20Cryptography_split_035.html#r622" class="calibre5 pcalibre">622</a>]. Further
elaboration on their ideas, based on different mathematical assumptions, were
developed in [<a href="Applied%20Cryptography_split_035.html#r240" class="calibre5 pcalibre">240</a>,<a href="Applied%20Cryptography_split_035.html#r319" class="calibre5 pcalibre">319</a>,<a href="Applied%20Cryptography_split_035.html#r239" class="calibre5 pcalibre">239</a>].</p>

<p class="calibre9">There are also different kinds of zero-knowledge proofs:</p>

<ul class="calibre13">

<li class="calibre14"><b class="calibre10">Perfect</b>. There is a simulator that gives transcripts identically
distributed to real transcripts (the Hamiltonian cycle and graph
isomorphism examples).
</li>
<li class="calibre14"><b class="calibre10">Statistical</b>. There is a simulator that gives transcripts identically
distributed to real transcripts, except for some constant number of
exceptions.
</li>
<li class="calibre14"><b class="calibre10">Computational</b>. There is a simulator that gives transcripts
indistinguishable from real transcripts.
</li>
<li class="calibre14"><b class="calibre10">No-use</b>. A simulator may not exist, but we can prove that Victor will
not learn any polynomial amount of information from the proof (the
parallel example).
</li>

</ul>

<p class="calibre9">Over the years, extensive work, both theoretical and applied, has been done on
minimum-disclosure and zero-knowledge proofs. Mike Burmester and Yvo
Desmedt invented <b class="calibre10">broadcast interactive proofs</b>, where one prover can
broadcast a zero-knowledge interactive proof to a large group of verifiers [<a href="Applied%20Cryptography_split_035.html#r280" class="calibre5 pcalibre">280</a>].
Cryptographers proved that <i class="calibre12">everything</i> that can be proven with an interactive
proof can also be proven with a zero-knowledge interactive proof [<a href="Applied%20Cryptography_split_035.html#r753" class="calibre5 pcalibre">753</a>,<a href="Applied%20Cryptography_split_035.html#r137" class="calibre5 pcalibre">137</a>].</p>

<p class="calibre9">A good survey article on the topic is [<a href="Applied%20Cryptography_split_035.html#r548" class="calibre5 pcalibre">548</a>]. For additional mathematical details,
variations, protocols, and applications, consult
[<a href="Applied%20Cryptography_split_035.html#r590" class="calibre5 pcalibre">590</a>, <a href="Applied%20Cryptography_split_035.html#r619" class="calibre5 pcalibre">619</a>, <a href="Applied%20Cryptography_split_035.html#r240" class="calibre5 pcalibre">240</a>, <a href="Applied%20Cryptography_split_035.html#r319" class="calibre5 pcalibre">319</a>, <a href="Applied%20Cryptography_split_035.html#r620" class="calibre5 pcalibre">620</a>, <a href="Applied%20Cryptography_split_035.html#r113" class="calibre5 pcalibre">113</a>, <a href="Applied%20Cryptography_split_035.html#r241" class="calibre5 pcalibre">241</a>, <a href="Applied%20Cryptography_split_036.html#r1528" class="calibre5 pcalibre">1528</a>, <a href="Applied%20Cryptography_split_035.html#r660" class="calibre5 pcalibre">660</a>, <a href="Applied%20Cryptography_split_035.html#r238" class="calibre5 pcalibre">238</a>, <a href="Applied%20Cryptography_split_035.html#r591" class="calibre5 pcalibre">591</a>, <a href="Applied%20Cryptography_split_035.html#r617" class="calibre5 pcalibre">617</a>, <a href="Applied%20Cryptography_split_035.html#r510" class="calibre5 pcalibre">510</a>, <a href="Applied%20Cryptography_split_035.html#r592" class="calibre5 pcalibre">592</a>, <a href="Applied%20Cryptography_split_035.html#r214" class="calibre5 pcalibre">214</a>, <a href="Applied%20Cryptography_split_035.html#r104" class="calibre5 pcalibre">104</a>, <a href="Applied%20Cryptography_split_035.html#r216" class="calibre5 pcalibre">216</a>, <a href="Applied%20Cryptography_split_036.html#r832" class="calibre5 pcalibre">832</a>, <a href="Applied%20Cryptography_split_035.html#r97" class="calibre5 pcalibre">97</a>, <a href="Applied%20Cryptography_split_036.html#r939" class="calibre5 pcalibre">939</a>, <a href="Applied%20Cryptography_split_035.html#r622" class="calibre5 pcalibre">622</a>, <a href="Applied%20Cryptography_split_035.html#r482" class="calibre5 pcalibre">482</a>, <a href="Applied%20Cryptography_split_035.html#r615" class="calibre5 pcalibre">615</a>, <a href="Applied%20Cryptography_split_035.html#r618" class="calibre5 pcalibre">618</a>, <a href="Applied%20Cryptography_split_035.html#r215" class="calibre5 pcalibre">215</a>, <a href="Applied%20Cryptography_split_035.html#r476" class="calibre5 pcalibre">476</a>, <a href="Applied%20Cryptography_split_035.html#r71" class="calibre5 pcalibre">71</a>]. 
<i class="calibre12">A lot</i> has been written on this subject.</p>

<h3 id="5.2" class="calibre7">5.2 Zero-Knowledge Proofs of Identity</h3>

<p class="calibre9">In the real world, we often use physical tokens as proofs of identity: passports,
driver’s licenses, credit cards, and so on. The token contains something that
links it to a person: a picture, usually, or a signature, but it could almost as
easily be a thumbprint, a retinal scan, or a dental x-ray. Wouldn’t it be nice to do
the same thing digitally?</p>

<p class="calibre9">Using zero-knowledge proofs as proofs of identity was first proposed by Uriel
Feige, Amos Fiat, and Adi Shamir [<a href="Applied%20Cryptography_split_035.html#r566" class="calibre5 pcalibre">566</a>,<a href="Applied%20Cryptography_split_035.html#r567" class="calibre5 pcalibre">567</a>]. Alice’s private key becomes a
function of her “identity.” Using a zero-knowledge proof, she proves that she
knows her private key and therefore proves her identity. Algorithms for this can
be found in <a href="Applied%20Cryptography_split_026.html#23.11" class="calibre5 pcalibre">Section 23.11</a>.</p>

<p class="calibre9">This idea is quite powerful. It allows a person to prove his identity without any
physical token. However, it’s not perfect. Here are some abuses.</p>

<h4 class="calibre8">The Chess Grandmaster Problem</h4>

<p class="calibre9">Here’s how Alice, who doesn’t even know the rules to chess, can defeat a
grandmaster. (This is sometimes called the Chess Grandmaster Problem.) She
challenges both Gary Kasparov and Anatoly Karpov to a game, at the same
time and place, but in separate rooms. She plays white against Kasparov and
black against Karpov. Neither grandmaster knows about the other.</p>

<p class="calibre9">Karpov, as white, makes his first move. Alice records the move and walks into
the room with Kasparov. Playing white, she makes the same move against
Kasparov. Kasparov makes his first move as black. Alice records the move,
walks into the room with Karpov, and makes the same move. This continues,
until she wins one game and loses the other, or both games end in a draw.</p>

<p class="calibre9">In reality, Kasparov is playing Karpov and Alice is simply acting as the
middleman, mimicking the moves of each grandmaster on the other’s board.
However, if neither Karpov nor Kasparov knows about the other’s presence,
each will be impressed with Alice’s play.</p>

<p class="calibre9">This kind of fraud can be used against zero-knowledge proofs of identity
[<a href="Applied%20Cryptography_split_035.html#r485" class="calibre5 pcalibre">485</a>,<a href="Applied%20Cryptography_split_035.html#r120" class="calibre5 pcalibre">120</a>]. While Alice is proving her identity to Mallory, Mallory can
simultaneously prove to Bob that he is Alice.</p>

<h4 class="calibre8">The Mafia Fraud</h4>

<p class="calibre9">When discussing his zero-knowledge identification protocol, Adi Shamir
[<a href="Applied%20Cryptography_split_036.html#r1424" class="calibre5 pcalibre">1424</a>] said: “I could go to a Mafia-owned store a million successive times and
they will still not be able to misrepresent themselves as me.”</p>

<p class="calibre9">Here’s how the Mafia can. Alice is eating at Bob’s Diner, a Mafia-owned
restaurant. Carol is shopping at Dave’s Emporium, an expensive jewelry store.
Bob and Carol are both members of the Mafia and are communicating by a
secret radio link. Alice and Dave are unaware of the fraud.</p>

<p class="calibre9">At the end of Alice’s meal, when she is ready to pay and prove her identity to
Bob, Bob signals Carol that the fraud is ready to begin. Carol chooses some
expensive diamonds and gets ready to prove her identity to Dave. Now, as
Alice proves her identity to Bob, Bob radios Carol and Carol performs the
same protocol with Dave. When Dave asks a question in the protocol, Carol
radios the question back to Bob, and Bob asks it of Alice. When Alice
answers, Bob radios the correct answer to Carol. Actually, Alice is just
proving her identity to Dave, and Bob and Carol are simply sitting in the
middle of the protocol passing messages back and forth. When the protocol
finishes, Alice has proved herself to Dave and has purchased some expensive
diamonds (which Carol disappears with).</p>

<h4 class="calibre8">The Terrorist Fraud</h4>

<p class="calibre9">If Alice is willing to collaborate with Carol, they can also defraud Dave. In this
protocol, Carol is a well-known terrorist. Alice is helping her enter the
country. Dave is the immigration officer. Alice and Carol are connected by a
secret radio link.</p>

<p class="calibre9">When Dave asks Carol questions as part of the zero-knowledge protocol, Carol
radios them back to Alice, who answers them herself. Carol recites these
answers to Dave. In reality, Alice is proving her identity to Dave, with Carol
acting as a communications path. When the protocol finishes, Dave thinks that
Carol is Alice and lets her into the country. Three days later, Carol shows up at
some government building with a minivan full of explosives.</p>

<h4 class="calibre8">Suggested Solutions</h4>

<p class="calibre9">Both the Mafia and Terrorist frauds are possible because the conspirators can
communicate via a secret radio. One way to prevent this requires all
identifications to take place inside Faraday cages, which block all
electromagnetic radiation. In the terrorist example, this assures immigration
officer Dave that Carol was not receiving her answers from Alice. In the Mafia
example, Bob could simply build a faulty Faraday cage in his restaurant, but
jeweler Dave would have a working one; Bob and Carol would not be able to
communicate. To solve the Chess Grandmaster Problem, Alice should be
forced to sit in her seat until the end of a game.</p>

<p class="calibre9">Thomas Beth and Yvo Desmedt proposed another solution, one using accurate
clocks [<a href="Applied%20Cryptography_split_035.html#r148" class="calibre5 pcalibre">148</a>]. If each step in the protocol must take place at a given time, no
time would be available for the conspirators to communicate. In the Chess
Grandmaster Problem, if every move in each game must be made as a clock
strikes one minute, then Alice will have no time to run from room to room. In
the Mafia story, Bob and Carol will have no time to pass questions and
answers to one another.</p>

<h4 class="calibre8">The Multiple Identity Fraud</h4>

<p class="calibre9">There are other possible abuses to zero-knowledge proofs of identity, also
discussed in [<a href="Applied%20Cryptography_split_035.html#r485" class="calibre5 pcalibre">485</a>,<a href="Applied%20Cryptography_split_035.html#r120" class="calibre5 pcalibre">120</a>]. In some implementations, there is no check when an
individual registers a public key. Hence, Alice can have several private keys
and, therefore, several identities. This can be a great help if she wants to
commit tax fraud. Alice can also commit a crime and disappear. First, she
creates and publishes several identities. One of them she doesn’t use. Then,
she uses that identity once and commits a crime so that the person who
identifies her is the witness. Then, she immediately stops using that identity.
The witness knows the identity of the person who committed the crime, but if
Alice never uses that identity again — she’s untraceable.</p>

<p class="calibre9">To prevent this, there has to be some mechanism by which each person has
only one identity. In [<a href="Applied%20Cryptography_split_035.html#r120" class="calibre5 pcalibre">120</a>] the authors suggest the bizarre idea of tamperproof
babies who are impossible to clone and contain a unique number as part of
their genetic code. They also suggested having each baby apply for an identity
at birth. (Actually, the parents would have to do this as the baby would be
otherwise occupied.) This could easily be abused; parents could apply for
multiple identities at the child’s birth. In the end, the uniqueness of an
individual is based on trust.</p>

<h4 class="calibre8">Renting Passports</h4>

<p class="calibre9">Alice wants to travel to Zaire, but that government won’t give her a visa. Carol
offers to rent her identity to Alice. (Bob offered first, but there were some
obvious problems.) Carol sells Alice her private key and Alice goes off to
Zaire pretending to be Carol.</p>

<p class="calibre9">Carol has not only been paid for her identity, but now she has a perfect alibi.
She commits a crime while Alice is in Zaire. “Carol” has proved her identity in
Zaire; how could she commit a crime back home?</p>

<p class="calibre9">Of course, Alice is free to commit crimes as well. She does so either before
she leaves or after she returns, near Carol’s home. First she identifies herself as
Carol (she has Carol’s private key, so she can easily do that), then she commits
a crime and runs away. The police will come looking for Carol. Carol will
claim she rented her identity to Alice, but who would believe such a
nonsensical story?</p>

<p class="calibre9">The problem is that Alice isn’t really proving her identity; she is proving that
she knows a piece of secret information. It is the link between that information
and the person it belongs to that is being abused. The tamperproof baby
solution would protect against this type of fraud, as would a police state where
all citizens would have to prove their identity very frequently (at the end of
each day, at each street corner, etc.). Biometric methods — fingerprints, retinal
scanning, voiceprints, and so on — may help solve this problem.</p>

<h4 class="calibre8">Proofs of Membership</h4>

<p class="calibre9">Alice wants to prove to Bob that she is a member of some super-secret
organization, but she does not want to reveal her identity. This problem is
similar but different to proving identity, and has also been studied
[<a href="Applied%20Cryptography_split_036.html#r887" class="calibre5 pcalibre">887</a>,<a href="Applied%20Cryptography_split_036.html#r906" class="calibre5 pcalibre">906</a>,<a href="Applied%20Cryptography_split_036.html#r907" class="calibre5 pcalibre">907</a>,<a href="Applied%20Cryptography_split_036.html#r1201" class="calibre5 pcalibre">1201</a>,<a href="Applied%20Cryptography_split_036.html#r1445" class="calibre5 pcalibre">1445</a>]. Some solutions are related to the problem of group
signatures (see <a href="Applied%20Cryptography_split_005.html#4.6" class="calibre5 pcalibre">Section 4.6</a>).</p>

<h3 id="5.3" class="calibre7">5.3 Blind Signatures</h3>

<p class="calibre9">An essential feature of digital signature protocols is that the signer knows what
he is signing. This is a good idea, except when we want the reverse.</p>

<p class="calibre9">We might want people to sign documents without ever seeing their contents.
There are ways that a signer can <i class="calibre12">almost</i>, but not exactly, know what he is
signing. But first things first.</p>

<h4 class="calibre8">Completely Blind Signatures</h4>

<p class="calibre9">Bob is a notary public. Alice wants him to sign a document, but does not want
him to have any idea what he is signing. Bob doesn’t care what the document
says; he is just certifying that he notarized it at a certain time. He is willing to
go along with this.</p>

<ol class="calibre17">

<li class="calibre14">Alice takes the document and multiplies it by a random value. This
random value is called a <b class="calibre10">blinding factor</b>.
</li>
<li class="calibre14">Alice sends the blinded document to Bob.
</li>
<li class="calibre14">Bob signs the blinded document.
</li>
<li class="calibre14">Alice divides out the blinding factor, leaving the original document
signed by Bob.
</li>

</ol>

<p class="calibre9">This protocol only works if the signature function and multiplication are
commutative. If they are not, there are other ways to modify the document
other than by multiplying. Some relevant algorithms appear in <a href="Applied%20Cryptography_split_026.html#23.12" class="calibre5 pcalibre">Section 23.12</a>.
For now, assume that the operation is multiplication and all the math works.</p>

<p class="calibre9">Can Bob cheat? Can he collect any information about the document that he is
signing? If the blinding factor is truly random and makes the blinded document
truly random, he cannot. The blinded document Bob signs in step (2) looks
nothing like the document Alice began with. The blinded document with
Bob’s signature on it in step (3) looks nothing like the signed document at the
end of step (4). Even if Bob got his hands on the document, with his signature,
after completing the protocol, he cannot prove (to himself or to anyone else)
that he signed it in that particular protocol. He knows that his signature is
valid. He can, like anyone else, verify his signature. However, there is no way
for him to correlate any information he received during the signing protocol
with the signed document. If he signed a million documents using this
protocol, he would have no way of knowing in which instance he signed which
document.</p>

<p class="calibre9">The properties of completely blind signatures are:</p>

<ol class="calibre17">

<li class="calibre14">Bob’s signature on the document is valid. The signature is a proof
that Bob signed the document. It will convince Bob that he signed the
document if it is ever shown to him. It also has all of the other properties
of digital signatures discussed in <a href="Applied%20Cryptography_split_003.html#2.6" class="calibre5 pcalibre">Section 2.6</a>.
</li>
<li class="calibre14">Bob cannot correlate the signed document with the act of signing the
document. Even if he keeps records of every blind signature he makes,
he cannot determine when he signed any given document.
</li>

</ol>

<p class="calibre9">Eve, who is in the middle, watching this protocol, has even less information
than Bob.</p>

<h4 class="calibre8">Blind Signatures</h4>

<p class="calibre9">With the completely blind signature protocol, Alice can have Bob sign
anything: “Bob owes Alice a million dollars,” “Bob owes Alice his first-born
child,” “Bob owes Alice a bag of chocolates.” The possibilities are endless.
This protocol isn’t useful in many applications.</p>

<p class="calibre9">However, there is a way that Bob can know what he is signing, while still
maintaining the useful properties of a blind signature. The heart of this
protocol is the cut-and-choose technique. Consider this example. Many people
enter this country every day, and the Department of Immigration wants to
make sure they are not smuggling cocaine. The officials could search
everyone, but instead they use a probabilistic solution. They will search
one-tenth of the people coming in. One person in ten has his belongings
inspected; the other nine get through untouched. Chronic smugglers will get
away with their misdeeds most of the time, but they have a 10 percent chance
of getting caught. And if the court system is effective, the penalty for getting
caught once will more than wipe out the gains from the other nine times.</p>

<p class="calibre9">If the Department of Immigration wants to increase the odds of catching
smugglers, they have to search more people. If they want to decrease the odds,
they have to search fewer people. By manipulating the probabilities, they
control how successful the protocol is in catching smugglers.</p>

<p class="calibre9">The blind signature protocol works in a similar manner. Bob will be given a
large pile of different blinded documents. He will <b class="calibre10">open</b>, that is examine, all but one and then sign the last.</p>

<p class="calibre9">Think of the blinded document as being in an envelope. The process of
blinding the document is putting the document in an envelope and the process
of removing the blinding factor is opening the envelope. When the document
is in an envelope, nobody can read it. The document is signed by having a
piece of carbon paper in the envelope: When the signer signs the envelope, his
signature goes through the carbon paper and signs the document as well.</p>

<p class="calibre9">This scenario involves a group of counterintelligence agents. Their identities
are secret; not even the counterintelligence agency knows who they are. The
agency’s director wants to give each agent a signed document stating: “The
bearer of this signed document, (insert agent’s cover name here), has full
diplomatic immunity.” Each of the agents has his own list of cover names, so
the agency can’t just hand out signed documents. The agents do not want to
send their cover names to the agency; the enemy might have corrupted the
agency’s computer. On the other hand, the agency doesn’t want to blindly sign
any document an agent gives it. A clever agent might substitute a message
like: “Agent (name) has retired and collects a million-dollar-a-year pension.
Signed, Mr. President.” In this case, blind signatures could be useful.</p>

<p class="calibre9">Assume that all the agents have 10 possible cover names, which they have
chosen themselves and which no one else knows. Also assume that the agents
don’t care under which cover name they are going to get diplomatic immunity.
Also assume that the agency’s computer is the Agency’s Large Intelligent
Computing Engine, or ALICE, and that our particular agent is the Bogota
Operations Branch: BOB.</p>

<ol class="calibre17">

<li class="calibre14">BOB prepares <i class="calibre12">n</i> documents, each using a different cover name,
giving himself diplomatic immunity.
</li>
<li class="calibre14">BOB blinds each of these documents with a different blinding
factor.
</li>
<li class="calibre14">BOB sends the <i class="calibre12">n</i> blinded documents to ALICE.
</li>
<li class="calibre14">ALICE chooses <i class="calibre12">n</i> - 1 documents at random and asks BOB for the
blinding factors for each of those documents.
</li>
<li class="calibre14">BOB sends ALICE the appropriate blinding factors.
</li>
<li class="calibre14">ALICE opens (i.e., she removes the blinding factor) <i class="calibre12">n</i> - 1
documents and makes sure they are correct — and not pension
authorizations.
</li>
<li class="calibre14">ALICE signs the remaining document and sends it to BOB.
</li>
<li class="calibre14">Agent removes the blinding factor and reads his new cover name:
“The Crimson Streak.” The signed document gives him diplomatic
immunity under that name.
</li>

</ol>

<p class="calibre9">This protocol is secure against BOB cheating. For him to cheat, he would have
to predict accurately which document ALICE would not examine. The odds of
him doing this are 1 in <i class="calibre12">n</i> — not very good. ALICE knows this and feels
confident signing a document that she is not able to examine. With this one
document, the protocol is the same as the previous completely blinded
signature protocol and maintains all of its properties of anonymity.</p>

<p class="calibre9">There is a trick that makes BOB’s chance of cheating even smaller. In step (4),
ALICE randomly chooses <i class="calibre12">n</i>/2 of the documents to challenge, and BOB sends her
the appropriate blinding factors in step (5). In step (7), ALICE multiplies together
all of the unchallenged documents and signs the mega-document. In step (8),
BOB strips off all the blinding factors. ALICE’s signature is acceptable only if it
is a valid signature of the product of <i class="calibre12">n</i>/2 identical documents. To cheat BOB has to be able to guess exactly which subset ALICE will challenge; the odds are
much smaller than the odds of guessing which one document ALICE won’t
challenge.</p>

<p class="calibre9">BOB has another way to cheat. He can generate two different documents, one
that ALICE is willing to sign and one that ALICE is not. Then he can find two
different blinding factors that transform each document into the same blinded
document. That way, if ALICE asks to examine the document, BOB gives her the
blinding factor that transforms it into the benign document. If ALICE doesn’t ask
to see the document and signs it, he uses the blinding factor that transforms it into
the malevolent document. While this is theoretically possible, the mathematics of
the particular algorithms involved make the odds of BOB’s being able to find
such a pair negligibly small. In fact, it can be made as small as the odds of Bob
being able to produce the signature on an arbitrary message himself. This issue is
discussed further in <a href="Applied%20Cryptography_split_026.html#23.12" class="calibre5 pcalibre">Section 23.12</a>.</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">Chaum has patents for several flavors of blind signatures (see Table 5.1).</p>

<table class="data-table1" id="table-5-1">
<caption class="calibre23">TABLE 5.1 - Chaum’s Blind Signature Patents</caption>
<tbody class="calibre24"><tr class="calibre25"><th class="calibre26">U.S. PATENT #</th><th class="calibre26">DATE</th><th class="calibre26">TITLE</th></tr>
<tr class="calibre25"><td class="calibre27">4,759,063</td><td class="calibre27">7/19/88</td><td class="calibre27">Blind Signature Systems [<a href="Applied%20Cryptography_split_035.html#r323" class="calibre5 pcalibre">323</a>]</td></tr>
<tr class="calibre25"><td class="calibre27">4,759,064</td><td class="calibre27">7/19/88</td><td class="calibre27">Blind Unanticipated Signature Systems [<a href="Applied%20Cryptography_split_035.html#r324" class="calibre5 pcalibre">324</a>]</td></tr>
<tr class="calibre25"><td class="calibre27">4,914,698</td><td class="calibre27">3/3/90</td><td class="calibre27">One-Show Blind Signature Systems [<a href="Applied%20Cryptography_split_035.html#r326" class="calibre5 pcalibre">326</a>]</td></tr>
<tr class="calibre25"><td class="calibre27">4,949,380</td><td class="calibre27">8/14/90</td><td class="calibre27">Returned-Value Blind Signature Systems [<a href="Applied%20Cryptography_split_035.html#r328" class="calibre5 pcalibre">328</a>]</td></tr>
<tr class="calibre25"><td class="calibre28">4,991,210</td><td class="calibre28">2/5/91</td><td class="calibre28">Unpredictable Blind Signature Systems [<a href="Applied%20Cryptography_split_035.html#r331" class="calibre5 pcalibre">331</a>]</td></tr>
</tbody></table>

<h3 id="5.4" class="calibre7">5.4 Identity-Based Public-Key Cryptography</h3>

<p class="calibre9">Alice wants to send a secure message to Bob. She doesn’t want to get his public
key from a key server; she doesn’t want to verify some trusted third party’s
signature on his public-key certificate; and she doesn’t even want to store Bob’s
public key on her own computer. She just wants to send him a secure message.</p>

<p class="calibre9"><b class="calibre10">Identity-based cryptosystems</b>, sometimes called Non-Interactive Key Sharing
(NIKS) systems, solve this problem [<a href="Applied%20Cryptography_split_036.html#r1422" class="calibre5 pcalibre">1422</a>]. Bob’s public key is based on his
name and network address (or telephone number, or physical street address, or
whatever). With normal public-key cryptography, Alice needs a signed certificate
that associates Bob’s public key with his identity. With identity-based
cryptography, Bob’s public key <i class="calibre12">is</i> his identity. This is a really cool idea, and about as ideal as you can get for a mail system: If Alice knows Bob’s address, she
can send him secure mail. It makes the cryptography about as transparent as
possible.</p>

<p class="calibre9">The system is based on Trent issuing private keys to users based on their identity.
If Alice’s private key is compromised, she has to change some aspect of her
identity to get another one. A serious problem is designing a system in such a
way that a collusion of dishonest users cannot forge a key.</p>

<p class="calibre9">A lot of work has been done on the mathematics of these sorts of schemes — most
of it in Japan — which turn out to be infuriatingly complicated to make secure.
Many of the proposed solutions involve Trent choosing a random number for
each user — in my opinion this defeats the real point of the system. Some of the
algorithms discussed in <a href="Applied%20Cryptography_split_022.html#19" class="calibre5 pcalibre">Chapters 19</a> and <a href="Applied%20Cryptography_split_023.html#20" class="calibre5 pcalibre">20</a> can be identity-based. For details,
algorithms, and cryptanalysis, see
[<a href="Applied%20Cryptography_split_035.html#r191" class="calibre5 pcalibre">191</a>, <a href="Applied%20Cryptography_split_036.html#r1422" class="calibre5 pcalibre">1422</a>, <a href="Applied%20Cryptography_split_036.html#r891" class="calibre5 pcalibre">891</a>, <a href="Applied%20Cryptography_split_036.html#r1022" class="calibre5 pcalibre">1022</a>, <a href="Applied%20Cryptography_split_036.html#r1515" class="calibre5 pcalibre">1515</a>, <a href="Applied%20Cryptography_split_036.html#r1202" class="calibre5 pcalibre">1202</a>, <a href="Applied%20Cryptography_split_036.html#r1196" class="calibre5 pcalibre">1196</a>, <a href="Applied%20Cryptography_split_036.html#r908" class="calibre5 pcalibre">908</a>, <a href="Applied%20Cryptography_split_035.html#r692" class="calibre5 pcalibre">692</a>, <a href="Applied%20Cryptography_split_035.html#r674" class="calibre5 pcalibre">674</a>, <a href="Applied%20Cryptography_split_036.html#r1131" class="calibre5 pcalibre">1131</a>, <a href="Applied%20Cryptography_split_036.html#r1023" class="calibre5 pcalibre">1023</a>, <a href="Applied%20Cryptography_split_036.html#r1516" class="calibre5 pcalibre">1516</a>, <a href="Applied%20Cryptography_split_036.html#r1536" class="calibre5 pcalibre">1536</a>, <a href="Applied%20Cryptography_split_036.html#r1544" class="calibre5 pcalibre">1544</a>, <a href="Applied%20Cryptography_split_035.html#r63" class="calibre5 pcalibre">63</a>, <a href="Applied%20Cryptography_split_036.html#r1210" class="calibre5 pcalibre">1210</a>, <a href="Applied%20Cryptography_split_035.html#r314" class="calibre5 pcalibre">314</a>, <a href="Applied%20Cryptography_split_035.html#r313" class="calibre5 pcalibre">313</a>, <a href="Applied%20Cryptography_split_036.html#r1545" class="calibre5 pcalibre">1545</a>, <a href="Applied%20Cryptography_split_036.html#r1539" class="calibre5 pcalibre">1539</a>, <a href="Applied%20Cryptography_split_036.html#r1543" class="calibre5 pcalibre">1543</a>, <a href="Applied%20Cryptography_split_036.html#r933" class="calibre5 pcalibre">933</a>, <a href="Applied%20Cryptography_split_036.html#r1517" class="calibre5 pcalibre">1517</a>, <a href="Applied%20Cryptography_split_035.html#r748" class="calibre5 pcalibre">748</a>, <a href="Applied%20Cryptography_split_036.html#r1228" class="calibre5 pcalibre">1228</a>]. 
An algorithm that does not
rely on any random numbers is [<a href="Applied%20Cryptography_split_036.html#r1035" class="calibre5 pcalibre">1035</a>]. The system discussed in
[<a href="Applied%20Cryptography_split_036.html#r1546" class="calibre5 pcalibre">1546</a>,<a href="Applied%20Cryptography_split_036.html#r1547" class="calibre5 pcalibre">1547</a>,<a href="Applied%20Cryptography_split_036.html#r1507" class="calibre5 pcalibre">1507</a>] is insecure against a chosen-public-key attack; so is the system
proposed as NIKS-TAS [<a href="Applied%20Cryptography_split_036.html#r1542" class="calibre5 pcalibre">1542</a>,<a href="Applied%20Cryptography_split_036.html#r1540" class="calibre5 pcalibre">1540</a>,<a href="Applied%20Cryptography_split_036.html#r1541" class="calibre5 pcalibre">1541</a>,<a href="Applied%20Cryptography_split_036.html#r993" class="calibre5 pcalibre">993</a>,<a href="Applied%20Cryptography_split_035.html#r375" class="calibre5 pcalibre">375</a>,<a href="Applied%20Cryptography_split_036.html#r1538" class="calibre5 pcalibre">1538</a>]. Honestly, nothing
proposed so far is both practical and secure.</p>

<h3 id="5.5" class="calibre7">5.5 Oblivious Transfer</h3>

<p class="calibre9">Cryptographer Bob is desperately trying to factor a 500-bit number, <i class="calibre12">n</i>. He knows it’s the product of five 100-bit numbers, but nothing more. (This is a problem. If
he can’t recover the key he’ll have to work overtime and he’ll miss his weekly
mental poker game with Alice.)</p>

<p class="calibre9">What do you know? Here comes Alice now:</p>

<ul class="split1">

<li class="calibre35">“I happen to know one factor of the number,” she says, “and I’ll sell
it to you for $100. That’s a dollar a bit.” To show she’s serious, she
uses a bit-commitment scheme and commits to each bit individually.</li>

<li class="calibre35">Bob is interested, but has only $50. Alice is unwilling to lower her
price and offers to sell Bob half the bits for half the price. “It’ll save
you a considerable amount of work,” she says.</li>

<li class="calibre35">“But how do I know that your number is actually a factor of <i class="calibre12">n</i>? If
you show me the number and let me verify that it is a factor, then I
will agree to your terms,” says Bob.</li>

<li class="calibre35">They are at an impasse. Alice cannot convince Bob that her number
is a factor of <i class="calibre12">n</i> without revealing it, and Bob is unwilling to buy 50
bits of a number that could very well be worthless.</li>


</ul>

<p class="calibre9">This story, stolen from Joe Kilian [<a href="Applied%20Cryptography_split_036.html#r831" class="calibre5 pcalibre">831</a>], introduces the concept of <b class="calibre10">oblivious</b>
<b class="calibre10">transfer</b>. Alice transmits a group of messages to Bob. Bob receives some subset
of those messages, but Alice has no idea which ones he receives. This doesn’t
completely solve the problem, however. After Bob has received a random half of
the bits, Alice has to convince him that the bits she sent are part of a factor of <i class="calibre12">n</i>, using a zero-knowledge proof.</p>

<p class="calibre9">In the following protocol, Alice will send Bob one of two messages. Bob will
receive one, and Alice will not know which.</p>

<ol class="split">

<li class="pcalibre1 calibre30">Alice generates two public-key/private-key key pairs, or four keys in
all. She sends both public keys to Bob.
</li>
<li class="pcalibre1 calibre30">Bob chooses a key in a symmetric algorithm (DES, for example). He
chooses one of Alice’s public keys and encrypts his DES key with it. He
sends the encrypted key to Alice without telling her which of her public
keys he used to encrypt it.
</li>
<li class="pcalibre1 calibre30">Alice decrypts Bob’s key twice, once with each of her private keys. In
one of the cases, she uses the correct key and successfully decrypts Bob’s
DES key. In the other case, she uses the wrong key and only manages to
generate a meaningless pile of bits that nonetheless look like a random
DES key. Since she does not know the correct plaintext, she has no idea
which is which.
</li>
<li class="pcalibre1 calibre30">Alice encrypts both of her messages, each with a different one of the
DES keys she generated in the previous step (one real and one
meaningless) and sends both of them to Bob.
</li>
<li class="pcalibre1 calibre30">Bob gets one of Alice’s messages encrypted with the proper DES key
and the other one encrypted with the gibberish DES key. When Bob
decrypts each of them with his DES key, he can read one of them; the other
just looks like gibberish to him.
</li>

</ol>

<p class="calibre9">Bob now has one of the two messages from Alice and Alice does not know
which one he was able to read successfully. Unfortunately, if the protocol
stopped here it would be possible for Alice to cheat. Another step is necessary.</p>

<ol class="split1">

<li class="pcalibre1 calibre30">After the protocol is complete and both possible results of the
transfer are known, Alice must give Bob her private keys so that he can
verify that she did not cheat. After all, she could have encrypted the
same message with both keys in step (4).
</li>

</ol>

<p class="calibre9">At this point, of course, Bob can figure out the second message.</p>

<p class="calibre9">The protocol is secure against an attack by Alice because she has no way of
knowing which of the two DES keys is the real one. She encrypts them both,
but Bob only successfully recovers one of them — until step (6). It is secure
against an attack by Bob because, before step (6), he cannot get Alice’s private
keys to determine the DES key that the other message was encrypted in. This
may still seem like nothing more than a more complicated way to flip coins
over a modem, but it has extensive implications when used in more
complicated protocols.</p>

<p class="calibre9">Of course, nothing stops Alice from sending Bob two completely useless
messages: “Nyah Nyah” and “You sucker.” This protocol guarantees that
Alice sends Bob one of two messages; it does nothing to ensure that Bob
wants to receive either of them.</p>

<p class="calibre9">Other oblivious transfer protocols are found in the literature. Some of them are
noninteractive, meaning that Alice can publish her two messages and Bob can
learn only one of them. He can do this on his own; he doesn’t have to
communicate with Alice [<a href="Applied%20Cryptography_split_035.html#r105" class="calibre5 pcalibre">105</a>].</p>

<p class="calibre9">No one really cares about being able to do oblivious transfer in practice, but
the notion is an important building block for other protocols. Although there
are many types of oblivious transfer — I have two secrets and you get one; I
have <i class="calibre12">n</i> secrets and you get one; I have one secret which you get with
probability 1/2; and so on — they are all equivalent [<a href="Applied%20Cryptography_split_035.html#r245" class="calibre5 pcalibre">245</a>,<a href="Applied%20Cryptography_split_035.html#r391" class="calibre5 pcalibre">391</a>,<a href="Applied%20Cryptography_split_035.html#r395" class="calibre5 pcalibre">395</a>].</p>

<h3 id="5.6" class="calibre7">5.6 Oblivious Signatures</h3>

<p class="calibre9">Honestly, I can’t think of a good use for these, but there are two kinds [<a href="Applied%20Cryptography_split_035.html#r346" class="calibre5 pcalibre">346</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Alice has <i class="calibre12">n</i> different messages. Bob can choose one of the <i class="calibre12">n</i>
messages for Alice to sign, and Alice will have no way of knowing
which one she signed.
</li>
<li class="calibre14">Alice has one message. Bob can choose one of <i class="calibre12">n</i> keys for Alice to
use in signing the message, and Alice will have no way of knowing
which key she used.
</li>

</ol>

<p class="calibre9">It’s a neat idea; I’m sure it has a use somewhere.</p>

<h3 id="5.7" class="calibre7">5.7 Simultaneous Contract Signing</h3>

<h4 class="calibre8">Contract Signing with an Arbitrator</h4>

<p class="calibre9">Alice and Bob want to enter into a contract. They’ve agreed on the wording,
but neither wishes to sign unless the other signs as well. Face to face, this is
easy: Both sign together. Over a distance, they could use an arbitrator.</p>

<ol class="calibre17">

<li class="calibre14">Alice signs a copy of the contract and sends it to Trent.
</li>
<li class="calibre14">Bob signs a copy of the contract and sends it to Trent.
</li>
<li class="calibre14">Trent sends a message to both Alice and Bob indicating that the
other has signed the contract.
</li>
<li class="calibre14">Alice signs two copies of the contract and sends them to Bob.
</li>
<li class="calibre14">Bob signs both copies of the contract, keeps one for himself, and
sends the other to Alice.
</li>
<li class="calibre14">Alice and Bob both inform Trent that they each have a copy of the
contract signed by both of them.
</li>
<li class="calibre14">Trent tears up his two copies of the contract with only one signature
each.
</li>

</ol>

<p class="calibre9">This protocol works because Trent prevents either of the parties from cheating.
If Bob were to refuse to sign the contract in step (5), Alice could appeal to
Trent for a copy of the contract already signed by Bob. If Alice were to refuse
to sign in step (4), Bob could do the same. When Trent indicates that he
received both contracts in step (3), both Alice and Bob know that the other is
bound by the contract. If Trent does not receive both contracts in steps (1) and
(2), he tears up the one he received and neither party is bound.</p>

<h4 class="calibre8">Simultaneous Contract Signing without an Arbitrator (Face-to-Face)</h4>

<p class="calibre9">If Alice and Bob were sitting face-to-face, they could sign the contract this
way [<a href="Applied%20Cryptography_split_036.html#r1244" class="calibre5 pcalibre">1244</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Alice signs the first letter of her name and passes the contract to
Bob.
</li>
<li class="calibre14">Bob signs the first letter of his name and passes the contract to
Alice.
</li>
<li class="calibre14">Alice signs the second letter of her name and passes the contract to
Bob.
</li>
<li class="calibre14">Bob signs the second letter of his name and passes the contract to
Alice.
</li>
<li class="calibre14">This continues until both Alice and Bob have signed their entire
names.
</li>

</ol>

<p class="calibre9">If you ignore the obvious problem with this protocol (Alice has a longer name
than Bob), it works just fine. After signing only one letter, Alice knows that no
judge will bind her to the terms of the contract. But the letter is an act of good
faith, and Bob responds with a similar act of good faith.</p>
<p class="calibre9">
After each party has signed several letters, a judge could probably be
convinced that both parties had signed the contract. The details are murky,
though. Surely they are not bound after only the first letter; just as surely they
are bound after they sign their entire names. At what point in the protocol do
they become bound? After signing one-half of their names? Two-thirds of their
names? Three-quarters?</p>

<p class="calibre9">Since neither Alice nor Bob is certain of the exact point at which she or he is
bound, each has at least some fear that she or he is bound throughout the
protocol. At no point can Bob say: “You signed four letters and I only signed
three. You are bound but I am not.” Bob has no reason not to continue with the
protocol. Furthermore, the longer they continue, the greater the probability that
a judge will rule that they are bound. Again, there is no reason not to continue
with the protocol. After all, they both wanted to sign the contract; they just
didn’t want to sign before the other one.</p>

<h4 class="calibre8">Simultaneous Contract Signing without an Arbitrator (Not Face-to-Face)</h4>

<p class="calibre9">This protocol uses the same sort of uncertainty [<a href="Applied%20Cryptography_split_035.html#r138" class="calibre5 pcalibre">138</a>]. Alice and Bob alternate
taking baby steps toward signing until both have signed.</p>

<p class="calibre9">In the protocol, Alice and Bob exchange a series of signed messages of the
form: “I agree that with probability <i class="calibre12">p</i>, I am bound by this contract.”</p>

<p class="calibre9">The recipient of this message can take it to a judge and, with probability <i class="calibre12">p</i>, the judge will consider the contract to be signed.</p>

<ol class="calibre17">

<li class="calibre14">Alice and Bob agree on a date by which the signing protocol should
be completed.
</li>
<li class="calibre14">Alice and Bob decide on a probability difference that they are
willing to live with. For example, Alice might decide that she is not
willing to be bound with a greater probability than 2 percent over Bob’s
probability. Call Alice’s difference <i class="calibre12">a; </i> call Bob’s difference <i class="calibre12">b</i>.
</li>
<li class="calibre14">Alice sends Bob a signed message with <i class="calibre12">p</i> = <i class="calibre12">a</i>.
</li>
<li class="calibre14">Bob sends Alice a signed message with <i class="calibre12">p</i> = <i class="calibre12">a</i> + <i class="calibre12">b</i>.
</li>
<li class="calibre14">Let <i class="calibre12">p</i> be the probability of the message Alice received in the
previous step from Bob. Alice sends Bob a signed message with <i class="calibre12">p´</i> = <i class="calibre12">p</i>
+ <i class="calibre12">a</i> or 1, whichever is smaller.
</li>
<li class="calibre14">Let <i class="calibre12">p</i> be the probability of the message Bob received in the previous step from Alice. Bob sends Alice a signed message with <i class="calibre12">p´</i> = <i class="calibre12">p</i> + <i class="calibre12">b</i> or 1, whichever is smaller.
</li>
<li class="calibre14">Alice and Bob continue alternating steps (5) and (6) until both have
received messages with <i class="calibre12">p</i> = 1 or until the date agreed to in step (1) has
passed.
</li>

</ol>

<p class="calibre9">As the protocol proceeds, both Alice and Bob agree to be bound to the contract
with a greater and greater probability. For example, Alice might define her <i class="calibre12">a</i>
as 2 percent and Bob might define his <i class="calibre12">b</i> as 1 percent. (It would be nice if they had chosen larger increments; we will be here for a while.) Alice’s first
message might state that she is bound with 2 percent probability. Bob might
respond that he is bound with 3 percent probability. Alice’s next message
might state that she is bound with 5 percent probability and so on, until both
are bound with 100 percent probability.</p>

<p class="calibre9">If both Alice and Bob complete the protocol by the completion date, all is well.
Otherwise, either party can take the contract to the judge, along with the other
party’s last signed message. The judge then randomly chooses a value between
0 and 1 before seeing the contract. If the value is less than the probability the
other party signed, then both parties are bound. If the value is greater than the
probability, then both parties are not bound. (The judge then saves the value, in
case he has to rule on another matter regarding the same contract.) This is what
is meant by being bound to the contract with probability <i class="calibre12">p</i>.</p>

<p class="calibre9">That’s the basic protocol, but it can have more complications. The judge can
rule in the absence of one of the parties. The judge’s ruling either binds both or
neither party; in no situation is one party bound and the other one not.
Furthermore, as long as one party is willing to have a slightly higher
probability of being bound than the other (no matter how small), the protocol
will terminate.</p>

<h4 class="calibre8">Simultaneous Contract Signing without an Arbitrator (Using Cryptography)</h4>

<p class="calibre9">This cryptographic protocol uses the same baby-step approach [<a href="Applied%20Cryptography_split_035.html#r529" class="calibre5 pcalibre">529</a>]. DES is
used in the description, although any symmetric algorithm will do.</p>

<ol class="calibre17">

<li class="calibre14">Both Alice and Bob randomly select 2<i class="calibre12">n</i> DES keys, grouped in pairs.
The pairs are nothing special; they are just grouped that way for the
protocol.
</li>
<li class="calibre14">Both Alice and Bob generate <i class="calibre12">n</i> pairs of messages, <i class="calibre12">L</i><sub class="calibre15">i</sub> and <i class="calibre12">R</i><sub class="calibre15">i</sub>: “This is the left half of my <i class="calibre12">i</i>th signature” and “This is the right half of my <i class="calibre12">i</i>th signature,” for example. The identifier, <i class="calibre12">i</i>, runs from 1 to <i class="calibre12">n</i>. Each
message will probably also include a digital signature of the contract
and a timestamp. The contract is considered signed if the other party can
produce both halves, <i class="calibre12">L</i><sub class="calibre15">i</sub> and <i class="calibre12">R</i><sub class="calibre15">i</sub>, of a single signature pair.
</li>
<li class="calibre14">Both Alice and Bob encrypt their message pairs in each of the DES
key pairs, the left message with the left key in the pair and the right
message with the right key in the pair.
</li>
<li class="calibre14">Alice and Bob send each other their pile of 2<i class="calibre12">n</i> encrypted messages, making clear which messages are which halves of which pairs.
</li>
<li class="calibre14">Alice and Bob send each other every key pair using the oblivious
transfer protocol for each pair. That is, Alice sends Bob either the key
used to encrypt the left message or the key used to encrypt the right
message, independently, for each of the <i class="calibre12">n</i> pairs. Bob does the same.
They can either alternate sending halves or one can send 100 and then
the other — it doesn’t matter. Now both Alice and Bob have one key in
each key pair, but neither knows which halves the other one has.
</li>
<li class="calibre14">Both Alice and Bob decrypt the message halves that they can, using
the keys they received. They make sure that the decrypted messages are
valid.
</li>
<li class="calibre14">Alice and Bob send each other the first bits of all 2<i class="calibre12">n</i> DES keys.
</li>
<li class="calibre14">Alice and Bob repeat step (7) for the second bits of all 2<i class="calibre12">n</i> DES keys, the third bits, and so on, until all the bits of all the DES keys have been
transferred.
</li>
<li class="calibre14">Alice and Bob decrypt the remaining halves of the message pairs
and the contract is signed.
</li>
<li class="calibre14">Alice and Bob exchange the private keys used during the oblivious
transfer protocol in step (5) and each verifies that the other did not
cheat.
</li>

</ol>

<p class="calibre9">Why do Alice and Bob have to go through all this work? Let’s assume Alice
wants to cheat and see what happens. In steps (4) and (5), Alice could disrupt
the protocol by sending Bob nonsense bit strings. Bob would catch this in step
(6), when he tried to decrypt whatever half he received. Bob could then stop
safely, before Alice could decrypt any of Bob’s message pairs.</p>

<p class="calibre9">If Alice were very clever, she could only disrupt half the protocol. She could
send one half of each pair correctly, but send a gibberish string for the other
half. Bob has only a 50 percent chance of receiving the correct half, so half the
time Alice could cheat. However, this only works if there is one key pair. If
there were only two pairs, this sort of deception would succeed 25 percent of
the time. That is why <i class="calibre12">n</i> should be large. Alice has to guess correctly the
outcome of <i class="calibre12">n</i> oblivious transfer protocols; she has a 1 in 2<sup class="calibre19">n</sup> chance of doing
this. If <i class="calibre12">n</i> = 10, Alice has a 1 in 1024 chance of deceiving Bob.</p>

<p class="calibre9">Alice could also send Bob random bits in step (8). Perhaps Bob won’t know
that she is sending him random bits until he receives the whole key and tries to
decrypt the message halves. But again, Bob has probability on his side. He has
already received half of the keys, and Alice does not know which half. If <i class="calibre12">n</i> is large enough, Alice is sure to send him a nonsense bit to a key he has already
received and he will know immediately that she is trying to deceive him.</p>

<p class="calibre9">Maybe Alice will just go along with step (8) until she has enough bits of the
keys to mount a brute-force attack and then stop transmitting bits. DES has a
56-bit-long key. If she receives 40 of the 56 bits, she only has to try 2<sup class="calibre19">16</sup>, or
65,536, keys in order to read the message — a task certainly within the realm of
a computer’s capabilities. But Bob will have exactly the same number of bits
of her keys (or, at worst, one bit less), so he can do the same thing. Alice has
no real choice but to continue the protocol.</p>

<p class="calibre9">The basic point is that Alice has to play fairly, because the odds of fooling Bob
are just too small. At the end of the protocol, both parties have <i class="calibre12">n</i> signed
message pairs, any one of which is sufficient for a valid signature.</p>

<p class="calibre9">There is one way Alice can cheat; she can send Bob identical messages in Step
(5). Bob can’t detect this until after the protocol is finished, but he can use a
transcript of the protocol to convince a judge of Alice’s duplicity.</p>

<p class="calibre9">There are two weaknesses with protocols of this type [<a href="Applied%20Cryptography_split_035.html#r138" class="calibre5 pcalibre">138</a>]. First, it’s a
problem if one of the parties has significantly more computing power than the
other. If, for example, Alice can mount a brute-force attack faster than Bob
can, then she can stop sending bits early in step (8), and figure out Bob’s keys
herself. Bob, who cannot do the same in a reasonable amount of time, will not
be happy.</p>

<p class="calibre9">Second, it’s a problem if one of the parties stops the protocol early. If Alice
abruptly stops the protocol, both face similar computational efforts, but Bob
does not have any real legal recourse. If, for example, the contract specifies
that she do something in a week, and Alice terminates the protocol at a point
when Bob would have to spend a year’s worth of computing power before she
is really committed, that’s a problem. The real difficulty here is the lack of a
near-term deadline by which the process cleanly terminates with either both or
neither party bound.</p>

<p class="calibre9">These problems also apply to the protocols in <a href="#5.8" class="calibre5 pcalibre">Sections 5.8</a> and <a href="#5.9" class="calibre5 pcalibre">5.9</a>.</p>

<h3 id="5.8" class="calibre7">5.8 Digital Certified Mail</h3>

<p class="calibre9">The same simultaneous oblivious transfer protocol used for contract signing
works, with some modifications, for computer certified mail [<a href="Applied%20Cryptography_split_035.html#r529" class="calibre5 pcalibre">529</a>]. Suppose
Alice wants to send a message to Bob, but she does not want him to read it
without signing a receipt. Surly postal workers handle this process in real life,
but the same thing can be done with cryptography. Whitfield Diffie first
discussed this problem in [<a href="Applied%20Cryptography_split_035.html#r490" class="calibre5 pcalibre">490</a>].</p>

<p class="calibre9">At first glance, the simultaneous contract-signing protocol can do this. Alice
simply encrypts her message with a DES key. Her half of the protocol can be
something like: “This is the left half of the DES key: <code class="calibre18">32f5</code>,” and Bob’s half can
be something like: “This is the left half of my receipt.” Everything else stays
the same.</p>

<p class="calibre9">To see why this won’t work, remember that the protocol hinges on the fact that
the oblivious transfer in step (5) keeps both parties honest. Both of them know
that they sent the other party a valid half, but neither knows which. They don’t
cheat in step (8) because the odds of getting away with it are miniscule. If
Alice is sending Bob not a message but half of a DES key, Bob can’t check the
validity of the DES key in step (6). Alice can still check the validity of Bob’s
receipt, so Bob is still forced to be honest. Alice can freely send Bob some
garbage DES key, and he won’t know the difference until she has a valid
receipt. Tough luck, Bob.</p>

<p class="calibre9">Getting around this problem requires some adjustment of the protocol:</p>

<ol class="calibre17">

<li class="calibre14">Alice encrypts her message using a random DES key, and sends the
message to Bob.
</li>
<li class="calibre14">Alice generates <i class="calibre12">n</i> pairs of DES keys. The first key of each pair is generated at random; the second key of each pair is the XOR of the first
key and the message encryption key.
</li>
<li class="calibre14">Alice encrypts a dummy message with each of her 2<i class="calibre12">n</i> keys.
</li>
<li class="calibre14">Alice sends the whole pile of encrypted messages to Bob, making
sure he knows which messages are which halves of which pairs.
</li>
<li class="calibre14">Bob generates <i class="calibre12">n</i> pairs of random DES keys.
</li>
<li class="calibre14">Bob generates a pair of messages that indicates a valid receipt.
“This is the left half of my receipt” and “this is the right half of my
receipt” are good candidates, with the addition of some kind of
random-bit string. He makes <i class="calibre12">n</i> receipt pairs, each numbered. As with the
previous protocol, the receipt is considered valid if Alice can produce
both halves of a receipt (with the same number) and all of her
encryption keys.
</li>
<li class="calibre14">Bob encrypts each of his message pairs with DES key pairs, the <i class="calibre12">i</i> th message pair with the <i class="calibre12">i</i> th key pair, the left message with the left key in
the pair, and the right message with the right key in the pair.
</li>
<li class="calibre14">Bob sends his pile of message pairs to Alice, making sure that Alice
knows which messages are which halves of which pairs.
</li>
<li class="calibre14">Alice and Bob send each other every key pair using the oblivious
transfer protocol. That is, Alice sends Bob either the key used to encrypt
the left message or the key used to encrypt the right message, for each of
the <i class="calibre12">n</i> pairs. Bob does the same. They can either alternate sending halves
or one can send <i class="calibre12">n</i> and then the other — it doesn’t matter. Now both Alice
and Bob have one key in each key pair, but neither knows which halves
the other has.
</li>
<li class="calibre14">Both Alice and Bob decrypt the halves they can and make sure that
the decrypted messages are valid.
</li>
<li class="calibre14">Alice and Bob send each other the first bits of all 2<i class="calibre12">n</i> DES keys. (If they are worried about Eve being able to read these mail messages, then
they should encrypt their transmissions to each other.)
</li>
<li class="calibre14">Alice and Bob repeat step (11) for the second bits of all 2<i class="calibre12">n</i> DES
keys, the third bits, and so on, until all the bits of all the DES keys have
been transferred.
</li>
<li class="calibre14">Alice and Bob decrypt the remaining halves of the message pairs.
Alice has a valid receipt from Bob, and Bob can XOR any key pair to
get the original message encryption key.
</li>
<li class="calibre14">Alice and Bob exchange the private keys used during the oblivious
transfer protocol and each verifies that the other did not cheat.
</li>

</ol>

<p class="calibre9">Steps (5) through (8) for Bob, and steps (9) through (12) for both Alice and
Bob, are the same as the contract-signing protocol. The twist is all of Alice’s
dummy messages. They give Bob some way of checking the validity of her
oblivious transfer in step (10), which forces her to stay honest during steps
(11) through (13). And, as with the simultaneous contract-signing protocol,
both a left and a right half of one of Alice’s message pairs are required to
complete the protocol.</p>

<h3 id="5.9" class="calibre7">5.9 Simultaneous Exchange of Secrets</h3>

<p class="calibre9">Alice knows secret <i class="calibre12">A</i>; Bob knows secret <i class="calibre12">B</i>. Alice is willing to tell Bob <i class="calibre12">A</i>, if Bob tells her <i class="calibre12">B</i>. Bob is willing to tell Alice <i class="calibre12">B</i>, if Alice tells him <i class="calibre12">A</i>. This protocol, observed in a schoolyard, does not work:</p>

<ol class="calibre17">

<li class="calibre14">Alice: “I’ll tell if you tell me first.”
</li>
<li class="calibre14">Bob: “I’ll tell if you tell me first.”
</li>
<li class="calibre14">Alice: “No, you first.”
</li>
<li class="calibre14">Bob: “Oh, all right.” Bob whispers.
</li>
<li class="calibre14">Alice: “Ha! I won’t tell you.”
</li>
<li class="calibre14">Bob: “That’s not fair.”
</li>

</ol>

<p class="calibre9">Cryptography can make it fair. The previous two protocols are
implementations of this more general protocol, one that lets Alice and Bob
exchange secrets simultaneously [<a href="Applied%20Cryptography_split_035.html#r529" class="calibre5 pcalibre">529</a>]. Rather than repeat the whole protocol,
I’ll sketch the modifications to the certified mail protocol.</p>

<p class="calibre9">Alice performs steps (1) through (4) using <i class="calibre12">A</i> as the message. Bob goes through
similar steps using <i class="calibre12">B</i> as his message. Alice and Bob perform the oblivious
transfer in step (9), decrypt the halves they can in step (10), and go through the
iterations in steps (11) and (12). If they are concerned about Eve, they should
encrypt their messages. Finally, both Alice and Bob decrypt the remaining
halves of the message pairs and XOR any key pair to get the original message
encryption key.</p>

<p class="calibre9">This protocol allows Alice and Bob to exchange secrets simultaneously, but
says nothing about the quality of the secrets exchanged. Alice could promise
Bob the solution to the Minotaur’s labyrinth, but actually send him a map of
Boston’s subway system. Bob will get whatever secret Alice sends him. Other
protocols are [<a href="Applied%20Cryptography_split_036.html#r1286" class="calibre5 pcalibre">1286</a>, <a href="Applied%20Cryptography_split_035.html#r195" class="calibre5 pcalibre">195</a>, <a href="Applied%20Cryptography_split_036.html#r991" class="calibre5 pcalibre">991</a>, <a href="Applied%20Cryptography_split_036.html#r1524" class="calibre5 pcalibre">1524</a>, <a href="Applied%20Cryptography_split_035.html#r705" class="calibre5 pcalibre">705</a>, <a href="Applied%20Cryptography_split_035.html#r753" class="calibre5 pcalibre">753</a>, <a href="Applied%20Cryptography_split_035.html#r259" class="calibre5 pcalibre">259</a>, <a href="Applied%20Cryptography_split_035.html#r358" class="calibre5 pcalibre">358</a>, <a href="Applied%20Cryptography_split_035.html#r415" class="calibre5 pcalibre">415</a>].</p>

<div class="calibre6" id="calibre_pb_12"></div>
</div>






</body></html>
