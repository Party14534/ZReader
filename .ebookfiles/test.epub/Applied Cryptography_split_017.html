<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="14">Chapter 14 <br class="calibre3"/>
Still Other Block Ciphers</h1>

<h3 id="14.1" class="calibre7">14.1 GOST</h3>

<p class="calibre9">GOST is a block algorithm from the former Soviet Union [<a href="Applied%20Cryptography_split_035.html#r655" class="calibre5 pcalibre">655</a>,<a href="Applied%20Cryptography_split_036.html#r1393" class="calibre5 pcalibre">1393</a>]. “GOST”
is an acronym for “Gosudarstvennyi Standard,” or Government Standard, sort
of similar to a FIPS, except that it can (and does) refer to just about any kind of
standard. (Actually, the full name is Gosudarstvennyi Standard Soyuza SSR,
or Government Standard of the Union of Soviet Socialist Republics.) This
standard is number 28147-89. The Government Committee for Standards of
the USSR authorized the standard, whoever they were.</p>

<p class="calibre9">I don’t know whether GOST 28147-89 was used for classified traffic or just
for civilian encryption. A remark at its beginning states that the algorithm
“satisfies all cryptographic requirements and not limits the grade of
information to be protected.” I have heard claims that it was initially used for
very high-grade communications, including classified military
communications, but I have no confirmation.</p>

<h4 class="calibre8">Description of GOST</h4>

<p class="calibre9">GOST is a 64-bit block algorithm with a 256-bit key. GOST also has some
additional key material that will be discussed later. The algorithm iterates a
simple encryption algorithm for 32 rounds.</p>

<p class="calibre9">To encrypt, first break the text up into a left half, <i class="calibre12">L</i>. and a right half, <i class="calibre12">R</i>. The subkey for round <i class="calibre12">i</i> is <i class="calibre12">K</i><sub class="calibre15">i</sub>. A round, <i class="calibre12">i</i>, of GOST is:</p>

<p class="math-left"><i class="calibre12">L</i><sub class="calibre15">i</sub> = <i class="calibre12">R</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">R</i><sub class="calibre15">i</sub> = <i class="calibre12">L</i><sub class="calibre15">i - 1</sub> ⊕ f(<i class="calibre12">R</i><sub class="calibre15">i - 1</sub>, <i class="calibre12">K</i><sub class="calibre15">i</sub>)
</p>

<p class="calibre9">Figure 14.1 is a single round of GOST. Function f is straightforward. First, the
right half and the <i class="calibre12">i</i>th subkey are added modulo 2<sup class="calibre19">32</sup>. The result is broken into eight 4-bit chunks, and each chunk becomes the input to a different S-box.
There are eight different S-boxes in GOST; the first 4 bits go into the first
S-box, the second 4 bits go into the second S-box, and so on. Each S-box is a
permutation of the numbers 0 through 15. For example, an S-box might be:</p>

<pre class="calibre20">7, 10, 2, 4, 15, 9, 0, 3, 6, 12, 5, 13, 1, 8, 11
</pre>

<div class="figure" id="figure-14-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-14-1.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 14.1</b> One round of GOST.</i></p>
</div>

<p class="calibre9">In this case, if the input to the S-box is 0, the output is 7. If the input is 1, the
output is 10, and so on. All eight S-boxes are different; these are considered
additional key material. The S-boxes are to be kept secret.</p>

<p class="calibre9">The outputs of the eight S-boxes are recombined into a 32-bit word, then the
entire word undergoes an 11-bit left circular shift. Finally, the result XORed to
the left half to become the new right half, and the right half becomes the new
left half. Do this 32 times and you’re done.</p>

<p class="calibre9">The subkeys are generated simply. The 256-bit key is divided into eight 32-bit
blocks: <i class="calibre12">k</i><sub class="calibre15">1</sub>, <i class="calibre12">k</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">k</i><sub class="calibre15">8</sub>. Each round uses a different subkey, as shown in Table 14.1. Decryption is the same as encryption with the order of the <i class="calibre12">k</i><sub class="calibre15">i</sub>s reversed.</p>

<table class="data-table1" id="table-14-1">
<caption class="calibre67">Table 14.1 - Use of GOST Subkeys in Different Rounds</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="calibre89">Round:</td><td class="calibre69">1</td><td class="calibre69">2</td><td class="calibre69">3</td><td class="calibre69">4</td><td class="calibre69">5</td><td class="calibre69">6</td><td class="calibre69">7</td><td class="calibre69">8</td><td class="calibre69">9</td><td class="calibre69">10</td><td class="calibre69">11</td><td class="calibre69">12</td><td class="calibre69">13</td><td class="calibre69">14</td><td class="calibre69">15</td><td class="calibre69">16</td></tr>
<tr class="calibre25"><td class="calibre61">Subkey:</td><td class="calibre70">1</td><td class="calibre70">2</td><td class="calibre70">3</td><td class="calibre70">4</td><td class="calibre70">5</td><td class="calibre70">6</td><td class="calibre70">7</td><td class="calibre70">8</td><td class="calibre70">1</td><td class="calibre70">2</td><td class="calibre70">3</td><td class="calibre70">4</td><td class="calibre70">5</td><td class="calibre70">6</td><td class="calibre70">7</td><td class="calibre70">8</td></tr>
<tr class="calibre71"><td class="calibre78">Round:</td><td class="calibre72">17</td><td class="calibre72">18</td><td class="calibre72">19</td><td class="calibre72">20</td><td class="calibre72">21</td><td class="calibre72">22</td><td class="calibre72">23</td><td class="calibre72">24</td><td class="calibre72">25</td><td class="calibre72">26</td><td class="calibre72">27</td><td class="calibre72">28</td><td class="calibre72">29</td><td class="calibre72">30</td><td class="calibre72">31</td><td class="calibre72">32</td></tr>
<tr class="calibre25"><td class="calibre61">Subkey:</td><td class="calibre70">1</td><td class="calibre70">2</td><td class="calibre70">3</td><td class="calibre70">4</td><td class="calibre70">5</td><td class="calibre70">6</td><td class="calibre70">7</td><td class="calibre70">8</td><td class="calibre70">8</td><td class="calibre70">7</td><td class="calibre70">6</td><td class="calibre70">5</td><td class="calibre70">4</td><td class="calibre70">3</td><td class="calibre70">2</td><td class="calibre70">1</td></tr>
</tbody></table>

<p class="calibre39">The GOST standard does not discuss how to generate the S-boxes, only that
they are somehow supplied [<a href="Applied%20Cryptography_split_035.html#r655" class="calibre5 pcalibre">655</a>]. This has led to speculation that some Soviet
organization would supply good S-boxes to those organizations it liked and
bad S-boxes to those organizations it wished to eavesdrop on. This may very
well be true, but further conversations with a GOST chip manufacturer within
Russia offered another alternative. He generated the S-box permutations
himself, using a random-number generator.</p>

<p class="calibre9">More recently, a set of S-boxes used in an application for the Central Bank of
the Russian Federation surfaced. These S-boxes are also used in the
GOST one-way hash function (see <a href="Applied%20Cryptography_split_021.html#18.11" class="calibre5 pcalibre">Section 18.11</a>) [<a href="Applied%20Cryptography_split_035.html#r657" class="calibre5 pcalibre">657</a>].They are listed in Table
14.2.</p>

<table class="data-table1" id="table-14-2">
<caption class="calibre67">Table 14.2 - GOST S-Boxes</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="title3" colspan="16">S-box 1:</td></tr>
<tr class="calibre25"><td class="calibre70">4</td><td class="calibre70">10</td><td class="calibre70">9</td><td class="calibre70">2</td><td class="calibre70">13</td><td class="calibre70">8</td><td class="calibre70">0</td><td class="calibre70">14</td><td class="calibre70">6</td><td class="calibre70">11</td><td class="calibre70">1</td><td class="calibre70">12</td><td class="calibre70">7</td><td class="calibre70">15</td><td class="calibre70">5</td><td class="calibre70">3</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 2:</td></tr>
<tr class="calibre25"><td class="calibre70">14</td><td class="calibre70">11</td><td class="calibre70">4</td><td class="calibre70">12</td><td class="calibre70">6</td><td class="calibre70">13</td><td class="calibre70">15</td><td class="calibre70">10</td><td class="calibre70">2</td><td class="calibre70">3</td><td class="calibre70">8</td><td class="calibre70">1</td><td class="calibre70">0</td><td class="calibre70">7</td><td class="calibre70">5</td><td class="calibre70">9</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 3:</td></tr>
<tr class="calibre25"><td class="calibre70">5</td><td class="calibre70">8</td><td class="calibre70">1</td><td class="calibre70">13</td><td class="calibre70">10</td><td class="calibre70">3</td><td class="calibre70">4</td><td class="calibre70">2</td><td class="calibre70">14</td><td class="calibre70">15</td><td class="calibre70">12</td><td class="calibre70">7</td><td class="calibre70">6</td><td class="calibre70">0</td><td class="calibre70">9</td><td class="calibre70">11</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 4:</td></tr>
<tr class="calibre25"><td class="calibre70">7</td><td class="calibre70">13</td><td class="calibre70">10</td><td class="calibre70">1</td><td class="calibre70">0</td><td class="calibre70">8</td><td class="calibre70">9</td><td class="calibre70">15</td><td class="calibre70">14</td><td class="calibre70">4</td><td class="calibre70">6</td><td class="calibre70">12</td><td class="calibre70">11</td><td class="calibre70">2</td><td class="calibre70">5</td><td class="calibre70">3</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 5:</td></tr>
<tr class="calibre25"><td class="calibre70">6</td><td class="calibre70">12</td><td class="calibre70">7</td><td class="calibre70">1</td><td class="calibre70">5</td><td class="calibre70">15</td><td class="calibre70">13</td><td class="calibre70">8</td><td class="calibre70">4</td><td class="calibre70">10</td><td class="calibre70">9</td><td class="calibre70">14</td><td class="calibre70">0</td><td class="calibre70">3</td><td class="calibre70">11</td><td class="calibre70">2</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 6:</td></tr>
<tr class="calibre25"><td class="calibre70">4</td><td class="calibre70">11</td><td class="calibre70">10</td><td class="calibre70">0</td><td class="calibre70">7</td><td class="calibre70">2</td><td class="calibre70">1</td><td class="calibre70">13</td><td class="calibre70">3</td><td class="calibre70">6</td><td class="calibre70">8</td><td class="calibre70">5</td><td class="calibre70">9</td><td class="calibre70">12</td><td class="calibre70">15</td><td class="calibre70">14</td></tr>
<tr class="calibre25"><td class="title3" colspan="16">S-box 7:</td></tr>
<tr class="calibre25"><td class="calibre70">13</td><td class="calibre70">11</td><td class="calibre70">4</td><td class="calibre70">1</td><td class="calibre70">3</td><td class="calibre70">15</td><td class="calibre70">5</td><td class="calibre70">9</td><td class="calibre70">0</td><td class="calibre70">10</td><td class="calibre70">14</td><td class="calibre70">7</td><td class="calibre70">6</td><td class="calibre70">8</td><td class="calibre70">2</td><td class="calibre70">12</td></tr>
<tr class="calibre71"><td class="title4" colspan="16">S-box 8:</td></tr>
<tr class="calibre25"><td class="calibre70">1</td><td class="calibre70">15</td><td class="calibre70">13</td><td class="calibre70">0</td><td class="calibre70">5</td><td class="calibre70">7</td><td class="calibre70">10</td><td class="calibre70">4</td><td class="calibre70">9</td><td class="calibre70">2</td><td class="calibre70">3</td><td class="calibre70">14</td><td class="calibre70">6</td><td class="calibre70">11</td><td class="calibre70">8</td><td class="calibre70">12</td></tr>
</tbody></table>

<h4 class="calibre8">Cryptanalysis of GOST</h4>

<p class="calibre9">These are the major differences between DES and GOST.</p>

<ul class="calibre13">

<li class="calibre14">DES has a complicated procedure for generating the subkeys from
the keys. GOST has a very simple procedure.
</li>
<li class="calibre14">DES has a 56-bit key; GOST has a 256-bit key. If you add in the
secret S-box permutations, GOST has a total of about 610 bits of secret
information.
</li>
<li class="calibre14">The S-boxes in DES have 6-bit inputs and 4-bit outputs; the S-boxes
in GOST have 4-bit inputs and outputs. Both algorithms have eight
S-boxes, but an S-box in GOST is one-fourth the size of an S-box in
DES.
</li>
<li class="calibre14">DES has an irregular permutation, called a P-box; GOST uses an
11-bit left circular shift.
</li>
<li class="calibre14">DES has 16 rounds; GOST has 32 rounds.
</li>

</ul>

<p class="calibre9">If there is no better way to break GOST other than brute force, it is a very
secure algorithm. GOST has a 256-bit key — longer if you count the secret
S-boxes. Against differential and linear cryptanalysis, GOST is probably
stronger than DES. Although the random S-boxes in GOST are probably
weaker than the fixed S-boxes in DES, their secrecy adds to GOST’s
resistance against differential and linear attacks. Also, both of these attacks
depend on the number of rounds: the more rounds, the more difficult the
attack. GOST has twice as many rounds as DES; this alone probably makes
both differential and linear cryptanalysis infeasible.</p>

<p class="calibre9">The other parts of GOST are either on par or worse than DES. GOST doesn’t
have the same expansion permutation that DES has. Deleting this permutation
from DES weakens it by reducing the avalanche effect; it is reasonable to
believe that GOST is weaker for not having it. GOST’s use of addition instead
is no less secure than DES’s XOR.</p>

<p class="calibre9">The greatest difference between them seems to be GOST’s cyclic shift instead
of a permutation. The DES permutation increases the avalanche effect. In
GOST a change in one input bit affects one S-box in one round, which then
affects two S-boxes in the next round, three the round after that, and so on.
GOST requires 8 rounds before a single change in an input affects every
output bit; DES only requires 5 rounds. This is certainly a weakness. But
remember: GOST has 32 rounds to DES’s 16.</p>

<p class="calibre9">GOST’s designers tried to achieve a balance between efficiency and security.
They modified DES’s basic design to create an algorithm that is better suited
for software implementation. They seem to have been less sure of their
algorithm’s security, and have tried to compensate by making the key length
very large, keeping the S-boxes secret, and doubling the number of iterations.
Whether their efforts have resulted in an algorithm more secure than DES
remains to be seen.</p>

<h3 id="14.2" class="calibre7">14.2 CAST</h3>

<p class="calibre9">CAST was designed in Canada by Carlisle Adams and Stafford Tavares [<a href="Applied%20Cryptography_split_035.html#r10" class="calibre5 pcalibre">10</a>,<a href="Applied%20Cryptography_split_035.html#r7" class="calibre5 pcalibre">7</a>].
They claim that the name refers to their design procedure and should conjure
up images of randomness, but note the authors’ initials. The example CAST
algorithm uses a 64-bit block size and a 64-bit key.</p>

<p class="calibre9">The structure of CAST should be familiar. The algorithm uses six S-boxes
with an 8-bit input and a 32-bit output. Construction of these S-boxes is
implementation-dependent and complicated; see the references for details.</p>

<p class="calibre9">To encrypt, first divide the plaintext block into a left half and a right half. The
algorithm has 8 rounds. In each round the right half is combined with some
key material using function f and then XORed with the left half to form the
new right half. The original right half (before the round) becomes the new left
half. After 8 rounds (don’t switch the left and right halves after the eighth
round), the two halves are concatenated to form the ciphertext.</p>

<p class="calibre9">Function f is simple:</p>

<ol class="calibre17">

<li class="calibre14">Divide the 32-bit input into four 8-bit quarters: <i class="calibre12">a, b, c, d</i>.
</li>
<li class="calibre14">Divide the 16-bit subkey into two 8-bit halves: <i class="calibre12">e, f</i>.
</li>
<li class="calibre14">Process <i class="calibre12">a</i> through S-box 1, <i class="calibre12">b</i> through S-box 2, <i class="calibre12">c</i> through S-box 3, <i class="calibre12">d</i> through S-box 4, <i class="calibre12">e</i> through S-box 5, and <i class="calibre12">f</i> through S-box 6.
</li>
<li class="calibre14">XOR the six S-box outputs together to get the final 32-bit output.
</li>

</ol>

<p class="calibre9">Alternatively, the 32-bit input can be XORed with 32 bits of key, divided into
four 8-bit quarters, processed through the S-boxes, and then XORed together
[<a href="Applied%20Cryptography_split_035.html#r7" class="calibre5 pcalibre">7</a>]. <i class="calibre12">N</i> rounds of this appears to be as secure as <i class="calibre12">N</i> + 2 rounds of the other option.</p>

<p class="calibre9">The 16-bit subkey for each round is easily calculated from the 64-bit key. If <i class="calibre12">k</i><sub class="calibre15">1</sub>, <i class="calibre12">k</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">k</i><sub class="calibre15">8</sub> are the 8 bytes of the key, then the subkeys for each round are:</p>

<p class="math-left">Round 1: <i class="calibre12">k</i><sub class="calibre15">1</sub>, <i class="calibre12">k</i><sub class="calibre15">2</sub>
Round 2: <i class="calibre12">k</i><sub class="calibre15">3</sub>, <i class="calibre12">k</i><sub class="calibre15">4</sub>
Round 3: <i class="calibre12">k</i><sub class="calibre15">5</sub>, <i class="calibre12">k</i><sub class="calibre15">6</sub>
Round 4: <i class="calibre12">k</i><sub class="calibre15">7</sub>, <i class="calibre12">k</i><sub class="calibre15">8</sub>
Round 5: <i class="calibre12">k</i><sub class="calibre15">4</sub>, <i class="calibre12">k</i><sub class="calibre15">3</sub>
Round 6: <i class="calibre12">k</i><sub class="calibre15">2</sub>, <i class="calibre12">k</i><sub class="calibre15">1</sub>
Round 7: <i class="calibre12">k</i><sub class="calibre15">8</sub>, <i class="calibre12">k</i><sub class="calibre15">7</sub>
Round 8: <i class="calibre12">k</i><sub class="calibre15">6</sub>, <i class="calibre12">k</i><sub class="calibre15">5</sub>
</p>

<p class="calibre9">The strength of this algorithm lies in its S-boxes. CAST does not have fixed
S-boxes; new ones are constructed for each application. Design criteria are in
[<a href="Applied%20Cryptography_split_035.html#r10" class="calibre5 pcalibre">10</a>]; bent functions are the S-box columns, selected for a number of desirable
S-box properties (see <a href="#14.10" class="calibre5 pcalibre">Section 14.10</a>). Once a set of S-boxes has been
constructed for a given implementation of CAST, they are fixed for all time.
The S-boxes are implementation-dependent, but not key-dependent.</p>

<p class="calibre9">It was shown in [<a href="Applied%20Cryptography_split_035.html#r10" class="calibre5 pcalibre">10</a>] that CAST is resistant to differential cryptanalysis and in
[<a href="Applied%20Cryptography_split_035.html#r728" class="calibre5 pcalibre">728</a>] that CAST is resistant to linear cryptanalysis. There is no known way to
break CAST other than brute force.</p>

<p class="calibre9">Northern Telecom is using CAST in their Entrust security software package
for Macintoshes, PCs, and UNIX workstations. The particular S-boxes they
chose are not public. The Canadian government is evaluating CAST as a new
encryption standard. CAST is patent-pending.</p>

<h3 id="14.3" class="calibre7">14.3 Blowfish</h3>

<p class="calibre9">Blowfish is an algorithm of my own design, intended for implementation on
large microprocessors [<a href="Applied%20Cryptography_split_036.html#r1388" class="calibre5 pcalibre">1388</a>,<a href="Applied%20Cryptography_split_036.html#r1389" class="calibre5 pcalibre">1389</a>]. The algorithm is unpatented, and the C
code in the back of this book is in the public domain. I designed Blowfish to
meet the following design criteria.</p>

<ol class="calibre17">

<li class="calibre14">Fast. Blowfish encrypts data on 32-bit microprocessors at a rate of 26
clock cycles per byte.
</li>
<li class="calibre14">Compact. Blowfish can run in less than 5K of memory.
</li>
<li class="calibre14">Simple. Blowfish uses only simple operations: addition, XORs, and
table lookups on 32-bit operands. Its design is easy to analyze which
makes it resistant to implementation errors [<a href="Applied%20Cryptography_split_036.html#r1391" class="calibre5 pcalibre">1391</a>].
</li>
<li class="calibre14">Variably Secure. Blowfish’s key length is variable and can be as long
as 448 bits.
</li>

</ol>

<p class="calibre9">Blowfish is optimized for applications where the key does not change often,
like a communications link or an automatic file encryptor. It is significantly
faster than DES when implemented on 32-bit microprocessors with large data
caches, such as the Pentium and the PowerPC. Blowfish is not suitable for
applications, such as packet switching, with frequent key changes, or as a
one-way hash function. Its large memory requirement makes it infeasible for
smart card applications.</p>

<h4 class="calibre8">Description of Blowfish</h4>

<p class="calibre9">Blowfish is a 64-bit block cipher with a variable-length key. The algorithm
consists of two parts: key expansion and data encryption. Key expansion
converts a key of up to 448 bits into several subkey arrays totaling 4168 bytes.</p>

<p class="calibre9">Data encryption consists of a simple function iterated 16 times (see Figure 14.2). Each round
consists of a key-dependent permutation, and a key- and data-dependent
substitution. All operations are additions and XORs on 32-bit words. The only
additional operations are four indexed array data lookups per round.</p>

<p class="calibre9">Blowfish uses a large number of subkeys. These keys must be precomputed
before any data encryption or decryption.</p>

<p class="calibre9">The P-array consists of 18 32-bit subkeys:</p>

<p class="math"><i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">P</i><sub class="calibre15">2</sub>,..., <i class="calibre12">P</i><sub class="calibre15">18</sub>
</p>

<p class="calibre9">Four 32-bit S-boxes have 256 entries each:</p>

<p class="math"><i class="calibre12">S</i><sub class="calibre15">1,0</sub>, <i class="calibre12">S</i><sub class="calibre15">1,1</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">1,255</sub>
<i class="calibre12">S</i><sub class="calibre15">2,0</sub>, <i class="calibre12">S</i><sub class="calibre15">2,1</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">2,255</sub>
<i class="calibre12">S</i><sub class="calibre15">3,0</sub>, <i class="calibre12">S</i><sub class="calibre15">3,1</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">3,255</sub>
<i class="calibre12">S</i><sub class="calibre15">4,0</sub>, <i class="calibre12">S</i><sub class="calibre15">4,1</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">4,255</sub>
</p>

<p class="calibre9">The exact method used to calculate these subkeys will be described later in this
section.</p>

<div class="figure" id="figure-14-2">
<div class="image1">
<p class="calibre9"><img src="ac-figure-14-2.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 14.2</b> Blowfish.</i></p>
</div>

<p class="calibre9">Blowfish is a Feistel network (see <a href="#14.10" class="calibre5 pcalibre">Section 14.10</a>) consisting of 16 rounds. The
input is a 64-bit data element, <i class="calibre12">x</i>. To encrypt:</p>

<p class="math-left">Divide <i class="calibre12">x</i> into two 32-bit halves: <i class="calibre12">x</i><sub class="calibre15">L</sub>, <i class="calibre12">x</i><sub class="calibre15">R</sub>
For <i class="calibre12">i</i> = 1 to 16:
    <i class="calibre12">x</i><sub class="calibre15">L</sub> = <i class="calibre12">x</i><sub class="calibre15">L</sub> ⊕ <i class="calibre12">P</i><sub class="calibre15">i</sub>
    <i class="calibre12">x</i><sub class="calibre15">R</sub> = F(<i class="calibre12">x</i><sub class="calibre15">L</sub>) ⊕ <i class="calibre12">x</i><sub class="calibre15">R</sub>
Swap <i class="calibre12">x</i><sub class="calibre15">L</sub> and <i class="calibre12">x</i><sub class="calibre15">R</sub>
Swap <i class="calibre12">x</i><sub class="calibre15">L</sub> and <i class="calibre12">x</i><sub class="calibre15">R</sub> (Undo the last swap.)
<i class="calibre12">x</i><sub class="calibre15">R</sub> = <i class="calibre12">x</i><sub class="calibre15">R</sub> ⊕ <i class="calibre12">P</i><sub class="calibre15">17</sub>
<i class="calibre12">x</i><sub class="calibre15">L</sub> = <i class="calibre12">x</i><sub class="calibre15">L</sub> ⊕ <i class="calibre12">P</i><sub class="calibre15">18</sub>
Recombine <i class="calibre12">x</i><sub class="calibre15">L</sub> and <i class="calibre12">x</i><sub class="calibre15">R</sub>

</p>

<div class="figure" id="figure-14-3">
<div class="image1">
<p class="calibre9"><img src="ac-figure-14-3.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 14.3</b> Function F.</i></p>
</div>

<p class="calibre9">Function F is as follows (see Figure 14.3):</p>

<p class="math-left">Divide <i class="calibre12">x</i><sub class="calibre15">L</sub> into four eight-bit quarters: <i class="calibre12">a, b, c</i>, and <i class="calibre12">d</i>
F(<i class="calibre12">x</i><sub class="calibre15">L</sub>) = ((<i class="calibre12">S</i><sub class="calibre15">1,<i class="calibre22">a</i></sub> + <i class="calibre12">S</i><sub class="calibre15">2,<i class="calibre22">b</i></sub> mod 2<sup class="calibre19">32</sup>) ⊕ <i class="calibre12">S</i><sub class="calibre15">3, <i class="calibre22">c</i></sub>) + <i class="calibre12">S</i><sub class="calibre15">4,d</sub> mod 2<sup class="calibre19">32</sup>
</p>

<p class="calibre9">Decryption is exactly the same as encryption, except that <i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">P</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">P</i><sub class="calibre15">18</sub> are used in the reverse order.
Implementations of Blowfish that require the fastest speeds should unroll the
loop and ensure that all subkeys are stored in cache. See [<a href="Applied%20Cryptography_split_035.html#r568" class="calibre5 pcalibre">568</a>] for details.</p>

<p class="calibre9">The subkeys are calculated using the Blowfish algorithm. The exact method
follows.</p>

<ol class="calibre17">

<li class="calibre14">Initialize first the P-array and then the four S-boxes, in order, with a
fixed string. This string consists of the hexadecimal digits of p.
</li>
<li class="calibre14">XOR <i class="calibre12">P</i><sub class="calibre15">1</sub> with the first 32 bits of the key, XOR <i class="calibre12">P</i><sub class="calibre15">2</sub> with the second 32-bits of the key, and so on for all bits of the key (up to <i class="calibre12">P</i><sub class="calibre15">18</sub>).
Repeatedly cycle through the key bits until the entire P-array has been
XORed with key bits.
</li>
<li class="calibre14">Encrypt the all-zero string with the Blowfish algorithm, using the
subkeys described in steps (1) and (2).
</li>
<li class="calibre14">Replace <i class="calibre12">P</i><sub class="calibre15">1</sub> and <i class="calibre12">P</i><sub class="calibre15">2</sub> with the output of step (3).
</li>
<li class="calibre14">Encrypt the output of step (3) using the Blowfish algorithm with the
modified subkeys.
</li>
<li class="calibre14">Replace <i class="calibre12">P</i><sub class="calibre15">3</sub> and <i class="calibre12">P</i><sub class="calibre15">4</sub> with the output of step (5).
</li>
<li class="calibre14">Continue the process, replacing all elements of the P-array, and then
all four S-boxes in order, with the output of the continuously changing
Blowfish algorithm.
</li>

</ol>

<p class="calibre9">In total, 521 iterations are required to generate all required subkeys.
Applications can store the subkeys — there’s no need to execute this derivation
process multiple times.</p>

<h4 class="calibre8">Security of Blowfish</h4>

<p class="calibre9">Serge Vaudenay examined Blowfish with known S-boxes and <i class="calibre12">r</i> rounds; a
differential attack can recover the P-array with 2<sup class="calibre19">8<i class="calibre22">r</i> + 1</sup> chosen plaintexts [<a href="Applied%20Cryptography_split_036.html#r1568" class="calibre5 pcalibre">1568</a>].
For certain weak keys that generate bad S-boxes (the odds of getting them
randomly are 1 in 2<sup class="calibre19">14</sup>), the same attack requires only 2<sup class="calibre19">4<i class="calibre22">r</i> + 1</sup> chosen plaintexts to recover the P-array. With unknown S-boxes this attack can detect whether a
weak key is being used, but cannot determine what it is (neither the S-boxes
nor the P-array). This attack only works against reduced-round variants; it is
completely ineffective against 16-round Blowfish.</p>

<p class="calibre9">Of course, the discovery of weak keys is significant, even though they seem
impossible to exploit. A weak key is one in which two entries for a given
S-box are identical. There is no way to check for weak keys before doing the
key expansion. If you are worried, you have to do the key expansion and check
for identical S-box entries. I don’t think this is necessary, though.</p>

<p class="calibre9">I know of no successful cryptanalysis against Blowfish. To be safe, do not
implement Blowfish with a reduced number of rounds.</p>

<p class="calibre9">Kent Marsh Ltd. has incorporated Blowfish in their FolderBolt security
product for Microsoft Windows and Macintosh. It is also part of Nautilus and
PGPfone.</p>

<h3 id="14.4" class="calibre7">14.4 SAFER</h3>

<p class="calibre9">SAFER K-64 stands for Secure And Fast Encryption Routine with a Key of 64
bits [<a href="Applied%20Cryptography_split_036.html#r1009" class="calibre5 pcalibre">1009</a>]. James Massey produced this nonproprietary algorithm for Cylink
Corp. and it is incorporated into some of their products. The government of
Singapore is planning to use this algorithm — with a 128-bit key [<a href="Applied%20Cryptography_split_036.html#r1010" class="calibre5 pcalibre">1010</a>] — for a
wide variety of applications. There are no patent, copyright, or other
restrictions on its use.</p>

<p class="calibre9">The algorithm has a block and key size of 64 bits. It is not a Feistel network
like DES (see <a href="#14.10" class="calibre5 pcalibre">Section 14.10</a>), but an iterated block cipher: The same function
is applied for some number of rounds. Each round uses two 64-bit subkeys,
and the algorithm only uses operations on bytes.</p>

<h4 class="calibre8">Description of SAFER K-64</h4>

<p class="calibre9">The plaintext block is divided into eight byte-length sub-blocks: <i class="calibre12">B</i><sub class="calibre15">1</sub>, <i class="calibre12">B</i><sub class="calibre15">2</sub>,..., <i class="calibre12">B</i><sub class="calibre15">7</sub>, <i class="calibre12">B</i><sub class="calibre15">8</sub>. Then the sub-blocks go through <i class="calibre12">r</i> rounds. Finally, an output transformation is applied to the sub-blocks. Each round uses two subkeys: <i class="calibre12">K</i><sub class="calibre15">2i - 1</sub> and <i class="calibre12">K</i><sub class="calibre15">2i</sub>.</p>

<p class="calibre9">Figure 14.4 shows one round of SAFER K-64. First, sub-blocks are either
XORed or added with bytes of subkey <i class="calibre12">K</i><sub class="calibre15">2i - 1</sub>. Then, the eight sub-blocks are
subjected to one of two nonlinear transformations:</p>

<p class="math-left"><i class="calibre12">y</i> = 45<sup class="calibre19">x</sup> mod 257. (If <i class="calibre12">x</i> = 128, then <i class="calibre12">y</i> = 0.)
<i class="calibre12">y</i> = log<sub class="calibre15">45</sub> <i class="calibre12">x</i>. (If <i class="calibre12">x</i> = 0, then <i class="calibre12">y</i> = 128.)
</p>

<p class="calibre9">These are operations in the finite field GF(257), and 45 is a primitive element
in that field. In practical implementations of SAFER K-64, it is quicker to
implement this in a lookup table than to calculate new results all the time.</p>

<div class="figure" id="figure-14-4">
<div class="image1">
<p class="calibre9"><img src="ac-figure-14-4.jpg" class="calibre11"/></p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 14.4</b> One round of SAFER.</i></p>
</div>
</div>

<p class="calibre9">Then, sub-blocks are either XORed or added with bytes of subkey <i class="calibre12">K</i><sub class="calibre15">2r</sub>. The
results of this operation are fed through three layers of linear operations
designed to increase the avalanche effect. Each operation is called a
Pseudo-Hadamard Transform (PHT). If the inputs to a PHT are <i class="calibre12">a</i><sub class="calibre15">1</sub> and <i class="calibre12">a</i><sub class="calibre15">2</sub>, then the outputs are:</p>

<p class="math-left"><i class="calibre12">b</i><sub class="calibre15">1</sub> = (2<i class="calibre12">a</i><sub class="calibre15">1</sub> + <i class="calibre12">a</i><sub class="calibre15">2</sub>) mod 256
<i class="calibre12">b</i><sub class="calibre15">2</sub> = (<i class="calibre12">a</i><sub class="calibre15">1</sub> + <i class="calibre12">a</i><sub class="calibre15">2</sub>) mod 256
</p>

<p class="calibre9">After <i class="calibre12">r</i> rounds, there is a final output transformation. This is the same as the first step of each round. <i class="calibre12">B</i><sub class="calibre15">1</sub>, <i class="calibre12">B</i><sub class="calibre15">4</sub>, <i class="calibre12">B</i><sub class="calibre15">5</sub>, and <i class="calibre12">B</i><sub class="calibre15">8</sub> are XORed with the corresponding bytes of the last subkey, and <i class="calibre12">B</i><sub class="calibre15">2</sub>, <i class="calibre12">B</i><sub class="calibre15">3</sub>, <i class="calibre12">B</i><sub class="calibre15">6</sub>, and <i class="calibre12">B</i><sub class="calibre15">7</sub> are added to the corresponding bytes of the last subkey. The result is the ciphertext.</p>

<p class="calibre9">Decryption is the reverse process: the output transformation (with subtraction
instead of addition), then <i class="calibre12">r</i> reverse rounds. The Inverse PHT (IPHT) is:</p>

<p class="math"><i class="calibre12">a</i><sub class="calibre15">1</sub> = (<i class="calibre12">b</i><sub class="calibre15">1</sub> - <i class="calibre12">b</i><sub class="calibre15">2</sub>) mod 256
<i class="calibre12">a</i><sub class="calibre15">2</sub> = (-<i class="calibre12">b</i><sub class="calibre15">1</sub> + 2<i class="calibre12">b</i><sub class="calibre15">2</sub>) mod 256
</p>

<p class="calibre9">Massey recommends 6 rounds, but you can increase that if you want greater
security.</p>

<p class="calibre9">Generating subkeys is easy. The first subkey, <i class="calibre12">K</i><sub class="calibre15">1</sub>, is simply the user key.
Subsequent subkeys are generated by the following procedure:</p>

<p class="math"><i class="calibre12">K</i><sub class="calibre15">i+1</sub> = (<i class="calibre12">K</i><sub class="calibre15">1</sub> &lt;&lt;&lt; 3<i class="calibre12">i</i>) + <i class="calibre12">c</i><sub class="calibre15">i</sub>
</p>

<p class="calibre9">The symbol “&lt;&lt;&lt;” is a left circular shift or a left rotation. The rotation is byte by byte, and <i class="calibre12">c</i><sub class="calibre15">i</sub> is a round constant. If <i class="calibre12">c</i><sub class="calibre15">ij</sub> is the <i class="calibre12">j</i>th byte of the <i class="calibre12">i</i>th round constant, then you can calculate all of the round constants by the formula</p>

<p class="math"><i class="calibre12">c</i><sub class="calibre15">ij</sub> = 45<sup class="calibre19">45<sup class="calibre66">(9<i class="calibre22">i + j</i>) mod 256</sup> mod 257</sup> mod 257
</p>

<p class="calibre9">Generally, these values are stored in a table.</p>

<h4 class="calibre8">SAFER K-128</h4>

<p class="calibre9">This alternate key schedule was developed by the Ministry of Home Affairs in
Singapore, and then incorporated into SAFER by Massey [<a href="Applied%20Cryptography_split_036.html#r1010" class="calibre5 pcalibre">1010</a>]. It uses two
keys, <i class="calibre12">K</i><sub class="calibre15">a</sub> and <i class="calibre12">K</i><sub class="calibre15">b</sub>, each 64-bits long. The trick is to generate two subkey sequences in parallel, and then alternate subkeys from each sequence. This
means that if you choose <i class="calibre12">K</i><sub class="calibre15">a</sub> = <i class="calibre12">K</i><sub class="calibre15">b</sub>, then the 128-bit key is compatible with the 64-bit key <i class="calibre12">K</i><sub class="calibre15">a</sub>.</p>

<h4 class="calibre8">Security of SAFER K-64</h4>

<p class="calibre9">Massey showed that SAFER K-64 is immune to differential cryptanalysis after
8 rounds and is adequately secure against the attack after 6 rounds. After only
3 rounds linear cryptanalysis is ineffective against this algorithm [<a href="Applied%20Cryptography_split_036.html#r1010" class="calibre5 pcalibre">1010</a>].</p>

<p class="calibre9">Knudsen found a weakness in the key schedule: For virtually every key, there
exists at least one (and sometimes as many as nine) other key that encrypts
some different plaintext to identical ciphertexts [<a href="Applied%20Cryptography_split_036.html#r862" class="calibre5 pcalibre">862</a>]. The number of different
plaintexts that encrypt to identical ciphertexts after 6 rounds is anywhere from
2<sup class="calibre19">22</sup> to 2<sup class="calibre19">28</sup>. While this attack may not impact SAFER’s security when used as
an encryption algorithm, it greatly reduces its security when used as a one-way
hash function. In any case, Knudsen recommends at least 8 rounds.</p>

<p class="calibre9">SAFER was designed for Cylink, and Cylink is tainted by the NSA [<a href="Applied%20Cryptography_split_035.html#r80" class="calibre5 pcalibre">80</a>]. I
recommend years of intense cryptanalysis before using SAFER in any form.</p>

<h3 id="14.5" class="calibre7">14.5 3-Way</h3>

<p class="calibre9">3-Way is a block cipher designed by Joan Daemen [<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>,<a href="Applied%20Cryptography_split_035.html#r410" class="calibre5 pcalibre">410</a>]. It has a 96-bit
block length and key length, and is designed to be very efficient in hardware.</p>

<p class="calibre9">3-Way is not a Feistel network, but it is an iterated block cipher. 3-Way can
have <i class="calibre12">n</i> rounds; Daemen recommends 11.</p>

<h4 class="calibre8">Description of 3-Way</h4>

<p class="calibre9">The algorithm is simple to describe. To encrypt a plaintext block, <i class="calibre12">x:</i></p>

<p class="math-left">For <i class="calibre12">i</i> = 0 to <i class="calibre12">n</i> - 1
    <i class="calibre12">x</i> = <i class="calibre12">x</i> XOR <i class="calibre12">K</i><sub class="calibre15">i</sub>
    <i class="calibre12">x</i> = theta(<i class="calibre12">x</i>)
    <i class="calibre12">x</i> = pi - 1(<i class="calibre12">x</i>)
    <i class="calibre12">x</i> = gamma(<i class="calibre12">x</i>)
    <i class="calibre12">x</i> = pi - 2(x)
<i class="calibre12">x</i> = <i class="calibre12">x</i> ⊕ <i class="calibre12">K</i><sub class="calibre15">n</sub>
<i class="calibre12">x</i> = theta(<i class="calibre12">x</i>)
</p>

<p class="calibre9">The functions are:</p>

<ul class="calibre13">

<li class="calibre14">theta(<i class="calibre12">x</i>) is a linear substitution function — basically a bunch of
circular shifts and XORs.
</li>
<li class="calibre14">pi-1(<i class="calibre12">x</i>) and pi-2(<i class="calibre12">x</i>) are simple permutations.
</li>
<li class="calibre14">gamma(<i class="calibre12">x</i>) is a nonlinear substitution function. This is the step that gives 3-Way its name; it is the parallel execution of the substitution step
on 3-bit blocks of the input.
</li>

</ul>

<p class="calibre9">Decryption is similar to encryption, except that the bits of the input have to be
reversed and the bits of the output have to be reversed. Code to implement
3-Way can be found in the back of this book.</p>

<p class="calibre9">So far, there has been no successful cryptanalysis of 3-Way. The algorithm is
unpatented.</p>

<h3 id="14.6" class="calibre7">14.6 Crab</h3>

<p class="calibre9">This algorithm was developed by Burt Kaliski and Matt Robshaw of RSA
Laboratories [<a href="Applied%20Cryptography_split_035.html#r810" class="calibre5 pcalibre">810</a>]. The idea behind Crab is to use techniques from one-way
hash functions to make a fast encryption algorithm. Hence, Crab is very
similar to MD5, and this section assumes you are familiar with <a href="Applied%20Cryptography_split_021.html#18.5" class="calibre5 pcalibre">Section 18.5</a>.</p>

<p class="calibre9">Crab has a very large block: 1024 bytes. Since Crab is presented more as a
research contribution than a real algorithm, no definitive key-generation
routines are presented. The authors suggest a method that could turn an 80-bit
key into three requisite subkeys, although the algorithm could easily accept
variable-length keys.</p>

<p class="calibre9">Crab uses two sets of large subkeys:</p>

<ul class="split1">
<li class="calibre35">A permutation of the numbers 0 through 255: <i class="calibre12">P</i><sub class="calibre15">0</sub>, <i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">P</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">P</i><sub class="calibre15">255</sub>.</li>
<li class="calibre35">A 2048-entry array of 32-bit numbers: <i class="calibre12">S</i><sub class="calibre15">0</sub>, <i class="calibre12">S</i><sub class="calibre15">1</sub>, <i class="calibre12">S</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">2047</sub>.</li>
</ul>

<p class="calibre9">These subkeys must all be calculated before encryption or decryption.</p>

<p class="calibre9">To encrypt a 1024-byte block <i class="calibre12">X:</i></p>

<ol class="calibre17">

<li class="calibre14">Divide <i class="calibre12">X</i> into 256 32-bit sub-blocks: <i class="calibre12">X</i><sub class="calibre15">0</sub>, <i class="calibre12">X</i><sub class="calibre15">1</sub>, <i class="calibre12">X</i><sub class="calibre15">2</sub>,..., <i class="calibre12">X</i><sub class="calibre15">255</sub>.
</li>
<li class="calibre14">Permute the sub-blocks of <i class="calibre12">X</i> according to <i class="calibre12">P</i>.
</li>
<li class="calibre14"><p class="math-left">For <i class="calibre12">r</i> = 0 to 3
    For <i class="calibre12">g</i> = 0 to 63
        <i class="calibre12">A</i> = <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>)&lt;&lt;&lt;2r</sub>
        <i class="calibre12">B</i> = <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+1)&lt;&lt;&lt;2r</sub>
        <i class="calibre12">C</i> = <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+2)&lt;&lt;&lt;2r</sub>
        <i class="calibre12">D</i> = <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+3)&lt;&lt;&lt;2r</sub>
        For step <i class="calibre12">s</i> = 0 to 7
            <i class="calibre12">A</i> = <i class="calibre12">A</i> ⊕ (<i class="calibre12">B</i> + f<sub class="calibre15">r</sub>(<i class="calibre12">B,C,D</i>) + <i class="calibre12">S</i><sub class="calibre15">512<i class="calibre22">r</i>+8<i class="calibre22">g</i>+s</sub>)
            <i class="calibre12">TEMP</i> = <i class="calibre12">D</i>
            <i class="calibre12">D</i> = <i class="calibre12">C</i>
            <i class="calibre12">C</i> = <i class="calibre12">B</i>
            <i class="calibre12">B</i> = <i class="calibre12">A</i> &lt;&lt;&lt; 5
            <i class="calibre12">A</i> = <i class="calibre12">TEMP</i>
        <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>)&lt;&lt;&lt;2r</sub> = <i class="calibre12">A</i>
        <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+1)&lt;&lt;&lt;2r</sub> = <i class="calibre12">B</i>
        <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+2)&lt;&lt;&lt;2r</sub> = <i class="calibre12">C</i>
        <i class="calibre12">X</i><sub class="calibre15">(4<i class="calibre22">g</i>+3)&lt;&lt;&lt;2r</sub> = <i class="calibre12">D</i>
</p>
</li>
<li class="calibre14">Recombine <i class="calibre12">X</i><sub class="calibre15">0</sub>, <i class="calibre12">X</i><sub class="calibre15">1</sub>, <i class="calibre12">X</i><sub class="calibre15">2</sub>,..., <i class="calibre12">X</i><sub class="calibre15">255</sub> to form the ciphertext.
</li>

</ol>

<p class="calibre9">The functions f<sub class="calibre15">r</sub>(<i class="calibre12">B,C,D</i>) are similar to those used in MD5:</p>

<p class="math-left"><i class="calibre12">f</i><sub class="calibre15">0</sub>(<i class="calibre12">B,C,D</i>) = (<i class="calibre12">B</i> ∧ <i class="calibre12">C</i>) ∨ ((¬<i class="calibre12">B</i>) ∧ <i class="calibre12">D</i>)
<i class="calibre12">f</i><sub class="calibre15">1</sub>(<i class="calibre12">B,C,D</i>) = (<i class="calibre12">B</i> ∧ <i class="calibre12">D</i>) ∨ (<i class="calibre12">C</i> ∧ (¬<i class="calibre12">D</i>))
<i class="calibre12">f</i><sub class="calibre15">2</sub>(<i class="calibre12">B,C,D</i>) = <i class="calibre12">B</i> ⊕ <i class="calibre12">C</i> ⊕ <i class="calibre12">D</i>
<i class="calibre12">f</i><sub class="calibre15">3</sub>(<i class="calibre12">B,C,D</i>) = <i class="calibre12">C</i> ⊕ (<i class="calibre12">B</i> ∨ (¬<i class="calibre12">D</i>))
</p>

<p class="calibre9">Decryption is the reverse process.</p>

<p class="calibre9">Generating the subkeys is a large task. Here is how the permutation array, <i class="calibre12">P</i>,
could be generated from an 80-bit key, <i class="calibre12">K</i>.</p>

<ol class="calibre17">

<li class="calibre14">Initialize <i class="calibre12">K</i><sub class="calibre15">0</sub>, <i class="calibre12">K</i><sub class="calibre15">1</sub>, <i class="calibre12">K</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">K</i><sub class="calibre15">9</sub> with the 10 bytes of <i class="calibre12">K</i>.
</li>
<li class="calibre14"><p class="math-left">For <i class="calibre12">i</i> = 10 to 255
    <i class="calibre12">K</i><sub class="calibre15">i</sub> = <i class="calibre12">K</i><sub class="calibre15">i - 2</sub> ⊕ <i class="calibre12">K</i><sub class="calibre15">i - 6</sub> ⊕ <i class="calibre12">K</i><sub class="calibre15">i - 7</sub> ⊕ <i class="calibre12">K</i><sub class="calibre15">i - 10</sub>
</p>

</li>
<li class="calibre14">For <i class="calibre12">i</i> = 0 to 255, <i class="calibre12">P</i><sub class="calibre15">i</sub> = <i class="calibre12">i</i>
</li>
<li class="calibre14"><i class="calibre12">m</i> = 0
</li>
<li class="calibre14"><p class="math-left">For <i class="calibre12">j</i> = 0 to 1
    For <i class="calibre12">i</i> = 256 to 1 step -1
        <i class="calibre12">m</i> = ( <i class="calibre12">K</i><sub class="calibre15">256 - <i class="calibre22">i</i></sub> + <i class="calibre12">K</i><sub class="calibre15">257 - <i class="calibre22">i</i></sub>) mod <i class="calibre12">i</i>
        <i class="calibre12">K</i><sub class="calibre15">257 - <i class="calibre22">i</i></sub> = <i class="calibre12">K</i><sub class="calibre15">257 - <i class="calibre22">i</i></sub> &lt;&lt;&lt; 3
        Swap <i class="calibre12">P</i><sub class="calibre15">i</sub> and <i class="calibre12">P</i><sub class="calibre15">i - 1</sub>
</p>

</li>

</ol>

<p class="calibre9">The S-array of 2048 32-bit words could be generated in a similar manner,
either from the same 80-bit key or from another key. The authors caution that
these details should “be viewed as motivational; there may very well be
alternative schemes which are both more efficient and offer improved
security” [<a href="Applied%20Cryptography_split_035.html#r810" class="calibre5 pcalibre">810</a>].</p>

<p class="calibre9">Crab was proposed as a testbed of new ideas and not as a working algorithm. It
uses many of the same techniques as MD5. Biham has argued that a very large
block size makes an algorithm easier to cryptanalyze [<a href="Applied%20Cryptography_split_035.html#r160" class="calibre5 pcalibre">160</a>]. On the other hand,
Crab may make efficient use of a very large key. In such a case, “easier to
cryptanalyze” might not mean much.</p>

<h3 id="14.7" class="calibre7">14.7 SXAL8/MBAL</h3>

<p class="calibre9">This is a 64-bit block algorithm from Japan [<a href="Applied%20Cryptography_split_035.html#r769" class="calibre5 pcalibre">769</a>]. SXAL8 is the basic
algorithm; MBAL is an expanded version with a variable block length. Since
MBAL does some clever things internally, the authors claim that they can get
adequate security with only a few rounds. With a block length of 1024 bytes,
MBAL is about 70 times faster than DES. Unfortunately, [<a href="Applied%20Cryptography_split_036.html#r1174" class="calibre5 pcalibre">1174</a>] shows that
MBAL is susceptible to differential cryptanalysis, and [<a href="Applied%20Cryptography_split_036.html#r865" class="calibre5 pcalibre">865</a>] shows that it is
susceptible to linear cryptanalysis.</p>

<h3 id="14.8" class="calibre7">14.8 RC5</h3>

<p class="calibre9">RC5 is a block cipher with a variety of parameters: block size, key size, and
number of rounds. It was invented by Ron Rivest and analyzed by RSA
Laboratories [<a href="Applied%20Cryptography_split_036.html#r1324" class="calibre5 pcalibre">1324</a>,<a href="Applied%20Cryptography_split_036.html#r1325" class="calibre5 pcalibre">1325</a>].</p>

<p class="calibre9">There are three operations: XOR, addition, and rotations. Rotations are
constant-time operations on most processors and variable rotations are a
nonlinear function. These rotations, which depend on both the key and the
data, are the interesting operation.</p>

<p class="calibre9">RC5 has a variable-length block, but this example will focus on a 64-bit data
block. Encryption uses 2<i class="calibre12">r</i> + 2 key-dependent 32-bit words — <i class="calibre12">S</i><sub class="calibre15">0</sub>, <i class="calibre12">S</i><sub class="calibre15">1</sub>, <i class="calibre12">S</i><sub class="calibre15">2</sub>,..., <i class="calibre12">S</i><sub class="calibre15">2<i class="calibre22">r</i> +
1</sub> — where <i class="calibre12">r</i> is the number of rounds. We’ll generate those words later. To
encrypt, first divide the plaintext block into two 32-bit words: <i class="calibre12">A</i> and <i class="calibre12">B</i>. (RC5
assumes a little-endian convention for packing bytes into words: The first byte
goes into the low-order bit positions of register <i class="calibre12">A</i>, etc.) Then:</p>

<p class="math-left"><i class="calibre12">A</i> = <i class="calibre12">A</i> + <i class="calibre12">S</i><sub class="calibre15">0</sub>
<i class="calibre12">B</i> = <i class="calibre12">B</i> + <i class="calibre12">S</i><sub class="calibre15">1</sub>
For <i class="calibre12">i</i> = 1 to <i class="calibre12">r:</i>
    <i class="calibre12">A</i> = ((<i class="calibre12">A</i> ⊕ <i class="calibre12">B</i>) &lt;&lt;&lt; <i class="calibre12">B</i>) + <i class="calibre12">S</i><sub class="calibre15">2i</sub>
    <i class="calibre12">B</i> = ((<i class="calibre12">B</i> ⊕ <i class="calibre12">A</i>) &lt;&lt;&lt; <i class="calibre12">A</i>) + <i class="calibre12">S</i><sub class="calibre15">2<i class="calibre22">i</i> + 1</sub>
</p>

<p class="calibre9">The output is in the registers <i class="calibre12">A</i> and <i class="calibre12">B</i>.</p>

<p class="calibre9">Decryption is just as easy. Divide the plaintext block into two words, <i class="calibre12">A</i> and <i class="calibre12">B</i>, and then:</p>

<p class="math-left">For <i class="calibre12">i</i> = <i class="calibre12">r</i> down to 1:
    <i class="calibre12">B</i> = ((<i class="calibre12">B</i> - <i class="calibre12">S</i><sub class="calibre15">2i + 1</sub>) &gt;&gt;&gt; <i class="calibre12">A</i>) ⊕ <i class="calibre12">A</i>
    <i class="calibre12">A</i> = ((<i class="calibre12">A</i> - <i class="calibre12">S</i><sub class="calibre15">2i</sub>) &gt;&gt;&gt; <i class="calibre12">B</i>) ⊕ <i class="calibre12">B</i>
<i class="calibre12">B</i> = <i class="calibre12">B</i> - <i class="calibre12">S</i><sub class="calibre15">1</sub>
<i class="calibre12">A</i> = <i class="calibre12">A</i> - <i class="calibre12">S</i><sub class="calibre15">0</sub>
</p>

<p class="calibre9">The symbol “&gt;&gt;&gt;” is a right circular shift. Of course, all addition and
subtraction are mod 2<sup class="calibre19">32</sup>.</p>

<p class="calibre9">Creating the array of keys is more complicated, but also straightforward. First,
copy the bytes of the key into an array, <i class="calibre12">L</i>, of <i class="calibre12">c</i> 32-bit words, padding the final word with zeros if necessary. Then, initialize an array, <i class="calibre12">S</i>, using a linear
congruential generator mod 2<sup class="calibre19">32</sup>:</p>

<p class="math-left"><i class="calibre12">S</i><sub class="calibre15">0</sub> = P
for <i class="calibre12">i</i> = 1 to 2(<i class="calibre12">r</i> + 1) – 1:
    <i class="calibre12">S</i><sub class="calibre15">i</sub> = (<i class="calibre12">S</i><sub class="calibre15">i - 1</sub> + Q) mod 2<sup class="calibre19">32</sup>
</p>

<p class="calibre9">P = <code class="calibre18">0xb7e15163</code> and Q = <code class="calibre18">0x9e3779b9</code>; these constants are based on the binary
representation of e and phi.</p>

<p class="calibre9">Finally, mix <i class="calibre12">L</i> into <i class="calibre12">S:</i></p>

<p class="math-left"><i class="calibre12">i</i> = <i class="calibre12">j</i> = 0
<i class="calibre12">A</i> = <i class="calibre12">B</i> = 0
do 3<i class="calibre12">n</i> times (where <i class="calibre12">n</i> is the maximum of 2(<i class="calibre12">r</i> + 1) and <i class="calibre12">c</i>):
    <i class="calibre12">A</i> = <i class="calibre12">S</i><sub class="calibre15">i</sub> = (<i class="calibre12">S</i><sub class="calibre15">i</sub> + <i class="calibre12">A</i> + <i class="calibre12">B</i>) &lt;&lt;&lt; 3
    <i class="calibre12">B</i> = <i class="calibre12">L</i><sub class="calibre15">j</sub> = (<i class="calibre12">L</i><sub class="calibre15">j</sub> + <i class="calibre12">A</i> + <i class="calibre12">B</i>) &lt;&lt;&lt; (<i class="calibre12">A</i> + <i class="calibre12">B</i>)
<i class="calibre12">i</i> = (<i class="calibre12">i</i> + 1) mod 2(<i class="calibre12">r</i> + 1)
<i class="calibre12">j</i> = (<i class="calibre12">j</i> + 1) mod <i class="calibre12">c</i>
</p>

<p class="calibre9">RC5 is actually a family of algorithms. We just defined RC5 with a 32-bit
word size and 64-bit block; there’s no reason why the same algorithm can’t
have a 64-bit word size and 128-bit block size. For <i class="calibre12">w</i> = 64, P and Q are
<code class="calibre18">0xb7e151628aed2a6b</code> and <code class="calibre18">0x9e3779b97f4a7c15</code>, respectively. Rivest
designates particular implementations of RC5 as RC5-<i class="calibre12">w/r/b</i>, where <i class="calibre12">w</i> is the word size, <i class="calibre12">r</i> is the number of rounds, and <i class="calibre12">b</i> is the length of the key in bytes.</p>

<p class="calibre9">RC5 is new, but RSA Laboratories has spent considerable time analyzing it
with a 64-bit block. After 5 rounds, the statistics look very good. After 8
rounds, every plaintext bit affects at least one rotation. There is a differential
attack that requires 2<sup class="calibre19">24</sup> chosen plaintexts for 5 rounds, 2<sup class="calibre19">45</sup> for 10 rounds, 2<sup class="calibre19">53</sup>
for 12 rounds, and 2<sup class="calibre19">68</sup> for 15 rounds. Of course, there are only 2<sup class="calibre19">64</sup> possible
chosen plaintexts, so this attack won’t work for 15 or more rounds. Linear
cryptanalysis estimates indicate that it is secure after 6 rounds. Rivest
recommends at least 12 rounds, and possibly 16 [<a href="Applied%20Cryptography_split_036.html#r1325" class="calibre5 pcalibre">1325</a>]. This number may
change.</p>

<p class="calibre9">RSADSI is in the process of patenting RC5, and the name is trademarked. The
company claims that license fees will be very small, but you’d better check
with them.</p>

<h3 id="14.9" class="calibre7">14.9 Other Block Algorithms</h3>

<p class="calibre9">There is an algorithm called CRYPTO-MECCANO in the literature [<a href="Applied%20Cryptography_split_035.html#r301" class="calibre5 pcalibre">301</a>]; it is
insecure. Four Japanese cryptographers presented an algorithm based on
chaotic maps at Eurocrypt ’91 [<a href="Applied%20Cryptography_split_035.html#r687" class="calibre5 pcalibre">687</a>,<a href="Applied%20Cryptography_split_035.html#r688" class="calibre5 pcalibre">688</a>]; Biham cryptanalyzed the algorithm
at the same conference [<a href="Applied%20Cryptography_split_035.html#r157" class="calibre5 pcalibre">157</a>]. Another algorithm relies on subsets of a
particular set of random codes [<a href="Applied%20Cryptography_split_035.html#r693" class="calibre5 pcalibre">693</a>]. There are several algorithms based on the
theory of error-correcting codes: a variant of the McEliece algorithm (see
<a href="Applied%20Cryptography_split_022.html#19.7" class="calibre5 pcalibre">Section 19.7</a>) [<a href="Applied%20Cryptography_split_035.html#r786" class="calibre5 pcalibre">786</a>,<a href="Applied%20Cryptography_split_036.html#r1290" class="calibre5 pcalibre">1290</a>], the Rao-Nam algorithm
[<a href="Applied%20Cryptography_split_036.html#r1292" class="calibre5 pcalibre">1292</a>, <a href="Applied%20Cryptography_split_035.html#r733" class="calibre5 pcalibre">733</a>, <a href="Applied%20Cryptography_split_036.html#r1504" class="calibre5 pcalibre">1504</a>, <a href="Applied%20Cryptography_split_036.html#r1291" class="calibre5 pcalibre">1291</a>, <a href="Applied%20Cryptography_split_036.html#r1056" class="calibre5 pcalibre">1056</a>, <a href="Applied%20Cryptography_split_036.html#r1057" class="calibre5 pcalibre">1057</a>, <a href="Applied%20Cryptography_split_036.html#r1058" class="calibre5 pcalibre">1058</a>, <a href="Applied%20Cryptography_split_036.html#r1293" class="calibre5 pcalibre">1293</a>], variants of the Rao-Nam
algorithm [<a href="Applied%20Cryptography_split_035.html#r464" class="calibre5 pcalibre">464</a>,<a href="Applied%20Cryptography_split_035.html#r749" class="calibre5 pcalibre">749</a>,<a href="Applied%20Cryptography_split_036.html#r1503" class="calibre5 pcalibre">1503</a>], and the Li-Wang algorithm [<a href="Applied%20Cryptography_split_036.html#r964" class="calibre5 pcalibre">964</a>,<a href="Applied%20Cryptography_split_036.html#r1561" class="calibre5 pcalibre">1561</a>] — they are
all insecure. CALC is insecure [<a href="Applied%20Cryptography_split_036.html#r1109" class="calibre5 pcalibre">1109</a>]. An algorithm called TEA, for Tiny
Encryption Algorithm, is too new to comment on [<a href="Applied%20Cryptography_split_036.html#r1592" class="calibre5 pcalibre">1592</a>]. Vino is another
algorithm [<a href="Applied%20Cryptography_split_035.html#r503" class="calibre5 pcalibre">503</a>]. MacGuffin, a block algorithm by Matt Blaze and me, is also
insecure [<a href="Applied%20Cryptography_split_035.html#r189" class="calibre5 pcalibre">189</a>]; it was broken at the same conference it was proposed.
BaseKing, similar in design philosophy as 3-way but with a 192-bit block
[<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>], is too new to comment on.</p>

<p class="calibre9">There are many more block algorithms outside the cryptology community.
Some are used by various government and military organizations. I have no
information about any of those. There are also dozens of proprietary
commercial algorithms. Some might be good; most are probably not. If
companies do not feel that their interests are served by making their algorithms
public, it is best to assume they’re right and avoid the algorithm.</p>

<h3 id="14.10" class="calibre7">14.10 Theory of Block Cipher Design</h3>

<p class="calibre9">In <a href="Applied%20Cryptography_split_014.html#11.1" class="calibre5 pcalibre">Section 11.1</a>, I described Shannon’s principles of confusion and diffusion.
Fifty years after these principles were first written, they remain the cornerstone
of good block cipher design.</p>

<p class="calibre9">Confusion serves to hide any relationship between the plaintext, the ciphertext,
and the key. Remember how linear and differential cryptanalysis can exploit
even a slight relationship between these three things? Good confusion makes
the relationship statistics so complicated that even these powerful cryptanalytic
tools won’t work.</p>

<p class="calibre9">Diffusion spreads the influence of individual plaintext or key bits over as much
of the ciphertext as possible. This also hides statistical relationships and makes
cryptanalysis more difficult.</p>

<p class="calibre9">Confusion alone is enough for security. An algorithm consisting of a single
key-dependent lookup table of 64 bits of plaintext to 64 bits of ciphertext
would be plenty strong. The problem is that large lookup tables require lots of
memory to implement: 10<sup class="calibre19">20</sup> bytes of memory for the table just mentioned. The
whole point of block cipher design is to create something that looks like a
large lookup table, but with much smaller memory requirements.</p>

<p class="calibre9">The trick is to repeatedly mix confusion (with much smaller tables) and
diffusion in a single cipher in different combinations. This is called a <b class="calibre10">product</b>
<b class="calibre10">cipher</b>. Sometimes a block cipher that incorporates layers of substitution and
permutation is called a <b class="calibre10">substitution-permutation network</b>, or even an <b class="calibre10">SP</b>
<b class="calibre10">network</b>.</p>

<p class="calibre9">Look back at function f of DES. The expansion permutation and P-box
perform diffusion; the S-boxes perform confusion. The expansion permutation
and P-box are linear; the S-boxes are nonlinear. Each operation is pretty
simple on its own; together they work pretty well.</p>

<p class="calibre9">DES also illustrates a few more principles of block cipher design. The first is
the idea of an <b class="calibre10">iterated block cipher</b>. This simply means taking a simple round
function and iterating it multiple times. Two-round DES isn’t very strong; it
takes 5 rounds before all of the output bits are dependent on all of the input
bits and all of the key bits [<a href="Applied%20Cryptography_split_036.html#r1078" class="calibre5 pcalibre">1078</a>,<a href="Applied%20Cryptography_split_036.html#r1080" class="calibre5 pcalibre">1080</a>]. Sixteen-round DES is strong; 32-round
DES is even stronger.</p>

<h4 class="calibre8">Feistel Networks</h4>

<p class="calibre9">Most block algorithms are <b class="calibre10">Feistel networks</b>. This idea dates from the early
1970s [<a href="Applied%20Cryptography_split_035.html#r552" class="calibre5 pcalibre">552</a>,<a href="Applied%20Cryptography_split_035.html#r553" class="calibre5 pcalibre">553</a>]. Take a block of length <i class="calibre12">n</i> and divide it into two halves of
length <i class="calibre12">n</i>/2: <i class="calibre12">L</i> and <i class="calibre12">R</i>. Of course, <i class="calibre12">n</i> must be even. You can define an iterated block cipher where the output of the <i class="calibre12">i</i>th round is determined from the output of the previous round:</p>

<p class="math-left"><i class="calibre12">L</i><sub class="calibre15">i</sub> = <i class="calibre12">R</i><sub class="calibre15">i - 1</sub>
<i class="calibre12">R</i><sub class="calibre15">i</sub> = <i class="calibre12">L</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">f</i>(<i class="calibre12">R</i><sub class="calibre15">i - 1</sub>, <i class="calibre12">K</i><sub class="calibre15">i</sub>)
</p>

<p class="calibre9"> <i class="calibre12">K</i><sub class="calibre15">i</sub> is the subkey used in the <i class="calibre12">i</i>th round and <i class="calibre12">f</i> is an arbitrary round function.</p>

<p class="calibre9">You’ve seen this concept in DES, Lucifer, FEAL, Khufu, Khafre, LOKI,
GOST, CAST, Blowfish, and others. Why is it such a big deal? The function is
guaranteed to be reversible. Because XOR is used to combine the left half with
the output of the round function, it is necessarily true that</p>

<p class="math"><i class="calibre12">L</i><sub class="calibre15">i - 1</sub> ⊕ <i class="calibre12">f</i>(<i class="calibre12">R</i><sub class="calibre15">i - 1</sub>, <i class="calibre12">K</i><sub class="calibre15">i</sub>) ⊕ <i class="calibre12">f</i>(<i class="calibre12">R</i><sub class="calibre15">i - 1</sub>, <i class="calibre12">K</i><sub class="calibre15">i</sub>) = <i class="calibre12">L</i><sub class="calibre15">i - 1</sub>
</p>

<p class="calibre9">A cipher that uses this construction is guaranteed to be invertible as long as the
inputs to <i class="calibre12">f</i> in each round can be reconstructed. It doesn’t matter what <i class="calibre12">f</i> is; <i class="calibre12">f</i> need not be invertible. We can design <i class="calibre12">f</i> to be as complicated as we please, and we don’t have to implement two different algorithms — one for encryption and
another for decryption. The structure of a Feistel network takes care of all this
automatically.</p>

<h4 class="calibre8">Simple Relations</h4>

<p class="calibre9">DES has the property that if <i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i></sub>(<i class="calibre12">P</i>) = <i class="calibre12">C</i>, then <i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K’</i></sub>(<i class="calibre12">P’</i>) = <i class="calibre12">C’</i>, where <i class="calibre12">P’</i>, <i class="calibre12">C’</i>, and <i class="calibre12">K’</i> are the bit-wise complements of <i class="calibre12">P, C</i>, and <i class="calibre12">K</i>. This property reduces the complexity of a brute-force attack by a factor of two. LOKI has
complementation properties that reduce the complexity of a brute-force attack by a factor of 256.</p>

<p class="calibre9">A <b class="calibre10">simple relation</b> can be defined as [<a href="Applied%20Cryptography_split_036.html#r857" class="calibre5 pcalibre">857</a>]:</p>

<p class="math">If <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">P</i>) = <i class="calibre12">C</i>, then <i class="calibre12">E</i><sub class="calibre15">f(K)</sub>(<i class="calibre12">g</i>(<i class="calibre12">P,K</i>)) = <i class="calibre12">h</i>(<i class="calibre12">C,K</i>)
</p>

<p class="calibre9">where <i class="calibre12">f, g</i>, and <i class="calibre12">h</i> are simple functions. By simple I mean that they are easy to compute, much easier than an iteration of the block cipher. In DES, <i class="calibre12">f</i> is the
bit-wise complement of <i class="calibre12">K, g</i> is the bit-wise complement of <i class="calibre12">P</i>, and <i class="calibre12">h</i> is the bit-wise complement of <i class="calibre12">C</i>. This is a result of XORing the key into part of the
text.</p>

<p class="calibre9">In a good block cipher, there are no simple relations. Methods for finding
some of these weaknesses are in [<a href="Applied%20Cryptography_split_036.html#r917" class="calibre5 pcalibre">917</a>].</p>

<h4 class="calibre8">Group Structure</h4>

<p class="calibre9">When discussing an algorithm, the question of whether it is a group arises. The
elements of the group are the ciphertext blocks with each possible key, and the
group operation is composition. Looking at an algorithmos group structure is
an attempt to get a handle on just how much extra scrambling happens under
multiple encryption.</p>

<p class="calibre9">The useful question is, however, not whether an algorithm is actually a group,
but just how close to a group it is. If it were only lacking one element, it
would not be a group; but double encryption would be — statistically
speaking — a waste of time. The work on DES showed that DES is very far
away from being a group. There are still some interesting questions about the
semigroup that DES encryption generates. Does it contain the identity: That is,
does it even generate a group? To put it another way, does some combination
of encryption (not decryption) operations eventually generate the identity
function? If so, how long is the shortest such combination?</p>

<p class="calibre9">The goal is to estimate the size of the keyspace for a theoretical brute-force
attack, and the result is a greatest lower bound on the keyspace entropy.</p>

<h4 class="calibre8">Weak Keys</h4>

<p class="calibre9">In a good block cipher, all keys are equally strong. Algorithms with a small
number of weak keys, like DES, are generally no problem. The odds of
picking one at random are very small, and it’s easy to test for and discard
them. However, these weak keys can sometimes be exploited if the block
cipher is used as a one-way hash function (see <a href="Applied%20Cryptography_split_021.html#18.11" class="calibre5 pcalibre">Section 18.11</a>).</p>

<h4 class="calibre8">Strength against Differential and Linear Cryptanalysis</h4>

<p class="calibre9">The study of differential and linear cryptanalysis has shed significant light on
the theory of good block cipher design. The inventors of IDEA introduced the
concept of <b class="calibre10">differentials</b>, a generalization of the basic idea of characteristics
[<a href="Applied%20Cryptography_split_036.html#r931" class="calibre5 pcalibre">931</a>]. They argued that block ciphers can be designed to resist this attack;
IDEA is the result of that work [<a href="Applied%20Cryptography_split_036.html#r931" class="calibre5 pcalibre">931</a>]. This concept was further formalized in
[<a href="Applied%20Cryptography_split_036.html#r1181" class="calibre5 pcalibre">1181</a>,<a href="Applied%20Cryptography_split_036.html#r1182" class="calibre5 pcalibre">1182</a>], when Kaisa Nyberg and Lars Knudsen showed how to make
block ciphers provably secure against differential cryptanalysis. This theory
has extensions to higher-order differentials [<a href="Applied%20Cryptography_split_035.html#r702" class="calibre5 pcalibre">702</a>,<a href="Applied%20Cryptography_split_035.html#r161" class="calibre5 pcalibre">161</a>,<a href="Applied%20Cryptography_split_036.html#r927" class="calibre5 pcalibre">927</a>,<a href="Applied%20Cryptography_split_036.html#r858" class="calibre5 pcalibre">858</a>,<a href="Applied%20Cryptography_split_036.html#r860" class="calibre5 pcalibre">860</a>] and partial
differentials [<a href="Applied%20Cryptography_split_036.html#r860" class="calibre5 pcalibre">860</a>]. Higher-order differentials seem to apply only to ciphers
with a small number of rounds, but partial differentials combine nicely with
differentials.</p>

<p class="calibre9">Linear cryptanalysis is newer, and is still being improved. Notions of key
ranking [<a href="Applied%20Cryptography_split_036.html#r1019" class="calibre5 pcalibre">1019</a>] and multiple approximations [<a href="Applied%20Cryptography_split_035.html#r811" class="calibre5 pcalibre">811</a>,<a href="Applied%20Cryptography_split_035.html#r812" class="calibre5 pcalibre">812</a>] have been defined.
other work that extends the idea of linear cryptanalysis can be found in [<a href="Applied%20Cryptography_split_036.html#r1270" class="calibre5 pcalibre">1270</a>];
[<a href="Applied%20Cryptography_split_036.html#r938" class="calibre5 pcalibre">938</a>] tries to combine linear and differential cryptanalysis into one attack. It is
unclear what design techniques will protect against these sorts of attacks.</p>

<p class="calibre9">Knudsen has made some progress, considering some necessary (but not
perhaps sufficient) criteria for what he calls <b class="calibre10">practically secure Feistel</b>
<b class="calibre10">networks</b>: ciphers that resist both linear and differential cryptanalysis [<a href="Applied%20Cryptography_split_036.html#r857" class="calibre5 pcalibre">857</a>].
Nyberg introduced in linear cryptanalysis an analogy to the concept of
differentials from differential cryptanalysis [<a href="Applied%20Cryptography_split_036.html#r1180" class="calibre5 pcalibre">1180</a>].</p>

<p class="calibre9">Interestingly enough, there seems to be a duality between differential and
linear cryptanalysis. This duality becomes apparent both in the design of
techniques to construct good differential characteristics and linear
approximations [<a href="Applied%20Cryptography_split_035.html#r164" class="calibre5 pcalibre">164</a>,<a href="Applied%20Cryptography_split_036.html#r1018" class="calibre5 pcalibre">1018</a>], and also in the design criteria for making
algorithms that are secure against both attacks [<a href="Applied%20Cryptography_split_035.html#r307" class="calibre5 pcalibre">307</a>]. Exactly where this line of
research will lead is still unknown. As a start, Daemen has developed an
algorithm-design strategy based on linear and differential cryptanalysis [<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>].</p>

<h4 class="calibre8">S-Box Design</h4>

<p class="calibre9">The strength of various Feistel networks — and specifically their resistance to
differential and linear cryptanalysis — is tied directly to their S-boxes. This has
prompted a spate of research on what constitutes a good S-box.</p>

<p class="calibre9">An S-box is simply a substitution: a mapping of <i class="calibre12">m-</i>bit inputs to <i class="calibre12">n-</i>bit outputs.
Previously I talked about one large lookup table of 64-bit inputs to 64-bit
outputs; that would be a 64*64-bit S-box. An S-box with an <i class="calibre12">m-</i>bit input and an <i class="calibre12">n-</i>bit output is called a <i class="calibre12"><b class="calibre10">m*n</b></i><b class="calibre10">-bit S-box</b>. S-boxes are generally the only nonlinear step in an algorithm; they are what give a block cipher its security.
In general, the bigger they are, the better.</p>

<p class="calibre9">DES has eight different 6*4-bit S-boxes. Khufu and Khafre have a single
8*32-bit S-box, LOKI has a 12*8-bit S-box, and both Blowfish and CAST
have 8*32-bit S-boxes. In IDEA the modular multiplication step is effectively
the S-box; it is a 16*16-bit S-box. The larger this S-box, the harder it is to find
useful statistics to attack using either differential or linear cryptanalysis
[<a href="Applied%20Cryptography_split_035.html#r653" class="calibre5 pcalibre">653</a>,<a href="Applied%20Cryptography_split_035.html#r729" class="calibre5 pcalibre">729</a>,<a href="Applied%20Cryptography_split_036.html#r1626" class="calibre5 pcalibre">1626</a>]. Also, while random S-boxes are usually not optimal to protect
against differential and linear attacks, it is easier to find strong S-boxes if the
S-boxes are larger. Most random S-boxes are nonlinear, nondegenerate, and
have strong resistance to linear cryptanalysis — and the fraction that does not
goes down rapidly as the number of input bits decreases [<a href="Applied%20Cryptography_split_036.html#r1185" class="calibre5 pcalibre">1185</a>,<a href="Applied%20Cryptography_split_036.html#r1186" class="calibre5 pcalibre">1186</a>,<a href="Applied%20Cryptography_split_036.html#r1187" class="calibre5 pcalibre">1187</a>].</p>

<p class="calibre9">The size of <i class="calibre12">m</i> is more important than the size of <i class="calibre12">n</i>. Increasing the size of <i class="calibre12">n</i> reduces the effectiveness of differential cryptanalysis, but greatly increases the
effectiveness of linear cryptanalysis. In fact, if <i class="calibre12">n</i> ≥ 2<sup class="calibre19">m</sup> - <i class="calibre12">m</i>, then there is definitely a linear relation of the input and output bits of the S-box. And if <i class="calibre12">n</i> ≥ 2<sup class="calibre19">m</sup>, then there is a linear relation of only the output bits [<a href="Applied%20Cryptography_split_035.html#r164" class="calibre5 pcalibre">164</a>].</p>

<p class="calibre9">Much of this work involves the study of <b class="calibre10">Boolean functions</b>
[<a href="Applied%20Cryptography_split_035.html#r94" class="calibre5 pcalibre">94</a>,<a href="Applied%20Cryptography_split_036.html#r1098" class="calibre5 pcalibre">1098</a>,<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>,<a href="Applied%20Cryptography_split_036.html#r1408" class="calibre5 pcalibre">1408</a>]. In order to be secure, the Boolean functions used in
S-boxes must satisfy specific conditions. They should not be linear or affine,
nor even close to linear or affine [<a href="Applied%20Cryptography_split_035.html#r9" class="calibre5 pcalibre">9</a>,<a href="Applied%20Cryptography_split_036.html#r1177" class="calibre5 pcalibre">1177</a>,<a href="Applied%20Cryptography_split_036.html#r1178" class="calibre5 pcalibre">1178</a>,<a href="Applied%20Cryptography_split_036.html#r1188" class="calibre5 pcalibre">1188</a>]. There should be a
balance of zeros and ones, and no correlations between different combinations
of bits. The output bits should behave independently when any single input bit
is complemented. These design criteria are also related to the study of <b class="calibre10">bent</b>
<b class="calibre10">functions</b>: functions which can be shown to be optimally nonlinear. Although
their definition is simple and natural, their study is very complicated
[<a href="Applied%20Cryptography_split_036.html#r1344" class="calibre5 pcalibre">1344</a>, <a href="Applied%20Cryptography_split_036.html#r1216" class="calibre5 pcalibre">1216</a>, <a href="Applied%20Cryptography_split_036.html#r947" class="calibre5 pcalibre">947</a>, <a href="Applied%20Cryptography_split_036.html#r905" class="calibre5 pcalibre">905</a>, <a href="Applied%20Cryptography_split_036.html#r1176" class="calibre5 pcalibre">1176</a>, <a href="Applied%20Cryptography_split_036.html#r1271" class="calibre5 pcalibre">1271</a>, <a href="Applied%20Cryptography_split_035.html#r295" class="calibre5 pcalibre">295</a>, <a href="Applied%20Cryptography_split_035.html#r296" class="calibre5 pcalibre">296</a>, <a href="Applied%20Cryptography_split_035.html#r297" class="calibre5 pcalibre">297</a>, <a href="Applied%20Cryptography_split_035.html#r149" class="calibre5 pcalibre">149</a>, <a href="Applied%20Cryptography_split_035.html#r349" class="calibre5 pcalibre">349</a>, <a href="Applied%20Cryptography_split_035.html#r471" class="calibre5 pcalibre">471</a>, <a href="Applied%20Cryptography_split_035.html#r298" class="calibre5 pcalibre">298</a>].</p>

<p class="calibre9">One property that seems very important is the avalanche effect: how many
output bits of an S-box change when some subset of the input bits are changed.
It’s easy to impose conditions on Boolean functions so that they satisfy
certain avalanche criteria, but constructing them is a harder task. The <b class="calibre10">strict</b>
<b class="calibre10">avalanche criteria</b> (<b class="calibre10">SAC</b>) guarantees that exactly half of the output bits change when one input bit changes [<a href="Applied%20Cryptography_split_036.html#r1586" class="calibre5 pcalibre">1586</a>]. See also [<a href="Applied%20Cryptography_split_036.html#r982" class="calibre5 pcalibre">982</a>,<a href="Applied%20Cryptography_split_035.html#r571" class="calibre5 pcalibre">571</a>,<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>,<a href="Applied%20Cryptography_split_035.html#r399" class="calibre5 pcalibre">399</a>]. One
paper attempts to look at all these criteria in terms of information leakage [<a href="Applied%20Cryptography_split_036.html#r1640" class="calibre5 pcalibre">1640</a>].</p>

<p class="calibre9">A few years ago cryptographers proposed choosing S-boxes so that the
difference distribution table for each S-box is uniform. This would provide
immunity against differential cryptanalysis by smoothing out the differentials
in any particular round [<a href="Applied%20Cryptography_split_035.html#r6" class="calibre5 pcalibre">6</a>,<a href="Applied%20Cryptography_split_035.html#r443" class="calibre5 pcalibre">443</a>,<a href="Applied%20Cryptography_split_035.html#r444" class="calibre5 pcalibre">444</a>,<a href="Applied%20Cryptography_split_036.html#r1177" class="calibre5 pcalibre">1177</a>]. LOKI is an example of this design.
However, this approach can sometimes aid in differential cryptanalysis [<a href="Applied%20Cryptography_split_035.html#r172" class="calibre5 pcalibre">172</a>].
Actually, a better approach is making sure that the maximum differential is as
small as possible. Kwangjo Kim proposed five criteria for the construction of
S-boxes [<a href="Applied%20Cryptography_split_036.html#r834" class="calibre5 pcalibre">834</a>], similar to the design criteria for the DES S-boxes.</p>

<p class="calibre9">Choosing good S-boxes is not an easy task; there are many competing ideas on
how to do it. Four general approaches can be identified.</p>

<ol class="calibre17">

<li class="calibre14">Choose randomly. It is clear that small random S-boxes are insecure,
but large random S-boxes may be good enough. Random S-boxes with
eight or more inputs are quite strong [<a href="Applied%20Cryptography_split_036.html#r1186" class="calibre5 pcalibre">1186</a>,<a href="Applied%20Cryptography_split_036.html#r1187" class="calibre5 pcalibre">1187</a>]. Twelve-bit S-boxes
are better. Even more strength is added if the S-boxes are both random
and key-dependent. IDEA uses both large and key-dependent S-boxes.
</li>
<li class="calibre14">Choose and test. Some ciphers generate random S-boxes and then
test them for the requisite properties. See [<a href="Applied%20Cryptography_split_035.html#r9" class="calibre5 pcalibre">9</a>,<a href="Applied%20Cryptography_split_035.html#r729" class="calibre5 pcalibre">729</a>] for examples of this
approach.
</li>
<li class="calibre14">Man-made. This technique uses little mathematics: S-boxes are
generated using more intuitive techniques. Bart Preneel stated that
“...theoretically interesting criteria are not sufficient [for choosing
Boolean functions for S-boxes]...” and that “...ad hoc design criteria are
required” [<a href="Applied%20Cryptography_split_036.html#r1262" class="calibre5 pcalibre">1262</a>].
</li>
<li class="calibre14">Math-made. Generate S-boxes according to mathematical principles
so that they have proven security against differential and linear
cryptanalysis, and good diffusive properties. See [<a href="Applied%20Cryptography_split_036.html#r1179" class="calibre5 pcalibre">1179</a>] for an excellent
example of this approach.
</li>

</ol>

<p class="calibre9">There has been some call for a combination of the “math-made” and
“man-made” approaches [<a href="Applied%20Cryptography_split_036.html#r1334" class="calibre5 pcalibre">1334</a>], but the real debate seems to be between
randomly chosen S-boxes and S-boxes with certain properties. Certainly the
latter approach has the advantage of being optimal against known
attacks — linear and differential cryptanalysis — but it offers unknown
protection against unknown attacks. The designers of DES knew about
differential cryptanalysis, and its S-boxes were optimized against it. They did
not seem to know about linear cryptanalysis, and the DES S-boxes are very
weak against it [<a href="Applied%20Cryptography_split_036.html#r1018" class="calibre5 pcalibre">1018</a>]. Randomly selected S-boxes in DES would be weaker
against differential cryptanalysis and stronger against linear cryptanalysis.</p>

<p class="calibre9">On the other hand, random S-boxes may not be optimal against these attacks,
but they can be made sufficiently large and therefore sufficiently resistant.
Also, they are more likely to be sufficiently resistant against unknown attacks.
The debate is still raging, but my personal feeling is that S-boxes should be as
large as possible, random, and key-dependent.</p>

<h4 class="calibre8">Designing a Block Cipher</h4>

<p class="calibre9">It is easy to design a block cipher. If you think of a 64-bit block cipher as a
permutation of the 64-bit numbers, it is clear that almost all of those
permutations are secure. What is difficult is to design a block cipher that is not
only secure, but can also be easily described and simply implemented.</p>

<p class="calibre9">It’s is easy to design a block cipher if you have sufficient memory for 48*32
S-boxes. It’s hard to design an insecure DES variant if you iterate it for 128
rounds. If the length of your key is 512 bits, you really do not care if there are
key-complementation properties.</p>

<p class="calibre9">The real trick — and the reason that real-world block cipher design is very
difficult — is to design a block cipher with the smallest possible key, the
smallest possible memory requirement, and the fastest possible running time.</p>

<h3 id="14.11" class="calibre7">14.11 Using one-Way Hash Functions</h3>

<p class="calibre9">The simplest way to encrypt with a one-way function is to hash the previous
ciphertext block concatenated with the key, then XOR the result with the
current plaintext block:</p>

<p class="math-left"><i class="calibre12">C</i><sub class="calibre15">i</sub> = <i class="calibre12">P</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">K,C<sub class="calibre15"><i class="calibre22">i</i> - 1</sub></i>)
<i class="calibre12">P</i><sub class="calibre15">i</sub> = <i class="calibre12">C</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">K,C<sub class="calibre15"><i class="calibre22">i</i> - 1</sub></i>)
</p>

<p class="calibre9">Set the block length equal to the output of the one-way hash function. This, in
effect uses the one-way function as a block cipher in CFB mode. A similar
construction can use the one-way function in OFB mode:</p>

<p class="math-left"><i class="calibre12">C</i><sub class="calibre15">i</sub> = <i class="calibre12">P</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">S</i><sub class="calibre15">i</sub>; <i class="calibre12">S</i><sub class="calibre15">i</sub> = <i class="calibre12">H</i>(<i class="calibre12">K,C<sub class="calibre15"><i class="calibre22">i</i> - 1</sub></i>)
<i class="calibre12">P</i><sub class="calibre15">i</sub> = <i class="calibre12">C</i><sub class="calibre15">i</sub> ⊕ <i class="calibre12">S</i><sub class="calibre15">i</sub>; <i class="calibre12">S</i><sub class="calibre15">i</sub> = <i class="calibre12">H</i>(<i class="calibre12">K,C<sub class="calibre15"><i class="calibre22">i</i> - 1</sub></i>)
</p>

<p class="calibre9">The security of this scheme depends on the security of the one-way function.</p>

<h4 class="calibre8">Karn</h4>

<p class="calibre9">This method, invented by Phil Karn and placed in the public domain, makes an
invertible encryption algorithm out of certain one-way hash functions.</p>

<p class="calibre9">The algorithm operates on plaintext and ciphertext in 32-byte blocks. The key
can be any length, although certain key lengths will be more efficient for
certain one-way hash functions. For the one-way hash functions MD4 and
MD5, 96-byte keys work best.</p>

<p class="calibre9">To encrypt, first split the plaintext into two 16-byte halves: <i class="calibre12">P</i><sub class="calibre15">1</sub> and <i class="calibre12">P</i><sub class="calibre15">r</sub>. Then, split the key into two 48-byte halves: <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12">K</i><sub class="calibre15">r</sub>.</p>

<p class="math-left"><i class="calibre12">P</i> = <i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">P</i><sub class="calibre15">r</sub>
<i class="calibre12">K</i> = <i class="calibre12">K</i><sub class="calibre15">1</sub>, <i class="calibre12">K</i><sub class="calibre15">r</sub>
</p>

<p class="calibre9">Append <i class="calibre12">K</i><sub class="calibre15">1</sub> to <i class="calibre12">P</i><sub class="calibre15">1</sub> and hash it with a one-way hash function, then XoR the result of the hash with <i class="calibre12">P</i><sub class="calibre15">r</sub> to produce <i class="calibre12">C</i><sub class="calibre15">r</sub>, the right half of the ciphertext. Then, append <i class="calibre12">K</i><sub class="calibre15">r</sub> to <i class="calibre12">C</i><sub class="calibre15">r</sub> and hash it with the one-way hash function. XOR the result with <i class="calibre12">P</i><sub class="calibre15">1</sub> to produce <i class="calibre12">C</i><sub class="calibre15">1</sub>. Finally, append C<sub class="calibre15">r</sub> to <i class="calibre12">C</i><sub class="calibre15">1</sub> to produce the ciphertext.</p>

<p class="math-left"><i class="calibre12">C</i><sub class="calibre15">r</sub> = <i class="calibre12">P</i><sub class="calibre15">r</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">K</i><sub class="calibre15">1</sub>)
<i class="calibre12">C</i><sub class="calibre15">1</sub> = <i class="calibre12">P</i><sub class="calibre15">1</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">C</i><sub class="calibre15">r</sub>, <i class="calibre12">K</i><sub class="calibre15">r</sub>)
<i class="calibre12">C</i> = <i class="calibre12">C</i><sub class="calibre15">1</sub>, <i class="calibre12">C</i><sub class="calibre15">r</sub>
</p>

<p class="calibre9">To decrypt, simply reverse the process. Append <i class="calibre12">K</i><sub class="calibre15">r</sub> to <i class="calibre12">C</i><sub class="calibre15">r</sub>, hash and XOR with <i class="calibre12">C</i><sub class="calibre15">1</sub> to produce <i class="calibre12">P</i><sub class="calibre15">1</sub>. Append <i class="calibre12">K</i><sub class="calibre15">1</sub> to <i class="calibre12">P</i><sub class="calibre15">1</sub>, hash and XoR with <i class="calibre12">C</i><sub class="calibre15">r</sub> to produce <i class="calibre12">P</i><sub class="calibre15">r</sub>.</p>

<p class="math-left"><i class="calibre12">P</i><sub class="calibre15">1</sub> = <i class="calibre12">C</i><sub class="calibre15">1</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">C</i><sub class="calibre15">r</sub>, <i class="calibre12">K</i><sub class="calibre15">r</sub>)
<i class="calibre12">P</i><sub class="calibre15">r</sub> = <i class="calibre12">C</i><sub class="calibre15">r</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">K</i><sub class="calibre15">1</sub>)
<i class="calibre12">P</i> = <i class="calibre12">P</i><sub class="calibre15">1</sub>, <i class="calibre12">P</i><sub class="calibre15">r</sub>
</p>

<p class="calibre9">The overall structure of Karn is the same as many of the other block
algorithms discussed in this section. It has only two rounds, because the
complexity of the algorithm is embedded in the one-way hash function. And
since the key is used only as the input to the hash function, it cannot be
recovered even using a chosen-plaintext attack — assuming, of course, that the
one-way hash function is secure.</p>

<h4 class="calibre8">Luby-Rackoff</h4>

<p class="calibre9">Michael Luby and Charles Rackoff showed that Karn is not secure [<a href="Applied%20Cryptography_split_036.html#r992" class="calibre5 pcalibre">992</a>].
Consider two single-block messages: <i class="calibre12">AB</i> and <i class="calibre12">AC</i>. If a cryptanalyst knows both the plaintext and the ciphertext of the first message, and knows the first half of
the plaintext of the second message, then he can easily compute the entire
second message. This known-plaintext attack is useful only in certain
circumstances, but it is a major security problem.</p>

<p class="calibre9">A three-round encryption algorithm avoids this problem [<a href="Applied%20Cryptography_split_036.html#r992" class="calibre5 pcalibre">992</a>,<a href="Applied%20Cryptography_split_036.html#r1643" class="calibre5 pcalibre">1643</a>,<a href="Applied%20Cryptography_split_036.html#r1644" class="calibre5 pcalibre">1644</a>]. It
uses three different hash functions: <i class="calibre12">H</i><sub class="calibre15">1</sub>, <i class="calibre12">H</i><sub class="calibre15">2</sub>, and <i class="calibre12">H</i><sub class="calibre15">3</sub>. Further work shows that <i class="calibre12">H</i><sub class="calibre15">1</sub> can equal <i class="calibre12">H</i><sub class="calibre15">2</sub>, or that <i class="calibre12">H</i><sub class="calibre15">2</sub> can equal <i class="calibre12">H</i><sub class="calibre15">3</sub>, but not both [<a href="Applied%20Cryptography_split_036.html#r1193" class="calibre5 pcalibre">1193</a>]. Also, <i class="calibre12">H</i><sub class="calibre15">1</sub>, <i class="calibre12">H</i><sub class="calibre15">2</sub>, and <i class="calibre12">H</i><sub class="calibre15">3</sub> cannot be based on iterating the same basic function [<a href="Applied%20Cryptography_split_036.html#r1643" class="calibre5 pcalibre">1643</a>]. Anyway,
assuming that <i class="calibre12">H</i><sub class="calibre15">(<i class="calibre22">k,x</i>)</sub> behaves like a pseudo-random function, here is a
three-round version:</p>

<ol class="calibre17">

<li class="calibre14">Divide the key into two halves: <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12">K</i><sub class="calibre15">r</sub>.
</li>
<li class="calibre14">Divide the plaintext block into two halves: <i class="calibre12">L</i><sub class="calibre15">0</sub> and <i class="calibre12">R</i><sub class="calibre15">0</sub>.
</li>
<li class="calibre14">Append <i class="calibre12">K</i><sub class="calibre15">1</sub> to <i class="calibre12">L</i><sub class="calibre15">0</sub> and hash it. XoR the result of the hash with <i class="calibre12">R</i><sub class="calibre15">0</sub> to produce <i class="calibre12">R</i><sub class="calibre15">1</sub>:
<p class="math"><i class="calibre12">R</i><sub class="calibre15">1</sub> = <i class="calibre12">R</i><sub class="calibre15">0</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">K</i><sub class="calibre15">1</sub>, <i class="calibre12">L</i><sub class="calibre15">0</sub>)
</p>
</li>
<li class="calibre14">Append <i class="calibre12">K</i><sub class="calibre15">r</sub> to <i class="calibre12">R</i><sub class="calibre15">1</sub> and hash it. XOR the result of the hash with <i class="calibre12">L</i><sub class="calibre15">0</sub> to produce <i class="calibre12">L</i><sub class="calibre15">1</sub>:
<p class="math"><i class="calibre12">L</i><sub class="calibre15">1</sub> = <i class="calibre12">L</i><sub class="calibre15">0</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">K</i><sub class="calibre15">r</sub>, <i class="calibre12">R</i><sub class="calibre15">1</sub>)
</p>
</li>
<li class="calibre14">Append <i class="calibre12">K</i><sub class="calibre15">1</sub> to <i class="calibre12">L</i><sub class="calibre15">1</sub> and hash it. XOR the result of the hash with <i class="calibre12">R</i><sub class="calibre15">1</sub> to produce <i class="calibre12">R</i><sub class="calibre15">2</sub>:
<p class="math"><i class="calibre12">R</i><sub class="calibre15">2</sub> = <i class="calibre12">R</i><sub class="calibre15">1</sub> ⊕ <i class="calibre12">H</i>(<i class="calibre12">K</i><sub class="calibre15">1</sub>, <i class="calibre12">L</i><sub class="calibre15">1</sub>)
</p>
</li>
<li class="calibre14">Append <i class="calibre12">L</i><sub class="calibre15">1</sub> to <i class="calibre12">R</i><sub class="calibre15">1</sub> to generate the message.
</li>

</ol>

<h4 class="calibre8">Message Digest Cipher (MDC)</h4>

<p class="calibre9">MDC, invented by Peter Gutmann [<a href="Applied%20Cryptography_split_035.html#r676" class="calibre5 pcalibre">676</a>], is a means of turning one-way hash
functions into a block cipher that runs in CFB mode. The cipher runs almost as
fast as the hash function and is at least as secure as the hash function. The rest
of this section assumes you are familiar with <a href="Applied%20Cryptography_split_021.html#18" class="calibre5 pcalibre">Chapter 18</a>.</p>

<p class="calibre9">Hash functions such as MD5 and SHA use a 512-bit text block to transform an
input value (128 bits with MD5, and 160 bits with SHA) into an output value
of equal size. This transformation is not reversible, but it is perfect for CFB
mode: The same operation is used for both encryption and decryption.</p>

<p class="calibre9">Let’s look at MDC with SHA. MDC has a 160-bit block size and a 512-bit
key. The hash function is run “sideways,” with the old hash state as the input
plaintext block (160 bits) and the 512-bit hash input as a key (see Figure 14.5).
Normally, when using the hash to simply hash some input, the 512-bit input to
the hash is varied as each new 512-bit block is hashed. But in this case the
512-bit input becomes an unchanging key.</p>

<div class="figure" id="figure-14-5">
<div class="image1">
<p class="calibre9"><img src="ac-figure-14-5.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 14.5</b> Message Digest Cipher (MDC).</i></p>
</div>

<p class="calibre9">MDC can be used with any one-way hash function: MD4, MD5, Snefru, and
others. It is unpatented. Anyone can use it at any time, in any way, royalty-free
[<a href="Applied%20Cryptography_split_035.html#r676" class="calibre5 pcalibre">676</a>].</p>

<p class="calibre9">However, I donot trust this construction. It is possible to attack the hash
function in a way that hash functions are not designed to withstand. It is not
important for hash functions to be able to resist a chosen-plaintext attack,
where a cryptanalyst chooses several of those starting 160-bit values, has them
“encrypted” by the same 512-bit “key,” and uses this to learn some
information about the 512-bit key used. Since the designers didnot have to
worry about this, it seems like a bad idea to count on your cipher being able to
resist this attack.</p>

<h4 class="calibre8">Security of Ciphers Based on one-Way Hash Functions</h4>

<p class="calibre9">While these constructions can be secure, they depend on the choice of the
underlying one-way hash function. A good one-way hash function doesnot
necessarily make a secure encryption algorithm. Cryptographic requirements
are different. For example, linear cryptanalysis is not a viable attack against
one-way hash functions, but works against encryption algorithms. A one-way
hash function such as SHA could have linear characteristics which, while not
affecting its security as a one-way hash function, could make it insecure in an
encryption algorithm such as MDC. I know of no cryptanalytic analysis of
particular one-way hash functions as block ciphers; wait for such analysis
before you trust any of them.</p>

<h3 id="14.12" class="calibre7">14.12 Choosing a Block Algorithm</h3>

<p class="calibre9">It’s a tough decision. DES is almost certainly insecure against the major
governments of the world unless you only encrypt very small chunks of data
for a single key. It’s probably all right against anyone else, but that is
changing soon. Brute-force DES key search machines will quickly become
economical for all sorts of organizations.</p>

<p class="calibre9">Biham’s key-dependent S-boxes for DES should be secure for at least a few
years against all but the most well-funded adversaries, and possibly even from
them. If you need security that lasts decades or fear the cryptanalytic efforts of
major governments, use triple-DES with three independent keys.</p>

<p class="calibre9">The other algorithms arenot worthless. I like Blowfish because it is fast and I
wrote it. 3-WAY looks good, and GoST is probably okay. The problem with
any recommendation is that the NSA almost certainly has an array of
impressive cryptanalytic techniques that are still classified, and I do not know
which algorithms they can break with them. Table 14.3 gives timing
measurements for some algorithms. These are meant for comparison purposes
only.</p>

<table class="data-table1" id="table-14-3">
<caption class="calibre67">Table 14.3 - Encryption Speeds of Some Block Ciphers on a 33 MHz 486SX</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Algorithm</th>
<th class="calibre26">Encryption Speed (Kilobytes/second)</th>
<th class="calibre26">Algorithm</th>
<th class="calibre26">Encryption Speed (Kilobytes/second)</th>
</tr>
<tr class="calibre25"><td class="calibre61">Blowfish (12 rounds)</td><td class="calibre77">182</td><td class="calibre61">MDC (using MD4)</td><td class="calibre77">186</td></tr>
<tr class="calibre25"><td class="calibre61">Blowfish (16 rounds)</td><td class="calibre77">135</td><td class="calibre61">MDC (using MD5)</td><td class="calibre77">135</td></tr>
<tr class="calibre25"><td class="calibre61">Blowfish (20 rounds)</td><td class="calibre77">110</td><td class="calibre61">MDC (using SHA)</td><td class="calibre77">23</td></tr>
<tr class="calibre25"><td class="calibre61">DES</td><td class="calibre77">35</td><td class="calibre61">NewDES</td><td class="calibre77">233</td></tr>
<tr class="calibre25"><td class="calibre61">FEAL-8</td><td class="calibre77">300</td><td class="calibre61">REDOC II</td><td class="calibre77">1</td></tr>
<tr class="calibre25"><td class="calibre61">FEAL-16</td><td class="calibre77">161</td><td class="calibre61">REDOC III</td><td class="calibre77">78</td></tr>
<tr class="calibre25"><td class="calibre61">FEAL-32</td><td class="calibre77">91</td><td class="calibre61">RC5-32/8</td><td class="calibre77">127</td></tr>
<tr class="calibre25"><td class="calibre61">GOST</td><td class="calibre77">53</td><td class="calibre61">RC5-32/12</td><td class="calibre77">86</td></tr>
<tr class="calibre25"><td class="calibre61">IDEA</td><td class="calibre77">70</td><td class="calibre61">RC5-32/16</td><td class="calibre77">65</td></tr>
<tr class="calibre25"><td class="calibre61">Khufu (16 rounds)</td><td class="calibre77">221</td><td class="calibre61">RC5-32/20</td><td class="calibre77">52</td></tr>
<tr class="calibre25"><td class="calibre61">Khufu (24 rounds)</td><td class="calibre77">153</td><td class="calibre61">SAFER (6 rounds)</td><td class="calibre77">81</td></tr>
<tr class="calibre25"><td class="calibre61">Khufu (32 rounds)</td><td class="calibre77">115</td><td class="calibre61">SAFER (8 rounds)</td><td class="calibre77">61</td></tr>
<tr class="calibre25"><td class="calibre61">Luby-Rackoff (using MD4)</td><td class="calibre77">47</td><td class="calibre61">SAFER (10 rounds)</td><td class="calibre77">49</td></tr>
<tr class="calibre25"><td class="calibre61">Luby-Rackoff (using MD5)</td><td class="calibre77">34</td><td class="calibre61">SAFER (12 rounds)</td><td class="calibre77">41</td></tr>
<tr class="calibre71"><td class="calibre78">Luby-Rackoff (using SHA)</td><td class="calibre79">11</td><td class="calibre78">3-Way</td><td class="calibre79">25</td></tr>
<tr class="calibre25"><td class="calibre61">Lucifer</td><td class="calibre77">52</td><td class="calibre61">Triple-DES</td><td class="calibre77">12</td></tr>
</tbody></table>

<p class="calibre39">My favorite algorithm is IDEA. Its 128-bit key, combined with its resistance to
any public means of cryptanalysis, gives me a warm, fuzzy feeling about the
algorithm. The algorithm has been analyzed by a lot of different groups, and
no serious results have been announced yet. Barring extraordinary
cryptanalytic news tomorrow, I am betting on IDEA today.</p>

<div class="calibre6" id="calibre_pb_34"></div>
</div>






</body></html>
