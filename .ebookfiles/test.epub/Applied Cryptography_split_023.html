<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="20">Chapter 20 <br class="calibre3"/>
Public-Key Digital Signature Algorithms</h1>

<h3 id="20.1" class="calibre7">20.1 Digital Signature Algorithm (DSA)</h3>

<p class="calibre9">In August 1991, The National Institute of Standards and Technology (NIST)
proposed the Digital Signature Algorithm (DSA) for use in their Digital
Signature Standard (DSS). According to the <i class="calibre12">Federal Register</i> [<a href="Applied%20Cryptography_split_035.html#r538" class="calibre5 pcalibre">538</a>]:</p>

<p class="quote">A Federal Information Processing Standard (FIPS) for Digital
Signature Standard (DSS) is being proposed. This proposed
standard specifies a public-key digital signature algorithm (DSA)
appropriate for Federal digital signature applications. The
proposed DSS uses a public key to verify to a recipient the
integrity of data and identity of the sender of the data. The DSS
can also be used by a third party to ascertain the authenticity of a
signature and the data associated with it.
<br class="calibre3"/><br class="calibre3"/>
This proposed standard adopts a public-key signature scheme that
uses a pair of transformations to generate and verify a digital
value called a signature.</p>

<p class="calibre9">And:</p>

<p class="quote">This proposed FIPS is the result of evaluating a number of
alternative digital signature techniques. In making the selection
NIST has followed the mandate contained in section 2 of the
Computer Security Act of 1987 that NIST develop standards to
“...assure the cost-effective security and privacy of Federal
information and, among technologies offering comparable
protection, on selecting the option with the most desirable
operating and use characteristics.”
<br class="calibre3"/><br class="calibre3"/>
Among the factors that were considered during this process were
the level of security provided, the ease of implementation in both
hardware and software, the ease of export from the U.S., the
applicability of patents, impact on national security and law
enforcement and the level of efficiency in both the signing and
verification functions. A number of techniques were deemed to
provide appropriate protection for Federal systems. The technique
selected has the following desirable characteristics:
<br class="calibre3"/><br class="calibre3"/>
NIST expects it to be available on a royalty-free basis. Broader
use of this technique resulting from public availability should be
an economic benefit to the government and the public.
<br class="calibre3"/><br class="calibre3"/>
The technique selected provides for efficient implementation of
the signature operations in smart card applications. In these
applications the signing operations are performed in the
computationally modest environment of the smart card while the
verification process is implemented in a more computationally
rich environment such as a personal computer, a hardware
cryptographic module, or a mainframe computer.</p>

<p class="calibre9">Before it gets too confusing, let me review the nomenclature: DSA is the
algorithm; the DSS is the standard. The standard employs the algorithm. The
algorithm is part of the standard.</p>

<h4 class="calibre8">Reaction to the Announcement</h4>

<p class="calibre9">NIST’s announcement created a maelstrom of criticisms and accusations.
Unfortunately, it was more political than academic. RSA Data Security, Inc.,
purveyors of the RSA algorithm, led the criticism against DSS. They wanted
RSA, and not another algorithm, used as the standard. RSADSI makes a lot of
money licensing the RSA algorithm, and a royalty-free digital signature
standard would directly affect their bottom line. (Note: DSA is not necessarily
free of patent infringements; I’ll discuss that later.)</p>

<p class="calibre9">Before the algorithm was announced, RSADSI campaigned against a
“common modulus,” which might have given the government the ability to
forge signatures. When the algorithm was announced without this common
modulus, they attacked it on other grounds [<a href="Applied%20Cryptography_split_035.html#r154" class="calibre5 pcalibre">154</a>], both in letters to NIST and
statements to the press. (Four letters to NIST appeared in [<a href="Applied%20Cryptography_split_036.html#r1326" class="calibre5 pcalibre">1326</a>]. When
reading them, keep in mind that at least two of the authors, Rivest and
Hellman, had a financial interest in DSS’s not being approved.)</p>

<p class="calibre9">Many large software companies that already licensed the RSA algorithm came
out against the DSS. In 1982, the government had solicited public-key
algorithms for a standard [<a href="Applied%20Cryptography_split_035.html#r537" class="calibre5 pcalibre">537</a>]. After that, there wasn’t a peep out of NIST for
nine years. Companies such as IBM, Apple, Novell, Lotus, Northern Telecom,
Microsoft, DEC, and Sun had already spent large amounts of money
implementing the RSA algorithm. They were not interested in losing their
investment.</p>

<p class="calibre9">In all, NIST received 109 comments by the end of the first comment period on
February 28, 1992.</p>

<p class="calibre9">Let’s look at the criticisms against DSA, one by one.</p>

<ol class="calibre17">

<li class="calibre14">DSA cannot be used for encryption or key distribution.
<p class="calibre9">True, but not the point of the standard. This is a signature standard.
NIST should have a standard for public-key encryption. NIST is
committing a grave injustice to the American people by not
implementing a public-key encryption standard. It is suspicious that this
proposed digital signature standard cannot be used for encryption. (As it
turns out, though, it can — see <a href="Applied%20Cryptography_split_026.html#23.3" class="calibre5 pcalibre">Section 23.3</a>.) That does not mean that a
signature standard is useless.</p>

</li>
<li class="calibre14">DSA was developed by the NSA, and there may be a trapdoor in the
algorithm.
Much of the initial comments were just paranoia: “NIST’s denial of
information with no apparent justification does not inspire confidence in
DSS, but intensifies concern that there is a hidden agenda, such as
laying the groundwork for a national public-key cryptosystem that is in
fact vulnerable to being broken by NIST and/or NSA” [<a href="Applied%20Cryptography_split_035.html#r154" class="calibre5 pcalibre">154</a>]. One
serious question about the security of DSA was raised by Arjen Lenstra
and Stuart Haber at Bellcore. This will be discussed later.
</li>
<li class="calibre14">DSA is slower than RSA [<a href="Applied%20Cryptography_split_035.html#r800" class="calibre5 pcalibre">800</a>].
<p class="calibre9">True, more or less. Signature generation speeds are the same, but
signature verification can be 10 to 40 times slower with DSA. Key
generation, however, is faster. But key generation is irrelevant; a user
rarely does it. On the other hand, signature verification is the most
common operation.</p>

<p class="calibre9">The problem with this criticism is that there are many ways to play with
the test parameters, depending on the results you want. Precomputations
can speed up DSA signature generation, but don’t always apply.
Proponents of RSA use numbers optimized to make their calculations
easier; proponents of DSA use their own optimizations. In any case,
computers are getting faster all the time. While there is a speed
difference, it will not be noticeable in most applications.</p>

</li>
<li class="calibre14">RSA is a <i class="calibre12">de facto</i> standard.
<p class="calibre9">Here are two examples of this complaint. From Robert Follett, the
program director of standards at IBM [<a href="Applied%20Cryptography_split_035.html#r570" class="calibre5 pcalibre">570</a>]:</p>

<p class="quote">IBM is concerned that NIST has proposed a standard with a
different digital signature scheme rather than adopting the
international standard. We have been convinced by users
and user organizations that the international standards using
RSA will be a prerequisite to the sales of security products
in the very near future.</p>

<p class="calibre9">From Les Shroyer, vice president and director, corporate MIS and
telecommunications, at Motorola [<a href="Applied%20Cryptography_split_036.html#r1444" class="calibre5 pcalibre">1444</a>]:</p>

<p class="quote">We must have a single, robust, politically-accepted digital
signature standard that is usable throughout the world,
between both U.S. and non-U.S., and Motorola and
non-Motorola entities. The lack of other viable digital
signature technology for the last eight years has made RSA
a de facto standard.... Motorola and many other
companies... have committed millions of dollars to RSA.
We have concern over the interoperability and support of
two different standards, as that situation will lead to added
costs, delays in deployment, and complication....</p>

<p class="calibre9">Many companies wanted NIST to adopt the ISO 9796, the international
digital signature standard that uses RSA [<a href="Applied%20Cryptography_split_035.html#r762" class="calibre5 pcalibre">762</a>]. While this is a valid
complaint, it is not a sufficient justification to make it a standard. A
royalty-free standard would better serve the U.S. public interest.</p>

</li>
<li class="calibre14">The DSA selection process was not public; sufficient time for
analysis has not been provided.
<p class="calibre9">First NIST claimed that they designed the DSA; then they admitted that
NSA helped them. Finally, they confirmed that NSA designed the
algorithm. This worries many people; the NSA doesn’t inspire trust.
Even so, the algorithm is public and available for analysis; and NIST
extended the time for analysis and comment.</p>

</li>
<li class="calibre14">DSA may infringe on other patents.
<p class="calibre9">It may. This will be discussed in the section on patent issues.</p>

</li>
<li class="calibre14">The key size is too small.
<p class="calibre9">This was the only valid criticism of DSS. The original implementation
set the modulus at 512 bits [<a href="Applied%20Cryptography_split_036.html#r1149" class="calibre5 pcalibre">1149</a>]. Since the algorithm gets its security
from the difficulty of computing discrete logs in that modulus, this
worried most cryptographers. There have since been advances in the
problem of calculating discrete logarithms in a finite field, and 512 bits
is too short for long-term security (see <a href="Applied%20Cryptography_split_009.html#7.2" class="calibre5 pcalibre">Section 7.2</a>). According to Brian
LaMacchia and Andrew Odlyzko, “...even 512-bit primes appear to
offer only marginal security...” [<a href="Applied%20Cryptography_split_036.html#r934" class="calibre5 pcalibre">934</a>]. In response to this criticism, NIST
made the key size variable, from 512 bits to 1024 bits. Not great, but
better.</p>

</li>

</ol>

<p class="calibre9">On May 19, 1994, the standard was finally issued [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>]. The issuing
statement said [<a href="Applied%20Cryptography_split_035.html#r542" class="calibre5 pcalibre">542</a>]:</p>

<p class="quote">This standard is applicable to all Federal departments and
agencies for the protection of unclassified information.... This
standard shall be used in designing and implementing public-key
based signature schemes which Federal departments and agencies
operate or which are operated for them under contract. Adoption
and use of this standard is available to private and commercial
organizations.</p>

<p class="calibre9">Before you run out and implement this standard in your next product, read the
section on patent issues below.</p>

<h4 class="calibre8">Description of DSA</h4>

<p class="calibre9">DSA is a variant of the Schnorr and ElGamal signature algorithms, and is fully
described in [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>]. The algorithm uses the following parameters:</p>

<p class="math-left"><i class="calibre12">p</i> = a prime number <i class="calibre12">L</i> bits long, when <i class="calibre12">L</i> ranges from 512 to 1024 and is a multiple of 64.
(In the original standard, the size of <i class="calibre12">p</i> was fixed at 512 bits [<a href="Applied%20Cryptography_split_036.html#r1149" class="calibre5 pcalibre">1149</a>]. 
This was the source of much criticism and was changed by NIST [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>].)

<i class="calibre12">q</i> = a 160-bit prime factor of <i class="calibre12">p</i> – 1.

<i class="calibre12">g</i> = <i class="calibre12">h</i><sup class="calibre19">(<i class="calibre22">p</i>-1)/<i class="calibre22">q</i></sup> mod <i class="calibre12">p</i>, where <i class="calibre12">h</i> is any number less than <i class="calibre12">p</i> – 1 such that <i class="calibre12">h</i><sup class="calibre19">(<i class="calibre22">p</i>-1)/<i class="calibre22">q</i></sup> mod <i class="calibre12">p</i> is greater than 1.

x = a number less than <i class="calibre12">q</i>.

<i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>.
</p>

<p class="calibre9">The algorithm also makes use of a one-way hash function: <i class="calibre12">H</i>(<i class="calibre12">m</i>). The standard specifies the Secure Hash Algorithm, discussed in <a href="Applied%20Cryptography_split_021.html#18.7" class="calibre5 pcalibre">Section 18.7</a>.</p>

<p class="calibre9">The first three parameters, <i class="calibre12">p, q</i>, and <i class="calibre12">g</i>, are public and can be common across a network of users. The private key is <i class="calibre12">x</i>; the public key is <i class="calibre12">y</i>.</p>

<p class="calibre9">To sign a message, <i class="calibre12">m</i>:</p>

<ol class="calibre17">

<li class="calibre14">Alice generates a random number, <i class="calibre12">k</i>, less than <i class="calibre12">q</i>.
</li>
<li class="calibre14">Alice generates
<p class="math-left"><i class="calibre12">r</i> = (<i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
 <i class="calibre12">s</i> = (<i class="calibre12">k</i><sup class="calibre19">-1</sup> (<i class="calibre12">H</i>(<i class="calibre12">m</i>) + <i class="calibre12">xr</i>)) mod <i class="calibre12">q</i>
</p>

The parameters <i class="calibre12">r</i> and <i class="calibre12">s</i> are her signature; she sends these to Bob.
</li>
<li class="calibre14">Bob verifies the signature by computing
<p class="math-left"><i class="calibre12">w</i> = <i class="calibre12">s</i><sup class="calibre19">-1</sup> mod <i class="calibre12">q</i>
 <i class="calibre12">u</i><sub class="calibre15">1</sub> = (<i class="calibre12">H</i>(<i class="calibre12">m</i>) * <i class="calibre12">w</i>) mod <i class="calibre12">q</i>
 <i class="calibre12">u</i><sub class="calibre15">2</sub> = (<i class="calibre12">rw</i>) mod <i class="calibre12">q</i>
 <i class="calibre12">v</i> = ((<i class="calibre12">g</i><sup class="calibre19">u<sub class="calibre16">1</sub></sup> * <i class="calibre12">y</i><sup class="calibre19">u<sub class="calibre16">2</sub></sup>) mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
</p>
If <i class="calibre12">v</i> = <i class="calibre12">r</i>, then the signature is verified.
</li>

</ol>

<p class="calibre9">Proofs for the mathematical relationships are found in [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>]. Table 20.1
provides a summary.</p>

<p id="table-20-1" class="calibre9"><b class="calibre10">Table 20.1 - DSA Signatures</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Public Key:</b></i></p>

<p class="math-left"><i class="calibre12">p</i> 512-bit to 1024-bit prime (can be shared among a group of users)
<i class="calibre12">q</i> 160-bit prime factor of <i class="calibre12">p</i> – 1 (can be shared among a group of users)
<i class="calibre12">g</i> = <i class="calibre12">h</i><sup class="calibre19">(<i class="calibre22">p</i> - 1)/<i class="calibre22">q</i></sup> mod <i class="calibre12">p</i>, where <i class="calibre12">h</i> is less than <i class="calibre12">p</i> – 1 and <i class="calibre12">h</i><sup class="calibre19">(<i class="calibre22">p</i> - 1)/<i class="calibre22">q</i></sup> mod <i class="calibre12">p</i> &gt; 1 (can be shared among a group of users)
<i class="calibre12">y</i> = <i class="calibre12">g</i><sup class="calibre19">x</sup> mod <i class="calibre12">p</i> (a p-bit number)
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Private Key:</b></i></p>

<p class="math-left"><i class="calibre12">x</i> &lt; <i class="calibre12">q</i> (a 160-bit number)
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Signing:</b></i></p>

<p class="math-left"><i class="calibre12">k</i> choose at random, less than <i class="calibre12">q</i>
<i class="calibre12">r</i> (signature) = (<i class="calibre12">g</i><sup class="calibre19">k</sup> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
<i class="calibre12">s</i> (signature) = (<i class="calibre12">k</i><sup class="calibre19">-1</sup> (<i class="calibre12">H</i>(<i class="calibre12">m</i>) + <i class="calibre12">xr</i>)) mod <i class="calibre12">q</i>
</p>

<p class="calibre9"><i class="calibre12"><b class="calibre10">Verifying:</b></i></p>

<p class="math-left"><i class="calibre12">w</i> = <i class="calibre12">s</i><sup class="calibre19">-1</sup> mod <i class="calibre12">q</i>
<i class="calibre12">u</i><sub class="calibre15">1</sub> = (<i class="calibre12">H</i>(<i class="calibre12">m</i>) * <i class="calibre12">w</i>) mod <i class="calibre12">q</i>
<i class="calibre12">u</i><sub class="calibre15">2</sub> = (<i class="calibre12">rw</i>) mod <i class="calibre12">q</i>
<i class="calibre12">v</i> = ((<i class="calibre12">g</i><sup class="calibre19">u<sub class="calibre16">1</sub></sup> * <i class="calibre12">y</i><sup class="calibre19">u<sub class="calibre16">2</sub></sup>) mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
If <i class="calibre12">v</i> = <i class="calibre12">r</i>, then the signature is verified.
</p>

<hr class="calibre63"/>

<h4 class="calibre8">Speed Precomputations</h4>

<p class="calibre9">Table 20.2 gives sample software speeds of DSA [<a href="Applied%20Cryptography_split_036.html#r918" class="calibre5 pcalibre">918</a>].</p>

<table class="data-table1" id="table-20-2">
<caption class="calibre67">Table 20.2 - DSA Speeds for Different Modulus Lengths with a 160-bit Exponent (on a SPARC II)</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">
</th><th class="calibre26">512 bits</th>
<th class="calibre26">768 bits</th>
<th class="calibre26">1024 bits</th>
</tr>
<tr class="calibre71"><td class="calibre72">Sign</td><td class="calibre72">0.20 sec</td><td class="calibre72">0.43 sec</td><td class="calibre72">0.57 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Verify</td><td class="calibre70">0.35 sec</td><td class="calibre70">0.80 sec</td><td class="calibre70">1.27 sec</td></tr>
</tbody></table>

<p class="calibre39">Real-world implementations of DSA can often be speeded up through
precomputations. Notice that the value <i class="calibre12">r</i> does not depend on the message. You
can create a string of random <i class="calibre12">k</i> values, and then precompute <i class="calibre12">r</i> values for each of them. You can also precompute <i class="calibre12">k</i><sup class="calibre19">-1</sup> for each of those <i class="calibre12">k</i> values. Then, when a message comes along, you can compute <i class="calibre12">s</i> for a given <i class="calibre12">r</i> and <i class="calibre12">k</i><sup class="calibre19">-1</sup>.</p>

<p class="calibre9">This precomputation speeds up DSA considerably. Table 20.3 is a comparison
of DSA and RSA computation times for a particular smart card
implementation [<a href="Applied%20Cryptography_split_036.html#r1479" class="calibre5 pcalibre">1479</a>].</p>

<table class="data-table1" id="table-20-3">
<caption class="calibre67">Table 20.3 - Comparison of RSA and DSA Computation Times</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">
</th><th class="calibre26">DSA</th>
<th class="calibre26">RSA</th>
<th class="calibre26">DSA with Common <i class="calibre12">p, q, g</i></th>
</tr>
<tr class="calibre25"><td class="calibre70">Global Computations</td><td class="calibre70">Off-card (P)</td><td class="calibre70">N/A</td><td class="calibre70">Off-card (P)</td></tr>
<tr class="calibre25"><td class="calibre70">Key Generation</td><td class="calibre70">14 sec</td><td class="calibre70">Off-card (S)</td><td class="calibre70">4 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Precomputation</td><td class="calibre70">14 sec</td><td class="calibre70">N/A</td><td class="calibre70">4 sec</td></tr>
<tr class="calibre25"><td class="calibre70">Signature</td><td class="calibre70">.03 sec</td><td class="calibre70">15 sec</td><td class="calibre70">.03 sec</td></tr>
<tr class="calibre71"><td class="calibre72">Verification</td><td class="calibre72">16 sec</td><td class="calibre72">1.5 sec</td><td class="calibre72">10 sec</td></tr>
<tr class="calibre25"><td class="calibre70"/><td class="calibre70">1–5 sec off-card (P)</td><td class="calibre70">1–3 sec off-card (P)</td><td class="calibre70"/></tr>
</tbody></table>
<p class="calibre39">Off-card computations were performed on an 80386 33 MHz, personal computer. (P)
indicates public parameters off-card and (S) indicates secret parameters off-card. Both algorithms use a 512-bit modulus.</p>

<h4 class="calibre8">DSA Prime Generation</h4>

<p class="calibre9">Lenstra and Haber pointed out that certain moduli are much easier to crack
than others [<a href="Applied%20Cryptography_split_036.html#r950" class="calibre5 pcalibre">950</a>]. If someone forced a network to use one of these “cooked”
moduli, then their signatures would be easier to forge. This isn’t a problem for
two reasons: These moduli are easy to detect and they are so rare that the
chances of using one when choosing a modulus randomly are almost
negligible — smaller, in fact, than the chances of accidentally generating a
composite number using a probabilistic prime generation routine.</p>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>] NIST recommended a specific method for generating the two
primes, <i class="calibre12">p</i> and <i class="calibre12">q</i>, where <i class="calibre12">q</i> divides <i class="calibre12">p</i> - 1. The prime <i class="calibre12">p</i> is <i class="calibre12">L</i> bits long, between 512
and 1024 bits long, in some multiple of 64 bits. The prime <i class="calibre12">q</i> is 160 bits long.
Let <i class="calibre12">L</i> - 1 = 160<i class="calibre12">n</i> + <i class="calibre12">b</i>, where <i class="calibre12">L</i> is the length of <i class="calibre12">p</i>, and <i class="calibre12">n</i> and <i class="calibre12">b</i> are two numbers and <i class="calibre12">b</i> is less than 160.</p>

<ol class="calibre17">

<li class="calibre14">Choose an arbitrary sequence of at least 160 bits and call it <i class="calibre12">S</i>. Let <i class="calibre12">g</i> be the length of <i class="calibre12">S</i> in bits.
</li>
<li class="calibre14">Compute <i class="calibre12">U</i> = SHA(<i class="calibre12">S</i>) ⊕ SHA((<i class="calibre12">S</i> + 1) mod 2<sup class="calibre19"><i class="calibre22">g</i></sup>), where SHA is the Secure Hash Algorithm (see <a href="Applied%20Cryptography_split_021.html#18.7" class="calibre5 pcalibre">Section 18.7</a>).
</li>
<li class="calibre14">Form <i class="calibre12">q</i> by setting the most significant bit and the least significant bit of <i class="calibre12">U</i> to 1.
</li>
<li class="calibre14">Check whether <i class="calibre12">q</i> is prime.
</li>
<li class="calibre14">If <i class="calibre12">q</i> is not prime, go back to step (1).
</li>
<li class="calibre14">Let <i class="calibre12">C</i> = 0 and <i class="calibre12">N</i> = 2.
</li>
<li class="calibre14">For <i class="calibre12">k</i> = 0, 1,..., <i class="calibre12">n</i>, let <i class="calibre12">V</i><sub class="calibre15">k</sub> = SHA((<i class="calibre12">S</i> + <i class="calibre12">N</i> + <i class="calibre12">k</i>) mod 2<sup class="calibre19"><i class="calibre22">g</i></sup>)
</li>
<li class="calibre14">Let <i class="calibre12">W</i> be the integer
<p class="math"><i class="calibre12">W</i> = <i class="calibre12">V</i><sub class="calibre15">0</sub> + 2<sup class="calibre19">160</sup> <i class="calibre12">V</i><sub class="calibre15">1</sub> +...+ 2<sup class="calibre19">160(<i class="calibre22">n</i> - 1)</sup> <i class="calibre12">V</i><sub class="calibre15">n - 1</sub> + 2<sup class="calibre19">160 <i class="calibre22">n</i></sup>(<i class="calibre12">V</i><sub class="calibre15">n</sub> mod 2<sup class="calibre19"><i class="calibre22">b</i></sup>)
</p>
and let
<p class="math"><i class="calibre12">X</i> = <i class="calibre12">W</i> + 2<sup class="calibre19"><i class="calibre22">L</i> - 1</sup>
</p>
Note that <i class="calibre12">X</i> is an <i class="calibre12">L</i>-bit number.
</li>
<li class="calibre14">Let <i class="calibre12">p</i> = <i class="calibre12">X</i> - ((<i class="calibre12">X</i> mod 2<i class="calibre12">q</i>) - 1). Note that <i class="calibre12">p</i> is congruent to 1 mod 2<i class="calibre12">q</i>.
</li>
<li class="calibre14">If <i class="calibre12">p</i> &lt; 2<sup class="calibre19"><i class="calibre22">L</i> - 1</sup>, then go to step (13).
</li>
<li class="calibre14">Check whether <i class="calibre12">p</i> is prime.
</li>
<li class="calibre14">If <i class="calibre12">p</i> is prime, go to step (15).
</li>
<li class="calibre14">Let <i class="calibre12">C</i> = <i class="calibre12">C</i> + 1 and <i class="calibre12">N</i> = <i class="calibre12">N</i> + <i class="calibre12">n</i> + 1.
</li>
<li class="calibre14">If <i class="calibre12">C</i> = 4096, then go to step (1). Otherwise, go to step (7).
</li>
<li class="calibre14">Save the value of <i class="calibre12">S</i> and the value of <i class="calibre12">C</i> used to generate <i class="calibre12">p</i> and <i class="calibre12">q</i>.
</li>

</ol>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>], the variable <i class="calibre12">S</i> is called the “seed,” <i class="calibre12">C</i> is called the “counter,” and <i class="calibre12">N</i>
the “offset.”</p>

<p class="calibre9">The point of this exercise is that there is a public means of generating <i class="calibre12">p</i> and <i class="calibre12">q</i>.
For all practical purposes, this method prevents cooked values of <i class="calibre12">p</i> and <i class="calibre12">q</i>. If someone hands you a <i class="calibre12">p</i> and a <i class="calibre12">q</i>, you might wonder where that person got them.
However, if someone hands you a value for <i class="calibre12">S</i> and <i class="calibre12">C</i> that generated the random <i class="calibre12">p</i> and <i class="calibre12">q</i>, you can go through this routine yourself. Using a one-way hash function, SHA in the standard, prevents someone from working backwards
from a <i class="calibre12">p</i> and <i class="calibre12">q</i> to generate an <i class="calibre12">S</i> and <i class="calibre12">C</i>.</p>

<p class="calibre9">This security is better than what you get with RSA. In RSA, the prime
numbers are kept secret. Someone could generate a fake prime or one of a
special form that makes factoring easier. Unless you know the private key, you
won’t know that. Here, even if you don’t know a person’s private key, you can
confirm that <i class="calibre12">p</i> and <i class="calibre12">q</i> have been generated randomly.</p>

<h4 class="calibre8">ElGamal Encryption with DSA</h4>

<p class="calibre9">There have been allegations that the government likes the DSA because it is
only a digital signature algorithm and can’t be used for encryption. It is,
however, possible to use the DSA function call to do ElGamal encryption.</p>

<p class="calibre9">Assume that the DSA algorithm is implemented with a single function call:</p>

<pre class="calibre20">DSAsign(p,q,g,k,x,h,r,s)
</pre>

<p class="calibre9">You supply the numbers <i class="calibre12">p, q, g, k, x</i>, and <i class="calibre12">h</i>, and the function returns the signature parameters: <i class="calibre12">r</i> and <i class="calibre12">s</i>.</p>

<p class="calibre9">To do ElGamal encryption of message <i class="calibre12">m</i> with public key <i class="calibre12">y</i>, choose a random number, <i class="calibre12">k</i>, and call</p>

<pre class="calibre20">DSAsign(p,p,g,k,0,0,r,s)
</pre>

<p class="calibre9">The value of <i class="calibre12">r</i> returned is <i class="calibre12">a</i> in the ElGamal scheme. Throw <i class="calibre12">s</i> away. Then, call</p>

<pre class="calibre20">DSAsign(p,p,y,k,0,0,r,s)
</pre>

<p class="calibre9">Rename the value of <i class="calibre12">r</i> to be <i class="calibre12">u</i>; throw <i class="calibre12">s</i> away. Call</p>

<pre class="calibre20">DSAsign(p,p,m,1,u,0,r,s)
</pre>

<p class="calibre9">Throw <i class="calibre12">r</i> away. The value of <i class="calibre12">s</i> returned is <i class="calibre12">b</i> in the ElGamal scheme. You now have the ciphertext, <i class="calibre12">a</i> and <i class="calibre12">b</i>.</p>

<p class="calibre9">Decryption is just as easy. Using secret key <i class="calibre12">x</i>, and ciphertext messages <i class="calibre12">a</i> and <i class="calibre12">b</i>, call</p>

<pre class="calibre20">DSAsign(p,p,a,x,0,0,r,s)
</pre>

<p class="calibre9">The value <i class="calibre12">r</i> is <i class="calibre12">a<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>. Call that <i class="calibre12">e</i>. Then call</p>

<pre class="calibre20">DSAsign(p,p,1,e,b,0,r,s)
</pre>

<p class="calibre9">The value <i class="calibre12">s</i> is the plaintext message, <i class="calibre12">m</i>.</p>

<p class="calibre9">This method will not work with all implementations of DSA. Some may fix
the values of <i class="calibre12">p</i> and <i class="calibre12">q</i>, or the lengths of some of the other parameters. Still, if the implementation is general enough, this is a way to encrypt using nothing
more than digital signature function.</p>

<h4 class="calibre8">RSA Encryption with DSA</h4>

<p class="calibre9">RSA encryption is even easier. With a modulus <i class="calibre12">n</i>, message <i class="calibre12">m</i>, and public key <i class="calibre12">e</i>, call</p>

<pre class="calibre20">DSAsign(n,n,m,e,0,0,r,s)
</pre>

<p class="calibre9">The value of <i class="calibre12">r</i> returned is the ciphertext.</p>

<p class="calibre9">RSA decryption is the same thing. If <i class="calibre12">d</i> is the private key, then</p>

<pre class="calibre20">DSAsign(n,n,m,d,0,0,r,s)
</pre>

<p class="calibre9">returns the plaintext as the value of <i class="calibre12">r</i>.</p>

<h4 class="calibre8">Security of DSA</h4>

<p class="calibre9">At 512-bits, DSA wasn’t strong enough for long-term security. At 1024 bits, it
is.</p>

<p class="calibre9">The NSA, in its first public interview on the subject, commented to Joe
Abernathy of <i class="calibre12">The Houston Chronicle</i> on allegations about a trapdoor in DSS
[<a href="Applied%20Cryptography_split_035.html#r363" class="calibre5 pcalibre">363</a>]:</p>

<p class="quote">Regarding the alleged trapdoor in the DSS. We find the term
trapdoor somewhat misleading since it implies that the messages
sent by the DSS are encrypted and with access via a trapdoor one
could somehow decrypt (read) the message without the sender’s
knowledge.
<br class="calibre3"/><br class="calibre3"/>
The DSS does not encrypt any data. The real issue is whether the
DSS is susceptible to someone forging a signature and therefore
discrediting the entire system. We state categorically that the
chances of anyone — including NSA — forging a signature with the
DSS when it is properly used and implemented is infinitesimally
small.
<br class="calibre3"/><br class="calibre3"/>
Furthermore, the alleged trapdoor vulnerability is true for <i class="calibre12">any</i>
public key-based authentication system, including RSA. To imply
somehow that this only affects the DSS (a popular argument in
the press) is totally misleading. The issue is one of
implementation and how one goes about selecting prime numbers.
We call your attention to a recent EUROCRYPT conference
which had a panel discussion on the issue of trapdoors in the
DSS. Included on the panel was one of the Bellcore researchers
who initially raised the trapdoor allegation, and our understanding
is that the panel — including the person from Bellcore — concluded
that the alleged trapdoor was not an issue for the DSS.
Furthermore, the general consensus appeared to be that the
trapdoor issue was trivial and had been overblown in the press.
However, to try to respond to the trapdoor allegation, at NIST’s
request, we have designed a prime generation process which will
ensure that one can avoid selection of the relatively few weak
primes which could lead to weakness in using the DSS.
Additionally, NIST intends to allow for larger modulus sizes up
to 1024 which effectively negates the need to even use the prime
generation process to avoid weak primes. An additional very
important point that is often overlooked is that with the DSS the
primes are <i class="calibre12">public</i> and therefore can be subject to public
examination. Not all public key systems provide for this same
type of examination.
<br class="calibre3"/><br class="calibre3"/>
The integrity of any information security system requires
attention to proper implementation. With the myriad of
vulnerabilities possible given the differences among users, NSA
has traditionally insisted on centralized trusted centers as a way to
minimize risk to the system. While we have designed technical
modifications to the DSS to meet NIST’s requests for a more
decentralized approach, we still would emphasize that portion of
the <i class="calibre12">Federal Register</i> notice for the DSS which states:
<br class="calibre3"/><br class="calibre3"/>
<i class="calibre12">“While it is the intent of this standard to specify
general security requirements for generating digital
signatures, conformance to this standard does not
assure that a particular implementation is secure. The
responsible authority in each agency or department
shall assure that an overall implementation provides
an acceptable level of security. NIST will be working
with government users to ensure appropriate
implementations.”</i>
<br class="calibre3"/><br class="calibre3"/>
Finally, we have read all the arguments purporting insecurities
with the DSS, and we remain unconvinced of their validity. The
DSS has been subjected to intense evaluation within NSA which
led to its being endorsed by our Director of Information Systems
Security for use in signing unclassified data processed in certain
intelligence systems and even for signing classified data in
selected systems. We believe that this approval speaks to the lack
of any credible attack on the integrity provided by the DSS given
proper use and implementation. Based on the technical and
security requirements of the U.S. government for digital
signatures, we believe the DSS is the best choice. In fact, the DSS
is being used in a pilot project for the Defense Message System to
assure the authenticity of electronic messages of vital command
and control information. This initial demonstration includes
participation from the Joint Chiefs of Staff, the military services,
and Defense Agencies and is being done in cooperation with
NIST.</p>

<p class="calibre9">I’m not going to comment on the trustworthiness of the NSA. Take their
comments for what you think they’re worth.</p>

<h4 class="calibre8">Attacks against k</h4>

<p class="calibre9">Each signature requires a new value of <i class="calibre12">k</i>, and that value must be chosen
randomly. If Eve ever recovers a <i class="calibre12">k</i> that Alice used to sign a message, perhaps
by exploiting some properties of the random-number generator that generated
<i class="calibre12">k</i>, she can recover Alice’s private key, <i class="calibre12">x</i>. If Eve ever gets two messages signed 
using the same <i class="calibre12">k</i>, even if she doesn’t know what it is, she can recover <i class="calibre12">x</i>. And 
with <i class="calibre12">x</i>, Eve can generate undetectable forgeries of Alice’s signature. In any
implementation of the DSA, a good random-number generator is essential to
the system’s security [<a href="Applied%20Cryptography_split_036.html#r1468" class="calibre5 pcalibre">1468</a>].</p>

<h4 class="calibre8">Dangers of a Common Modulus</h4>

<p class="calibre9">Even though the DSS does not specify a common modulus to be shared by
everyone, different implementations may. For example, the Internal Revenue
Service is considering using the DSS for the electronic submission of tax
returns. What if they require every taxpayer in the country to use a common <i class="calibre12">p</i>
and <i class="calibre12">q</i>? Even though the standard doesn’t require a common modulus, such an
implementation accomplishes the same thing. A common modulus too easily
becomes a tempting target for cryptanalysis. It is still too early to tell much
about different DSS implementations, but there is some cause for concern.</p>

<h4 class="calibre8">Subliminal Channel in DSA</h4>

<p class="calibre9">Gus Simmons discovered a subliminal channel in DSA [<a href="Applied%20Cryptography_split_036.html#r1468" class="calibre5 pcalibre">1468</a>,<a href="Applied%20Cryptography_split_036.html#r1469" class="calibre5 pcalibre">1469</a>] (see
<a href="Applied%20Cryptography_split_026.html#23.3" class="calibre5 pcalibre">Section 23.3</a>). This subliminal channel allows someone to embed a secret
message in his signature that can only be read by another person who knows
the key. According to Simmons, it is a “remarkable coincidence” that the
“apparently inherent shortcomings of subliminal channels using the ElGamal
scheme can all be overcome” in the DSS, and that the DSS “provides the most
hospitable setting for subliminal communications discovered to date.” NIST
and NSA have not commented on this subliminal channel; no one knows if
they even knew about it. Since this subliminal channel allows an unscrupulous
implementer of DSS to leak a piece of the private key with each signature, it is
important to never use an implementation of DSS if you don’t trust the
implementer.</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">David Kravitz, formerly of the NSA, holds a patent on DSA [<a href="Applied%20Cryptography_split_036.html#r897" class="calibre5 pcalibre">897</a>]. According
to NIST [<a href="Applied%20Cryptography_split_035.html#r538" class="calibre5 pcalibre">538</a>]:</p>

<p class="quote">NIST intends to make this DSS technique available world-wide
on a royalty-free basis to the public interest. We believe this
technique is patentable and that no other patents would apply to
the DSS, but we cannot give firm assurances to such effect in
advance of issuance of the patent.</p>

<p class="calibre9">Even so, three patent holders claim that the DSA infringes on their patents:
Diffie-Hellman (see <a href="Applied%20Cryptography_split_025.html#22.1" class="calibre5 pcalibre">Section 22.1</a>) [<a href="Applied%20Cryptography_split_035.html#r718" class="calibre5 pcalibre">718</a>], Merkle-Hellman (see <a href="Applied%20Cryptography_split_022.html#19.2" class="calibre5 pcalibre">Section 19.2</a>)
[<a href="Applied%20Cryptography_split_035.html#r720" class="calibre5 pcalibre">720</a>], and Schnorr (see <a href="Applied%20Cryptography_split_024.html#21.3" class="calibre5 pcalibre">Section 21.3</a>) [<a href="Applied%20Cryptography_split_036.html#r1398" class="calibre5 pcalibre">1398</a>]. The Schnorr patent is the most
troublesome. The other two patents expire in 1997; the Schnorr patent is valid
until 2008. The Schnorr algorithm was not developed with government money;
unlike the PKP patents, the U.S. government has no rights to the Schnorr
patent; and Schnorr patented his algorithm worldwide. Even if the U.S. courts
rule in favor of DSA, it is unclear what other courts around the world would
do. Is an international company going to adopt a standard that may be legal in
some countries but infringes on a patent in others? This issue will take time to
resolve; at the time of this writing it isn’t even resolved in the United States.</p>

<p class="calibre9">In June 1993 NIST proposed to give PKP an exclusive patent license to DSA
[<a href="Applied%20Cryptography_split_035.html#r541" class="calibre5 pcalibre">541</a>]. The agreement fell through after public outcry and the standard was
issued without any deal. NIST said [<a href="Applied%20Cryptography_split_035.html#r542" class="calibre5 pcalibre">542</a>]:</p>

<p class="quote">...NIST has addressed the possible patent infringement claims,
and has concluded that there are no valid claims.</p>

<p class="calibre9">So the standard is official, lawsuits are threatened, and no one knows what to
do. NIST has said that it would help defend people sued for patent
infringement, if they were using DSA to satisfy a government contract.
Everyone else, it seems, is on their own. ANSI has a draft banking standard
that uses DSA [<a href="Applied%20Cryptography_split_035.html#r60" class="calibre5 pcalibre">60</a>]. NIST is working to standardize DSA within the
government. Shell Oil has made DSA their international standard. I know of
no other proposed DSA standards.</p>

<h3 id="20.2" class="calibre7">20.2 DSA Variants</h3>

<p class="calibre9">This variant makes computation easier on the signer by not forcing him to
compute <i class="calibre12">k</i><sup class="calibre19">-1</sup> [<a href="Applied%20Cryptography_split_036.html#r1135" class="calibre5 pcalibre">1135</a>]. All the parameters are as in DSA. To sign a message, <i class="calibre12">m</i>, Alice generates two random numbers, <i class="calibre12">k</i> and <i class="calibre12">d</i>, both less than <i class="calibre12">q</i>. The signature is</p>

<p class="math-left"><i class="calibre12">r</i> = (<i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
<i class="calibre12">s</i> = (<i class="calibre12">H</i>(<i class="calibre12">m</i>) + <i class="calibre12">xr</i>) * <i class="calibre12">d</i> mod <i class="calibre12">q</i>
<i class="calibre12">t</i> = <i class="calibre12">kd</i> mod <i class="calibre12">q</i>
</p>

<p class="calibre9">Bob verifies the signature by computing</p>

<p class="math-left"><i class="calibre12">w</i> = <i class="calibre12">t</i>/<i class="calibre12">s</i> mod <i class="calibre12">q</i>
<i class="calibre12">u</i><sub class="calibre15">1</sub> = (<i class="calibre12">H</i>(<i class="calibre12">m</i>) * <i class="calibre12">w</i>) mod <i class="calibre12">q</i>
<i class="calibre12">u</i><sub class="calibre15">2</sub> = (<i class="calibre12">rw</i>) mod <i class="calibre12">q</i>
</p>

<p class="calibre9">If <i class="calibre12">r</i> = ((<i class="calibre12">g</i><sup class="calibre19">u<sub class="calibre16">1</sub></sup> * <i class="calibre12">y</i><sup class="calibre19">u<sub class="calibre16">2</sub></sup>) mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>, then the signature is verified.</p>

<p class="calibre9">This next variant makes computation easier on the verifier [<a href="Applied%20Cryptography_split_036.html#r1040" class="calibre5 pcalibre">1040</a>,<a href="Applied%20Cryptography_split_036.html#r1629" class="calibre5 pcalibre">1629</a>]. All
the parameters are as in DSA. To sign a message, <i class="calibre12">m</i>, Alice generates a random
number, <i class="calibre12">k</i>, less than <i class="calibre12">q</i>. The signature is</p>

<p class="math-left"><i class="calibre12">r</i> = (<i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
<i class="calibre12">s</i> = <i class="calibre12">k</i> * (<i class="calibre12">H</i>(<i class="calibre12">m</i>) + <i class="calibre12">xr</i>)<sup class="calibre19">-1</sup> mod <i class="calibre12">q</i>
</p>

<p class="calibre9">Bob verifies the signature by computing</p>

<p class="math-left"><i class="calibre12">u</i><sub class="calibre15">1</sub> = (<i class="calibre12">H</i>(<i class="calibre12">m</i>) * <i class="calibre12">s</i>) mod <i class="calibre12">q</i>
 <i class="calibre12">u</i><sub class="calibre15">2</sub> = (<i class="calibre12">sr</i>) mod <i class="calibre12">q</i>
</p>

<p class="calibre9">If <i class="calibre12">r</i> = ((<i class="calibre12">g</i><sup class="calibre19">u<sub class="calibre16">1</sub></sup> * <i class="calibre12">y</i><sup class="calibre19">u<sub class="calibre16">2</sub></sup>) mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>, then the signature is verified.</p>

<p class="calibre9">Another DSA variant allows for batch verification; Bob can verify signatures
in batches [<a href="Applied%20Cryptography_split_036.html#r1135" class="calibre5 pcalibre">1135</a>]. If they are all valid, he is done. If one isn’t valid, then he
still has to find it. Unfortunately, it is not secure; either the signer or the
verifier can easily create a set of bogus signatures that satisfy the batch criteria
[<a href="Applied%20Cryptography_split_036.html#r974" class="calibre5 pcalibre">974</a>].</p>

<p class="calibre9">There is also a variant for DSA prime generation, one that embeds <i class="calibre12">q</i> and the
parameters used to generate the primes within <i class="calibre12">p</i>. Whether this scheme reduces
the security of DSA is still unknown.</p>

<ol class="calibre17">

<li class="calibre14">Choose an arbitrary sequence of at least 160 bits and call it <i class="calibre12">S</i>. Let <i class="calibre12">g</i> be the length of <i class="calibre12">S</i> in bits.
</li>
<li class="calibre14">Compute <i class="calibre12">U</i> = SHA(<i class="calibre12">S</i>) ⊕ SHA((<i class="calibre12">S</i> + 1) mod 2<sup class="calibre19"><i class="calibre22">g</i></sup>), where SHA is the Secure Hash Algorithm (see <a href="Applied%20Cryptography_split_021.html#18.7" class="calibre5 pcalibre">Section 18.7</a>).
</li>
<li class="calibre14">Form <i class="calibre12">q</i> by setting the most significant bit and the least significant bit of <i class="calibre12">U</i> to 1.
</li>
<li class="calibre14">Check whether <i class="calibre12">q</i> is prime.
</li>
<li class="calibre14">Let <i class="calibre12">p</i> be the concatenation of <i class="calibre12">q, S, C</i>, and SHA(<i class="calibre12">S</i>). <i class="calibre12">C</i> is set to 32
zero bits.
</li>
<li class="calibre14"> <i class="calibre12">p</i> = <i class="calibre12">p</i> - (<i class="calibre12">p</i> mod <i class="calibre12">q</i>) + 1.
</li>
<li class="calibre14"> <i class="calibre12">p</i> = <i class="calibre12">p</i> + <i class="calibre12">q</i>.
</li>
<li class="calibre14">If the <i class="calibre12">C</i> in <i class="calibre12">p</i> is <code class="calibre18">0x7fffffff</code>, go to step (1).
</li>
<li class="calibre14">Check whether <i class="calibre12">p</i> is prime.
</li>
<li class="calibre14">If <i class="calibre12">p</i> is composite, go to step (7).
</li>

</ol>

<p class="calibre9">The neat thing about this variant is that you don’t have to store the values of <i class="calibre12">C</i>
and <i class="calibre12">S</i> used to generate <i class="calibre12">p</i> and <i class="calibre12">q</i>; they are embedded within <i class="calibre12">p</i>. For applications without a whole lot of memory, like smart cards, this can be a big deal.</p>

<h3 id="20.3" class="calibre7">20.3 GOST Digital Signature Algorithm</h3>

<p class="calibre9">This is a Russian digital signature standard, officially called GOST R 34.10-94
[<a href="Applied%20Cryptography_split_035.html#r656" class="calibre5 pcalibre">656</a>]. The algorithm is very similar to DSA, and uses the following
parameters</p>

<p class="math-left"><i class="calibre12">p</i> = a prime number, either between 509 and 512 bits long, or between 1020 and 1024 bits long.
<i class="calibre12">q</i> = a 254- to 256-bit prime factor of <i class="calibre12">p</i> - 1.
<i class="calibre12">a</i> = any number less than <i class="calibre12">p</i> - 1 such that <i class="calibre12">a<sup class="calibre19">q</sup></i> mod <i class="calibre12">p</i> = 1.
<i class="calibre12">x</i> = a number less than <i class="calibre12">q</i>.
<i class="calibre12">y</i> = <i class="calibre12">a<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>.
</p>

<p class="calibre9">The algorithm also makes use of a one-way hash function: <i class="calibre12">H</i>(<i class="calibre12">x</i>). The standard specifies GOST R 34.11-94 (see <a href="Applied%20Cryptography_split_021.html#18.11" class="calibre5 pcalibre">Section 18.11</a>), a function based on the GOST
symmetric algorithm (see <a href="Applied%20Cryptography_split_017.html#14.1" class="calibre5 pcalibre">Section 14.1</a>) [<a href="Applied%20Cryptography_split_035.html#r657" class="calibre5 pcalibre">657</a>].</p>

<p class="calibre9">The first three parameters, <i class="calibre12">p, q</i>, and <i class="calibre12">a</i>, are public and can be common across a network of users. The private key is <i class="calibre12">x</i>; the public key is <i class="calibre12">y</i>.</p>

<p class="calibre9">To sign a message, <i class="calibre12">m</i></p>

<ol class="calibre17">

<li class="calibre14">Alice generates a random number, <i class="calibre12">k</i>, less than <i class="calibre12">q</i>
</li>
<li class="calibre14">Alice generates
<p class="math-left"><i class="calibre12">r</i> = (<i class="calibre12">a<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
<i class="calibre12">s</i> = (<i class="calibre12">xr</i> + <i class="calibre12">k</i>(<i class="calibre12">H</i>(<i class="calibre12">m</i>))) mod <i class="calibre12">q</i>
</p>

If <i class="calibre12">H</i>(<i class="calibre12">m</i>) mod <i class="calibre12">q</i> = 0, then set it equal to 1. If <i class="calibre12">r</i> = 0, then choose another <i class="calibre12">k</i> and start again. The signature is two numbers: <i class="calibre12">r</i> mod 2<sup class="calibre19">256</sup> and <i class="calibre12">s</i> mod
2<sup class="calibre19">256</sup>. She sends these to Bob.
</li>
<li class="calibre14">Bob verifies the signature by computing
<p class="math-left"><i class="calibre12">v</i> = <i class="calibre12">H</i>(<i class="calibre12">m</i>)<sup class="calibre19"><i class="calibre22">q</i>-2</sup> mod <i class="calibre12">q</i>
<i class="calibre12">z</i><sub class="calibre15">1</sub> = (<i class="calibre12">sv</i>) mod <i class="calibre12">q</i>
<i class="calibre12">z</i><sub class="calibre15">2</sub> = ((<i class="calibre12">q</i> - <i class="calibre12">r</i>) * <i class="calibre12">v</i>) mod <i class="calibre12">q</i>
<i class="calibre12">u</i> = ((<i class="calibre12">a</i><sup class="calibre19">z<sub class="calibre16">1</sub></sup> * <i class="calibre12">y</i><sup class="calibre19">z<sub class="calibre16">2</sub></sup>) mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
</p>

If <i class="calibre12">u</i> = <i class="calibre12">r</i>, then the signature is verified.
</li>

</ol>

<p class="calibre9">The difference between this scheme and DSA is that with DSA <i class="calibre12">s</i> = (<i class="calibre12">xr</i> +
 <i class="calibre12">k</i><sup class="calibre19">-1</sup>(<i class="calibre12">H</i>(<i class="calibre12">m</i>))) mod <i class="calibre12">q</i>, which leads to a different verification equation. Curious, though, is that <i class="calibre12">q</i> is 256 bits. Most Western cryptographers seem satisfied with a <i class="calibre12">q</i> of around 160 bits. Perhaps this is just a reflection of the Russian tendency to play it ultrasafe.</p>

<p class="calibre9">The standard has been in use since the beginning of 1995, and is not classified
“for special use” — whatever that means.</p>

<h3 id="20.4" class="calibre7">20.4 Discrete Logarithm Signature Schemes</h3>

<p class="calibre9">ElGamal, Schnorr (see <a href="Applied%20Cryptography_split_024.html#21.3" class="calibre5 pcalibre">Section 21.3</a>), and DSA signature schemes are very
similar. In fact, they are just three examples of a general digital signature
scheme based on the Discrete Logarithm Problem. Along with thousands of
other signature schemes, they are part of the same family [<a href="Applied%20Cryptography_split_035.html#r740" class="calibre5 pcalibre">740</a>,<a href="Applied%20Cryptography_split_035.html#r741" class="calibre5 pcalibre">741</a>,<a href="Applied%20Cryptography_split_035.html#r699" class="calibre5 pcalibre">699</a>,<a href="Applied%20Cryptography_split_036.html#r1184" class="calibre5 pcalibre">1184</a>].</p>

<p class="calibre9">Choose <i class="calibre12">p</i>, a large prime number, and <i class="calibre12">q</i>, either <i class="calibre12">p</i> - 1 or a large prime factor of <i class="calibre12">p</i>
- 1. Then choose <i class="calibre12">g</i>, a number between 1 and <i class="calibre12">p</i> such that <i class="calibre12">g<sup class="calibre19">q</sup></i> ≡ 1 (mod <i class="calibre12">p</i>). All these numbers are public, and can be common to a group of users. The private
key is <i class="calibre12">x</i>, less than <i class="calibre12">q</i>. The public key is <i class="calibre12">y</i> = <i class="calibre12">g<sup class="calibre19">x</sup></i> mod <i class="calibre12">p</i>.</p>

<p class="calibre9">To sign a message, <i class="calibre12">m</i>, first choose a random <i class="calibre12">k</i> less than and relatively prime to <i class="calibre12">q</i>. If <i class="calibre12">q</i> is also prime, any <i class="calibre12">k</i> less than <i class="calibre12">q</i> works. First compute</p>

<p class="math"><i class="calibre12">r</i> = <i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">The generalized <b class="calibre10">signature equation</b> now becomes</p>

<p class="math"><i class="calibre12">ak</i> = <i class="calibre12">b</i> + <i class="calibre12">cx</i> mod <i class="calibre12">q</i>
</p>

<p class="calibre9">The coefficients <i class="calibre12">a, b</i>, and <i class="calibre12">c</i> can be any of a variety of things. Each line in Table 20.4 gives six possibilities.</p>

<table class="data-table1" id="table-20-4">
<caption class="calibre67">Table 20.4 - Possible Permutations of <i class="calibre12">a, b</i>, and <i class="calibre12">c</i> (<i class="calibre12">r’</i> = <i class="calibre12">r</i> mod <i class="calibre12">q</i>)</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="calibre69">±<i class="calibre12">r’</i></td><td class="calibre69">±<i class="calibre12">s</i></td><td class="calibre69"><i class="calibre12">m</i></td></tr>
<tr class="calibre25"><td class="calibre70">±<i class="calibre12">r’m</i></td><td class="calibre70">±<i class="calibre12">s</i></td><td class="calibre70">1</td></tr>
<tr class="calibre25"><td class="calibre70">±<i class="calibre12">r’m</i></td><td class="calibre70">±<i class="calibre12">ms</i></td><td class="calibre70">1</td></tr>
<tr class="calibre71"><td class="calibre72">±<i class="calibre12">mr’</i></td><td class="calibre72">±<i class="calibre12">r’s</i></td><td class="calibre72">1</td></tr>
<tr class="calibre25"><td class="calibre70">±<i class="calibre12">ms</i></td><td class="calibre70">±<i class="calibre12">r’s</i></td><td class="calibre70">1</td></tr>
</tbody></table>

<p class="calibre39">To verify the signature, the receiver must confirm that</p>

<p class="math"><i class="calibre12">r<sup class="calibre19">a</sup></i> = <i class="calibre12">g<sup class="calibre19">b</sup>y<sup class="calibre19">c</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">This is called the <b class="calibre10">verification equation</b>.</p>

<p class="calibre9">Table 20.5 lists the signature and verifications possible from just the first line
of potential values for <i class="calibre12">a, b</i>, and <i class="calibre12">c</i>, ignoring the effects of the ±.
That’s six different signature schemes. Adding the negative signs brings the
total to 24. Using the other possible values listed for <i class="calibre12">a, b</i>, and <i class="calibre12">c</i> brings the total to 120.</p>

<table class="data-table1" id="table-20-5">
<caption class="calibre67">Table 20.5 - Discrete Logarithm Signature Schemes</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Signature Equation</th>
<th class="calibre26">Verification Equation</th>
</tr>
<tr class="calibre25"><td class="calibre70">(1) <i class="calibre12">r’k</i> = <i class="calibre12">s</i> + <i class="calibre12">mx</i> mod <i class="calibre12">q</i></td><td class="calibre70"><i class="calibre12">r<sup class="calibre19">r’</sup></i> = <i class="calibre12">g<sup class="calibre19">s</sup>y<sup class="calibre19">m</sup></i> mod <i class="calibre12">p</i></td></tr>
<tr class="calibre25"><td class="calibre70">(2) <i class="calibre12">r’k</i> = <i class="calibre12">m</i> + <i class="calibre12">sx</i> mod <i class="calibre12">q</i></td><td class="calibre70"><i class="calibre12">r<sup class="calibre19">r’</sup></i> = <i class="calibre12">g<sup class="calibre19">m</sup>y<sup class="calibre19">s</sup></i> mod <i class="calibre12">p</i></td></tr>
<tr class="calibre25"><td class="calibre70">(3) <i class="calibre12">sk</i> = <i class="calibre12">r’</i> + <i class="calibre12">mx</i> mod <i class="calibre12">q</i></td><td class="calibre70"><i class="calibre12">r<sup class="calibre19">s</sup></i> = <i class="calibre12">g<sup class="calibre19">r’</sup>y<sup class="calibre19">m</sup></i> mod <i class="calibre12">p</i></td></tr>
<tr class="calibre25"><td class="calibre70">(4) <i class="calibre12">sk</i> = <i class="calibre12">m</i> + <i class="calibre12">r’x</i> mod <i class="calibre12">q</i></td><td class="calibre70"><i class="calibre12">r<sup class="calibre19">s</sup></i> = <i class="calibre12">g<sup class="calibre19">m</sup>y<sup class="calibre19">r’</sup></i> mod <i class="calibre12">p</i></td></tr>
<tr class="calibre71"><td class="calibre72">(5) <i class="calibre12">mk</i> = <i class="calibre12">s</i> + <i class="calibre12">r’x</i> mod <i class="calibre12">q</i></td><td class="calibre72"><i class="calibre12">r<sup class="calibre19">m</sup></i> = <i class="calibre12">g<sup class="calibre19">s</sup>y<sup class="calibre19">r’</sup></i> mod <i class="calibre12">p</i></td></tr>
<tr class="calibre25"><td class="calibre70">(6) <i class="calibre12">mk</i> = <i class="calibre12">r’</i> + <i class="calibre12">sx</i> mod <i class="calibre12">q</i></td><td class="calibre70"><i class="calibre12">r<sup class="calibre19">m</sup></i> = <i class="calibre12">g<sup class="calibre19">r’</sup>y<sup class="calibre19">s</sup></i> mod <i class="calibre12">p</i></td></tr>
</tbody></table>

<p class="calibre39">ElGamal [<a href="Applied%20Cryptography_split_035.html#r518" class="calibre5 pcalibre">518</a>,<a href="Applied%20Cryptography_split_035.html#r519" class="calibre5 pcalibre">519</a>] and DSA [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>] are essentially based on equation (4).
Other schemes are based on equation (2) [<a href="Applied%20Cryptography_split_035.html#r24" class="calibre5 pcalibre">24</a>,<a href="Applied%20Cryptography_split_036.html#r1629" class="calibre5 pcalibre">1629</a>]. Schnorr [<a href="Applied%20Cryptography_split_036.html#r1396" class="calibre5 pcalibre">1396</a>,<a href="Applied%20Cryptography_split_036.html#r1397" class="calibre5 pcalibre">1397</a>] is
closely related to equation (5), as is another scheme [<a href="Applied%20Cryptography_split_036.html#r1183" class="calibre5 pcalibre">1183</a>]. And equation (1)
can be modified to yield the scheme proposed in [<a href="Applied%20Cryptography_split_036.html#r1630" class="calibre5 pcalibre">1630</a>]. The rest of the
equations are new.</p>

<p class="calibre9">There’s more. You can make any of these schemes more DSA-like by defining
<i class="calibre12">r</i> as</p>

<p class="math-left"><i class="calibre12">r</i> = (<i class="calibre12">g<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i></p>

<p class="calibre9">Keep the same signature equation and make the verification equation</p>

<p class="math-left"><i class="calibre12">u</i><sub class="calibre15">1</sub> = <i class="calibre12">a</i><sup class="calibre19">-1</sup><i class="calibre12">b</i> mod <i class="calibre12">q</i>
<i class="calibre12">u</i><sub class="calibre15">2</sub> = <i class="calibre12">a</i><sup class="calibre19">-1</sup><i class="calibre12">c</i> mod <i class="calibre12">q</i>
<i class="calibre12">r</i> = (<i class="calibre12">g</i><sup class="calibre19">u<sub class="calibre16">1</sub></sup><i class="calibre12">y</i><sup class="calibre19">u<sub class="calibre16">2</sub></sup> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
</p>

<p class="calibre9">There are two other possibilities along these lines [<a href="Applied%20Cryptography_split_035.html#r740" class="calibre5 pcalibre">740</a>,<a href="Applied%20Cryptography_split_035.html#r741" class="calibre5 pcalibre">741</a>]; you can do this
with each of the 120 schemes, bringing the total to 480
discrete-logarithm-based digital signature schemes.</p>

<p class="calibre9">But wait — there’s more. Additional generalizations and variations can generate
more than 13,000 variants (not all of them terribly efficient) [<a href="Applied%20Cryptography_split_035.html#r740" class="calibre5 pcalibre">740</a>,<a href="Applied%20Cryptography_split_035.html#r741" class="calibre5 pcalibre">741</a>].</p>

<p class="calibre9">One of the nice things about using RSA for digital signatures is a feature called
<b class="calibre10">message recovery</b>. When you verify an RSA signature you compute <i class="calibre12">m</i>. Then
you compare the computed <i class="calibre12">m</i> with the message and see if the signature is valid
for that message. With the previous schemes, you can’t recover <i class="calibre12">m</i> when you
compute the signature; you need a candidate <i class="calibre12">m</i> that you use in a verification
equation. Well, as it turns out it is possible to construct a message recovery
variant for all the above signature schemes.</p>

<p class="calibre9">To sign, first compute</p>

<p class="math"><i class="calibre12">r</i> = <i class="calibre12">mg<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">and replace <i class="calibre12">m</i> by 1 in the signature equation. Then you can reconstruct the
verification equation such that <i class="calibre12">m</i> can be computed directly.</p>

<p class="calibre9">You can do the same with the DSA-like schemes:</p>

<p class="math"><i class="calibre12">r</i> = (<i class="calibre12">mg<sup class="calibre19">k</sup></i> mod <i class="calibre12">p</i>) mod <i class="calibre12">q</i>
</p>

<p class="calibre9">All the variants are equally secure, so it makes sense to choose a scheme that is
easy to compute with. The requirement to compute inverses slows most of
these schemes. As it turns out, a scheme in this pile allows computing both the
signature equation and the verification equation without inverses and also
gives message recovery. It is called the <b class="calibre10">p-NEW</b> scheme [<a href="Applied%20Cryptography_split_036.html#r1184" class="calibre5 pcalibre">1184</a>].</p>

<p class="math"><i class="calibre12">r</i> = <i class="calibre12">mg<sup class="calibre19">-k</sup></i> mod <i class="calibre12">p</i>
 <i class="calibre12">s</i> = <i class="calibre12">k</i> - <i class="calibre12">r’x</i> mod <i class="calibre12">q</i>
</p>

<p class="calibre9">And <i class="calibre12">m</i> is recovered (and the signature verified) by</p>

<p class="math"><i class="calibre12">m</i> = <i class="calibre12">g<sup class="calibre19">s</sup>y<sup class="calibre19">r’</sup>r</i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">Some variants sign two and three message blocks at the same time [<a href="Applied%20Cryptography_split_035.html#r740" class="calibre5 pcalibre">740</a>]; other
variants can be used for blind signatures [<a href="Applied%20Cryptography_split_035.html#r741" class="calibre5 pcalibre">741</a>].</p>

<p class="calibre9">This is a remarkable piece of research. All of the various
discrete-logarithm-based digital signature schemes have been put in one
coherent framework. In my opinion this finally puts to rest any patent dispute
between Schnorr [<a href="Applied%20Cryptography_split_036.html#r1398" class="calibre5 pcalibre">1398</a>] and DSA [<a href="Applied%20Cryptography_split_036.html#r897" class="calibre5 pcalibre">897</a>]: DSA is not a derivative of Schnorr,
nor even of ElGamal. All three are examples of this general construction, and
this general construction is unpatented.</p>

<h3 id="20.5" class="calibre7">20.5 Ong-Schnorr-Shamir</h3>

<p class="calibre9">This signature scheme uses polynomials modulo <i class="calibre12">n</i> [<a href="Applied%20Cryptography_split_036.html#r1219" class="calibre5 pcalibre">1219</a>,<a href="Applied%20Cryptography_split_036.html#r1220" class="calibre5 pcalibre">1220</a>]. Choose a
large integer <i class="calibre12">n</i> (you need not know the factorization of <i class="calibre12">n</i>). Then choose a random integer, <i class="calibre12">k</i>, such that <i class="calibre12">k</i> and <i class="calibre12">n</i> are relatively prime. Calculate <i class="calibre12">h</i> such that</p>

<p class="math"><i class="calibre12">h</i> = -<i class="calibre12">k</i><sup class="calibre19">-2</sup> mod <i class="calibre12">n</i> = -(<i class="calibre12">k</i><sup class="calibre19">-1</sup>)<sup class="calibre19">2</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">The public key is <i class="calibre12">h</i> and <i class="calibre12">n</i>; <i class="calibre12">k</i> is the private key.</p>

<p class="calibre9">To sign a message, <i class="calibre12">M</i>, first generate a random number, <i class="calibre12">r</i>, such that <i class="calibre12">r</i> and <i class="calibre12">n</i> are
relatively prime. Then calculate:</p>

<p class="math-left"><i class="calibre12">S</i><sub class="calibre15">1</sub> = 1/2 * (<i class="calibre12">M</i>/<i class="calibre12">r</i> + <i class="calibre12">r</i>) mod <i class="calibre12">n</i>
<i class="calibre12">S</i><sub class="calibre15">2</sub> = <i class="calibre12">k</i>/2 * (<i class="calibre12">M</i>/<i class="calibre12">r</i> – <i class="calibre12">r</i>) mod <i class="calibre12">n</i>
</p>

<p class="calibre9">The pair, <i class="calibre12">S</i><sub class="calibre15">1</sub> and <i class="calibre12">S</i><sub class="calibre15">2</sub>, is the signature.</p>

<p class="calibre9">To verify a signature, confirm that</p>

<p class="math">S<sub class="calibre15">1</sub><sup class="calibre19">2</sup> + <i class="calibre12">h</i> * <i class="calibre12">S</i><sub class="calibre15">2</sub><sup class="calibre19">2</sup> ≡ <i class="calibre12">M</i>(mod <i class="calibre12">n</i>)
</p>

<p class="calibre9">The version of the scheme described here is based on quadratic polynomials.
When it was first proposed in [<a href="Applied%20Cryptography_split_036.html#r1217" class="calibre5 pcalibre">1217</a>], a $100 reward was offered for successful
cryptanalysis. It was proved insecure [<a href="Applied%20Cryptography_split_036.html#r1255" class="calibre5 pcalibre">1255</a>,<a href="Applied%20Cryptography_split_035.html#r18" class="calibre5 pcalibre">18</a>], but its authors were not
deterred. They proposed a modification of the algorithm based on cubic
polynomials, which is also insecure [<a href="Applied%20Cryptography_split_036.html#r1255" class="calibre5 pcalibre">1255</a>]. The authors then proposed a
quartic version, which was also broken [<a href="Applied%20Cryptography_split_035.html#r524" class="calibre5 pcalibre">524</a>,<a href="Applied%20Cryptography_split_036.html#r1255" class="calibre5 pcalibre">1255</a>]. A variant which fixes these
problems is in [<a href="Applied%20Cryptography_split_036.html#r1134" class="calibre5 pcalibre">1134</a>].</p>

<h3 id="20.6" class="calibre7">20.6 ESIGN</h3>

<p class="calibre9">ESIGN is a digital signature scheme from NTT Japan [<a href="Applied%20Cryptography_split_036.html#r1205" class="calibre5 pcalibre">1205</a>,<a href="Applied%20Cryptography_split_035.html#r583" class="calibre5 pcalibre">583</a>]. It is touted
as being at least as secure and considerably faster than either RSA or DSA,
with similar key and signature lengths.</p>

<p class="calibre9">The private key is a pair of large prime numbers, <i class="calibre12">p</i> and <i class="calibre12">q</i>. The public key is <i class="calibre12">n</i>, when</p>

<p class="math"><i class="calibre12">n</i> = <i class="calibre12">p</i><sup class="calibre19">2</sup><i class="calibre12">q</i>
</p>

<p class="calibre9"><i class="calibre12">H</i> is a hash function that operates on a message, <i class="calibre12">m</i>, such that <i class="calibre12">H</i>(<i class="calibre12">m</i>) is between 0 and <i class="calibre12">n</i> – 1. There is also a security parameter, <i class="calibre12">k</i>, which will be discussed shortly.</p>

<ol class="calibre17">

<li class="calibre14">Alice picks a random number <i class="calibre12">x</i>, where <i class="calibre12">x</i> is less than <i class="calibre12">pq</i>.
</li>
<li class="calibre14">Alice computes:
<p class="math-left"><i class="calibre12">w</i>, the least integer that is larger than or equal to (<i class="calibre12">H</i>(<i class="calibre12">m</i>) - <i class="calibre12">x<sup class="calibre19">k</sup></i> mod <i class="calibre12">n</i>)/<i class="calibre12">pq</i>
<i class="calibre12">s</i> = <i class="calibre12">x</i> + ((<i class="calibre12">w</i>/ <i class="calibre12">kx</i><sup class="calibre19"><i class="calibre22">k</i> - 1</sup>) mod <i class="calibre12">p</i>)<i class="calibre12">pq</i>
</p>

</li>
<li class="calibre14">Alice sends <i class="calibre12">s</i> to Bob.
</li>
<li class="calibre14">To verify the signature, Bob computes <i class="calibre12">s<sup class="calibre19">k</sup></i> mod <i class="calibre12">n</i>. He also computes <i class="calibre12">a</i>, which is the least integer larger than or equal to two times the number
of bits of <i class="calibre12">n</i> divided by 3. If <i class="calibre12">H</i>(<i class="calibre12">m</i>) is less than or equal to <i class="calibre12">s<sup class="calibre19">k</sup></i> mod <i class="calibre12">n</i>, and if <i class="calibre12">s<sup class="calibre19">k</sup></i> mod <i class="calibre12">n</i> is less than <i class="calibre12">H</i>(<i class="calibre12">m</i>) + 2<sup class="calibre19"><i class="calibre22">a</i></sup>, then the signature is considered valid.
</li>

</ol>

<p class="calibre9">This algorithm works faster with precomputation. This precomputation can be
done at any time and has nothing to do with the message being signed. After
picking <i class="calibre12">x</i>, Alice could break step (2) into two partial steps. The first can be precomputed.</p>

<ul class="split1">
<li class="calibre35">2a. Alice computes:
<p class="math-left"><i class="calibre12">u</i> = <i class="calibre12">x<sup class="calibre19">k</sup></i> mod <i class="calibre12">n</i>
<i class="calibre12">v</i> = 1/(<i class="calibre12">kx</i><sup class="calibre19">k - 1</sup>) mod <i class="calibre12">p</i>
</p>
</li>
<li class="calibre35">2b. Alice computes:
<p class="math-left"><i class="calibre12">w</i> = the least integer that is larger than or equal to (<i class="calibre12">H</i>(<i class="calibre12">m</i>) - <i class="calibre12">u</i>)/<i class="calibre12">pq</i>)
<i class="calibre12">s</i> = <i class="calibre12">x</i> + (<i class="calibre12">wv</i> mod <i class="calibre12">p</i>)<i class="calibre12">pq</i>
</p>
</li>
</ul>

<p class="calibre9">For the size of numbers generally used, this precomputation speeds up the
signature process by a factor of 10. Almost all the hard work is done in the
precomputation stage. A discussion of modular arithmetic operations to speed
ESIGN can be found in [<a href="Applied%20Cryptography_split_036.html#r1625" class="calibre5 pcalibre">1625</a>,<a href="Applied%20Cryptography_split_036.html#r1624" class="calibre5 pcalibre">1624</a>]. This algorithm can also be extended to
work with elliptic curves [<a href="Applied%20Cryptography_split_036.html#r1206" class="calibre5 pcalibre">1206</a>].</p>

<h4 class="calibre8">Security of ESIGN</h4>

<p class="calibre9">When this algorithm was originally proposed, <i class="calibre12">k</i> was set to 2 [<a href="Applied%20Cryptography_split_036.html#r1215" class="calibre5 pcalibre">1215</a>]. This was
quickly broken by Ernie Brickell and John DeLaurentis [<a href="Applied%20Cryptography_split_035.html#r261" class="calibre5 pcalibre">261</a>], who then
extended their attack to <i class="calibre12">k</i> = 3. A modified version of this algorithm [<a href="Applied%20Cryptography_split_036.html#r1203" class="calibre5 pcalibre">1203</a>] was broken by Shamir [<a href="Applied%20Cryptography_split_036.html#r1204" class="calibre5 pcalibre">1204</a>]. The variant proposed in [<a href="Applied%20Cryptography_split_036.html#r1204" class="calibre5 pcalibre">1204</a>] was broken in
[<a href="Applied%20Cryptography_split_036.html#r1553" class="calibre5 pcalibre">1553</a>]. ESIGN is the current incarnation of this family of algorithms. Another
new attack [<a href="Applied%20Cryptography_split_036.html#r963" class="calibre5 pcalibre">963</a>] does not work against ESIGN.</p>

<p class="calibre9">The authors currently recommend these values for <i class="calibre12">k</i>: 8, 16, 32, 64, 128, 256,
512, and 1024. They also recommend that <i class="calibre12">p</i> and <i class="calibre12">q</i> each be of at least 192 bits, making <i class="calibre12">n</i> at least 576 bits long. (I think <i class="calibre12">n</i> should be twice that length.) With these parameters, the authors conjecture that ESIGN is as secure as RSA or
Rabin. And their analysis shows favorable speed comparison to RSA,
ElGamal, and DSA [<a href="Applied%20Cryptography_split_035.html#r582" class="calibre5 pcalibre">582</a>].</p>

<h4 class="calibre8">Patents</h4>

<p class="calibre9">ESIGN is patented in the United States [<a href="Applied%20Cryptography_split_036.html#r1208" class="calibre5 pcalibre">1208</a>], Canada, England, France,
Germany, and Italy. Anyone who wishes to license the algorithm should
contact <code class="calibre18">Intellectual Property Department, NTT, 1–6 Uchisaiwai-cho, 1-chome,
Chiyada-ku, 100 Japan</code>.</p>

<h3 id="20.7" class="calibre7">20.7 Cellular Automata</h3>

<p class="calibre9">A new and novel idea, studied by Papua Guam [<a href="Applied%20Cryptography_split_035.html#r665" class="calibre5 pcalibre">665</a>], is the use of cellular
automata in public-key cryptosystems. This system is still far too new and has
not been studied extensively, but a preliminary examination suggests that it
may have a cryptographic weakness similar to one seen in other cases [<a href="Applied%20Cryptography_split_035.html#r562" class="calibre5 pcalibre">562</a>].
Still, this is a promising area of research. Cellular automata have the property
that, even if they are invertible, it is impossible to calculate the predecessor of
an arbitrary state by reversing the rule for finding the successor. This sounds a
whole lot like a trapdoor one-way function.</p>

<h3 id="20.8" class="calibre7">20.8 Other Public-Key Algorithms</h3>

<p class="calibre9">Many other public-key algorithms have been proposed and broken over the
years. The Matsumoto-Imai algorithm [<a href="Applied%20Cryptography_split_036.html#r1021" class="calibre5 pcalibre">1021</a>] was broken in [<a href="Applied%20Cryptography_split_035.html#r450" class="calibre5 pcalibre">450</a>]. The Cade
algorithm was first proposed in 1985, broken in 1986 [<a href="Applied%20Cryptography_split_035.html#r774" class="calibre5 pcalibre">774</a>], and then
strengthened in the same year [<a href="Applied%20Cryptography_split_035.html#r286" class="calibre5 pcalibre">286</a>]. In addition to these attacks, there are
general attacks for decomposing polynomials over finite fields [<a href="Applied%20Cryptography_split_035.html#r605" class="calibre5 pcalibre">605</a>]. Any
algorithm that gets its security from the composition of polynomials over a
finite field should be looked upon with skepticism, if not outright suspicion.</p>

<p class="calibre9">The Yagisawa algorithm combines exponentiation mod <i class="calibre12">p</i> with arithmetic mod
<i class="calibre12">p</i> - 1 [<a href="Applied%20Cryptography_split_036.html#r1623" class="calibre5 pcalibre">1623</a>]; it was broken in [<a href="Applied%20Cryptography_split_035.html#r256" class="calibre5 pcalibre">256</a>]. Another public-key algorithm,
Tsujii-Kurosawa-Itoh-Fujioka-Matsumoto [<a href="Applied%20Cryptography_split_036.html#r1548" class="calibre5 pcalibre">1548</a>] is insecure [<a href="Applied%20Cryptography_split_036.html#r948" class="calibre5 pcalibre">948</a>]. A third
system, Luccio-Mazzone [<a href="Applied%20Cryptography_split_036.html#r993" class="calibre5 pcalibre">993</a>], is insecure [<a href="Applied%20Cryptography_split_035.html#r717" class="calibre5 pcalibre">717</a>]. A signature scheme based
on birational permutations [<a href="Applied%20Cryptography_split_036.html#r1425" class="calibre5 pcalibre">1425</a>] was broken the day after it was presented
[<a href="Applied%20Cryptography_split_035.html#r381" class="calibre5 pcalibre">381</a>]. Tatsuaki Okamoto has several signature schemes: one is provably as
secure as the Discrete Logarithm Problem, and another is provably as secure as
the Discrete Logarithm Problem <i class="calibre12">and</i> the Factoring Problem [<a href="Applied%20Cryptography_split_036.html#r1206" class="calibre5 pcalibre">1206</a>]. Similar
schemes are in [<a href="Applied%20Cryptography_split_035.html#r709" class="calibre5 pcalibre">709</a>].</p>

<p class="calibre9">Gustavus Simmons suggested J-algebras as a basis for public-key algorithms
[<a href="Applied%20Cryptography_split_036.html#r1455" class="calibre5 pcalibre">1455</a>,<a href="Applied%20Cryptography_split_035.html#r145" class="calibre5 pcalibre">145</a>]. This idea was abandoned after efficient methods for factoring
polynomials were invented [<a href="Applied%20Cryptography_split_036.html#r951" class="calibre5 pcalibre">951</a>]. Special polynomial semigroups have also
been studied [<a href="Applied%20Cryptography_split_036.html#r1619" class="calibre5 pcalibre">1619</a>,<a href="Applied%20Cryptography_split_036.html#r962" class="calibre5 pcalibre">962</a>], but so far nothing has come of it. Harald Niederreiter
proposed a public-key algorithm based on shift-register sequences [<a href="Applied%20Cryptography_split_036.html#r1166" class="calibre5 pcalibre">1166</a>].
Another is based on Lyndon words [<a href="Applied%20Cryptography_split_036.html#r1476" class="calibre5 pcalibre">1476</a>] and another on propositional
calculus [<a href="Applied%20Cryptography_split_035.html#r817" class="calibre5 pcalibre">817</a>]. And a recent public-key algorithm gets its security from the
matrix cover problem [<a href="Applied%20Cryptography_split_035.html#r82" class="calibre5 pcalibre">82</a>]. Tatsuaki Okamoto and Kazuo Ohta compare a
number of digital signature schemes in [<a href="Applied%20Cryptography_split_036.html#r1212" class="calibre5 pcalibre">1212</a>].</p>

<p class="calibre9">Prospects for creating radically new and different public-key cryptography
algorithms seem dim. In 1988 Whitfield Diffie noted that most public-key
algorithms are based on one of three hard problems [<a href="Applied%20Cryptography_split_035.html#r492" class="calibre5 pcalibre">492</a>,<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Knapsack: Given a set of unique numbers, find a subset whose sum
is <i class="calibre12">N</i>.
</li>
<li class="calibre14">Discrete logarithm: If <i class="calibre12">p</i> is a prime and <i class="calibre12">g</i> and <i class="calibre12">m</i> are integers, find <i class="calibre12">x</i> such that <i class="calibre12">g<sup class="calibre19">x</sup></i> ≡ <i class="calibre12">M</i>(mod <i class="calibre12">p</i>).
</li>
<li class="calibre14">Factoring: If <i class="calibre12">N</i> is the product of two primes, either
<ol class="calibre43">

<li class="calibre14">factor <i class="calibre12">N</i>,
</li>
<li class="calibre14">given integers <i class="calibre12">M</i> and <i class="calibre12">C</i>, find <i class="calibre12">d</i> such that <i class="calibre12">M<sup class="calibre19">d</sup></i> ≡ <i class="calibre12">C</i>(mod <i class="calibre12">N</i>), 
</li>
<li class="calibre14">given integers <i class="calibre12">e</i> and <i class="calibre12">C</i>, find <i class="calibre12">M</i> such that <i class="calibre12">M<sup class="calibre19">e</sup></i> ≡ <i class="calibre12">C</i>(mod <i class="calibre12">N</i>), or 
</li>
<li class="calibre14">given an integer <i class="calibre12">x</i>, decide whether there exists an integer <i class="calibre12">y</i>
such that <i class="calibre12">x</i> ≡ <i class="calibre12">y</i><sup class="calibre19">2</sup>(mod <i class="calibre12">N</i>).
</li>

</ol>

</li>

</ol>

<p class="calibre9">According to Diffie [<a href="Applied%20Cryptography_split_035.html#r492" class="calibre5 pcalibre">492</a>,<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>], the Discrete Logarithm Problem was suggested
by J. Gill, the Factoring Problem by Knuth, and the knapsack problem by
Diffie himself.</p>

<p class="calibre9">This narrowness in the mathematical foundations of public-key cryptography
is worrisome. A breakthrough in either the problem of factoring or of
calculating discrete logarithms could render whole classes of public-key
algorithms insecure. Diffie points out [<a href="Applied%20Cryptography_split_035.html#r492" class="calibre5 pcalibre">492</a>,<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>] that this risk is mitigated by
two factors:</p>

<ol class="calibre17">

<li class="calibre14">The operations on which public key cryptography
currently depends — multiplying, exponentiating, and
factoring — are all fundamental arithmetic phenomena.
They have been the subject of intense mathematical
scrutiny for centuries and the increased attention that has
resulted from their use in public key cryptosystems has on
balance enhanced rather than diminished our confidence.
</li>
<li class="calibre14">Our ability to carry out large arithmetic computations
has grown steadily and now permits us to implement our
systems with numbers sufficient in size to be vulnerable
only to a dramatic breakthrough in factoring, logarithms, or
root extraction.
</li>

</ol>

<p class="calibre9">As we have seen, not all public-key algorithms based on these problems are
secure. The strength of any public-key algorithm depends on more than the
computational complexity of the problem upon which it is based; a hard
problem does not necessarily imply a strong algorithm. Adi Shamir listed three
reasons why this is so [<a href="Applied%20Cryptography_split_036.html#r1415" class="calibre5 pcalibre">1415</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Complexity theory usually deals with single isolated
instances of a problem. A cryptanalyst often has a large
collection of statistically related problems to solve — several
ciphertexts encrypted with the same key.
</li>
<li class="calibre14">The computational complexity of a problem is typically
measured by its worst-case or average-case behavior. To be
useful as a cipher, the problem must be hard to solve in
almost all cases.
</li>
<li class="calibre14">An arbitrarily difficult problem cannot necessarily be
transformed into a cryptosystem, and it must be possible to
insert trapdoor information into the problem so that a
shortcut solution is possible with this information and only
with this information.
</li>

</ol>

<div class="calibre6" id="calibre_pb_46"></div>
</div>






</body></html>
