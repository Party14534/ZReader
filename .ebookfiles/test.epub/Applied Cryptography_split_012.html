<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="10">Chapter 10 <br class="calibre3"/>
Using Algorithms</h1>

<p class="calibre9">Think of security — data security, communications security, information
security, whatever — as a chain. The security of the entire system is only as
strong as the weakest link. Everything has to be secure: cryptographic
algorithms, protocols, key management, and more. If your algorithms are great
but your random-number generator stinks, any smart cryptanalyst is going to
attack your system through the random-number generation. If you patch that
hole but forget to securely erase a memory location that contains the key, a
cryptanalyst will break your system via that route. If you do everything right
and accidentally e-mail a copy of your secure files to <i class="calibre12">The Wall Street Journal</i>, you might as well not have bothered.</p>

<p class="calibre9">It’s not fair. As the designer of a secure system, you have to think of every
possible means of attack and protect against them all, but a cryptanalyst only
has to find one hole in your security and exploit it.</p>

<p class="calibre9">Cryptography is only a part of security, and often a very small part. It is the
mathematics of making a system secure, which is different from actually
making a system secure. Cryptography has its “size queens”: people who
spend so much time arguing about how long a key should be that they forget
about everything else. If the secret police want to know what is on your
computer, it is far easier for them to break into your house and install a camera
that can record what is on your computer screen than it is for them to
cryptanalze your hard drive.</p>

<p class="calibre9">Additionally, the traditional view of computer cryptography as “spy versus
spy” technology is becoming increasingly inappropriate. Over 99 percent of
the cryptography used in the world is not protecting military secrets; it’s in
applications such as bank cards, pay-TV, road tolls, office building and
computer access tokens, lottery terminals, and prepayment electricity meters
[<a href="Applied%20Cryptography_split_035.html#r43" class="calibre5 pcalibre">43</a>,<a href="Applied%20Cryptography_split_035.html#r44" class="calibre5 pcalibre">44</a>]. In these applications, the role of cryptography is to make petty crime
slightly more difficult; the paradigm of the well-funded adversary with a rabbit
warren of cryptanalysts and roomsful of computers just doesn’t apply.</p>

<p class="calibre9">Most of those applications have used lousy cryptography, but successful
attacks against them had nothing to do with cryptanalysis. They involved
crooked employees, clever sting operations, stupid implementations,
integration blunders, and random idiocies. (I strongly recommend Ross
Anderson’s paper, “Why Cryptosytems Fail” [<a href="Applied%20Cryptography_split_035.html#r44" class="calibre5 pcalibre">44</a>]; it should be required
reading for anyone involved in this field.) Even the NSA has admitted that
most security failures in its area of interest are due to failures in
implementation, and not failures in algorithms or protocols [<a href="Applied%20Cryptography_split_036.html#r1119" class="calibre5 pcalibre">1119</a>]. In these
instances it didn’t matter how good the cryptography was; the successful
attacks bypassed it completely.</p>

<h3 id="10.1" class="calibre7">10.1 Choosing an Algorithm</h3>

<p class="calibre9">When it comes to evaluating and choosing algorithms, people have several
alternatives:</p>

<ul class="calibre13">

<li class="calibre14"> They can choose a published algorithm, based on the belief that a
published algorithm has been scrutinized by many cryptographers; if no
one has broken the algorithm yet, then it must be pretty good.
</li>
<li class="calibre14"> They can trust a manufacturer, based on the belief that a well-known
manufacturer has a reputation to uphold and is unlikely to risk that
reputation by selling equipment or programs with inferior algorithms.
</li>
<li class="calibre14"> They can trust a private consultant, based on the belief that an
impartial consultant is best equipped to make a reliable evaluation of
different algorithms.
</li>
<li class="calibre14"> They can trust the government, based on the belief that the
government is trustworthy and wouldn’t steer its citizens wrong.
</li>
<li class="calibre14"> They can write their own algorithms, based on the belief that their
cryptographic ability is second-to-none and that they should trust
nobody but themselves.
</li>

</ul>

<p class="calibre9">Any of these alternatives is problematic, but the first seems to be the most
sensible. Putting your trust in a single manufacturer, consultant, or government
is asking for trouble. Most people who call themselves security consultants
(even those from big-name firms) usually don’t know anything about
encryption. Most security product manufacturers are no better. The NSA has
some of the world’s best cryptographers working for it, but they’re not telling
all they know. They have their own interests to further which are not congruent
with those of their citizens. And even if you’re a genius, writing your own
algorithm and then using it without any peer review is just plain foolish.</p>

<p class="calibre9">The algorithms in this book are public. Most have appeared in the open
literature and many have been cryptanalyzed by experts in the field. I list all
published results, both positive and negative. I don’t have access to the
cryptanalysis done by any of the myriad military security organizations in the
world (which are probably better than the academic institutions — they’ve been
doing it longer and are better funded), so it is possible that these algorithms are
easier to break than it appears. Even so, it is far more likely that they are more
secure than an algorithm designed and implemented in secret in some
corporate basement.</p>

<p class="calibre9">The hole in all this reasoning is that we don’t know the abilities of the various
military cryptanalysis organizations.</p>

<p class="calibre9">What algorithms can the NSA break? For the majority of us, there’s really no
way of knowing. If you are arrested with a DES-encrypted computer hard
drive, the FBI is unlikely to introduce the decrypted plaintext at your trial; the
fact that they can break an algorithm is often a bigger secret than any
information that is recovered. During WWII, the Allies were forbidden from
using decrypted German Ultra traffic unless they could have plausibly gotten
the information elsewhere. The only way to get the NSA to admit to the ability
to break a given algorithm is to encrypt something so valuable that its public
dissemination is worth the admission. Or, better yet, create a really funny joke
and send it via encrypted e-mail to shady characters in shadowy countries.
NSA employees are people, too; I doubt even they can keep a good joke secret.</p>

<p class="calibre9">A good working assumption is that the NSA can read any message that it
chooses, but that it cannot read all messages that it chooses. The NSA is
limited by resources, and has to pick and choose among its various targets.
Another good assumption is that they prefer breaking knuckles to breaking
codes; this preference is so strong that they will only resort to breaking codes
when they wish to preserve the secret that they have read the message.</p>

<p class="calibre9">In any case, the best most of us can do is to choose among public algorithms
that have withstood a reasonable amount of public scrutiny and cryptanalysis.</p>

<h4 class="calibre8">Algorithms for Export</h4>

<p class="calibre9">Algorithms for export out of the United States must be approved by the U.S.
government (actually, by the NSA — see <a href="Applied%20Cryptography_split_029.html#25.1" class="calibre5 pcalibre">Section 25.1</a>). It is widely believed
that these export-approved algorithms can be broken by the NSA. Although no
one has admitted this on the record, these are some of the things the NSA is
rumored to privately suggest to companies wishing to export their
cryptographic products:</p>

<ul class="calibre13">

<li class="calibre14"> Leak a key bit once in a while, embedded in the ciphertext.
</li>
<li class="calibre14"> “Dumb down” the effective key to something in the 30-bit range.
For example, while the algorithm might accept a 100-bit key, most of
those keys might be equivalent.
</li>
<li class="calibre14"> Use a fixed IV, or encrypt a fixed header at the beginning of each
encrypted message. This facilitates a known-plaintext attack.
</li>
<li class="calibre14"> Generate a few random bytes, encrypt them with the key, and then
put both the plaintext and the ciphertext of those random bytes at the
beginning of the encrypted message. This also facilitates a
known-plaintext attack.
</li>

</ul>

<p class="calibre9">NSA gets a copy of the source code, but the algorithm’s details remain secret
from everyone else. Certainly no one advertises any of these deliberate
weaknesses, but beware if you buy a U.S. encryption product that has been
approved for export.</p>

<h3 id="10.2" class="calibre7">10.2 Public-Key Cryptography versus Symmetric Cryptography</h3>

<p class="calibre9">Which is better, public-key cryptography or symmetric cryptography? This
question doesn’t make any sense, but has been debated since public-key
cryptography was invented. The debate assumes that the two types of
cryptography can be compared on an equal footing. They can’t.</p>

<p class="calibre9">Needham and Schroeder [<a href="Applied%20Cryptography_split_036.html#r1159" class="calibre5 pcalibre">1159</a>] pointed out that the number and length of
messages are far greater with public-key algorithms than with symmetric
algorithms. Their conclusion was that the symmetric algorithm was more
efficient than the public-key algorithm. While true, this analysis overlooks the
significant security benefits of public-key cryptography.</p>

<p class="calibre9">Whitfield Diffie writes [<a href="Applied%20Cryptography_split_035.html#r492" class="calibre5 pcalibre">492</a>,<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>]:</p>

<p class="quote">In viewing public-key cryptography as a new form of
cryptosystem rather than a new form of key management, I set the
stage for criticism on grounds of both security and performance.
Opponents were quick to point out that the RSA system ran about
one-thousandth as fast as DES and required keys about ten times
as large. Although it had been obvious from the beginning that the
use of public key systems could be limited to exchanging keys for
conventional [symmetric] cryptography, it was not immediately
clear that this was necessary. In this context, the proposal to build
<i class="calibre12">hybrid</i> systems [<a href="Applied%20Cryptography_split_036.html#r879" class="calibre5 pcalibre">879</a>] was hailed as a discovery in its own right.</p>

<p class="calibre9">Public-key cryptography and symmetric cryptography are different sorts of
animals; they solve different sorts of problems. Symmetric cryptography is
best for encrypting data. It is orders of magnitude faster and is not susceptible
to chosen-ciphertext attacks. Public-key cryptography can do things that
symmetric cryptography can’t; it is best for key management and a myriad of
protocols discussed in <a href="Applied%20Cryptography_split_002.html#part1" class="calibre5 pcalibre">Part I</a>.</p>

<p class="calibre9">Other primitives were discussed in <a href="Applied%20Cryptography_split_002.html#part1" class="calibre5 pcalibre">Part I</a>: one-way hash functions, message
authentication codes, and so on. Table 10.1 lists different types of algorithms
and their properties [<a href="Applied%20Cryptography_split_035.html#r804" class="calibre5 pcalibre">804</a>].</p>

<table class="data-table2" id="table-10-1">
<caption class="calibre23">Table 10.1 - Classes of Algorithms</caption>
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre26">Algorithm</th>
<th class="calibre26">Confidentiality</th>
<th class="calibre26">Authentication</th>
<th class="calibre26">Integrity</th>
<th class="calibre26">Key Management</th>
</tr>
<tr class="calibre25"><td class="calibre61">Symmetric encryption algorithms</td><td class="calibre27">Yes</td><td class="calibre27">No</td><td class="calibre27">No</td><td class="calibre27">Yes</td></tr>
<tr class="calibre25"><td class="calibre61">Public-key encryption algorithms</td><td class="calibre27">Yes</td><td class="calibre27">No</td><td class="calibre27">No</td><td class="calibre27">Yes</td></tr>
<tr class="calibre25"><td class="calibre61">Digital signature algorithms</td><td class="calibre27">No</td><td class="calibre27">Yes</td><td class="calibre27">Yes</td><td class="calibre27">No</td></tr>
<tr class="calibre25"><td class="calibre61">Key-agreement algorithms</td><td class="calibre27">Yes</td><td class="calibre27">Optional</td><td class="calibre27">No</td><td class="calibre27">Yes</td></tr>
<tr class="calibre25"><td class="calibre61">One-way hash functions</td><td class="calibre27">No</td><td class="calibre27">No</td><td class="calibre27">Yes</td><td class="calibre27">No</td></tr>
<tr class="calibre25"><td class="calibre62">Message authentication codes</td><td class="calibre28">No</td><td class="calibre28">Yes</td><td class="calibre28">Yes</td><td class="calibre28">No</td></tr>
</tbody></table>

<h3 id="10.3" class="calibre7">10.3 Encrypting Communications Channels</h3>

<p class="calibre9">This is the classic Alice and Bob problem: Alice wants to send Bob a secure
message. What does she do? She encrypts the message.</p>

<p class="calibre9">In theory, this encryption can take place at any layer in the OSI (Open Systems
Interconnect) communications model. (See the OSI security architecture
standard for more information [<a href="Applied%20Cryptography_split_035.html#r305" class="calibre5 pcalibre">305</a>].) In practice, it takes place either at the
lowest layers (one and two) or at higher layers. If it takes place at the lowest
layers, it is called <b class="calibre10">link-by-link encryption</b>; everything going through a
particular data link is encrypted. If it takes place at higher layers, it is called
<b class="calibre10">end-to-end encryption</b>; the data are encrypted selectively and stay encrypted
until they are decrypted by the intended final recipient. Each approach has its
own benefits and drawbacks.</p>

<h4 class="calibre8">Link-by-Link Encryption</h4>

<p class="calibre9">The easiest place to add encryption is at the physical layer (see Figure 10.1).
This is called link-by-link encryption. The interfaces to the physical layer are
generally standardized and it is easy to connect hardware encryption devices at
this point. These devices encrypt all data passing through them, including data,
routing information, and protocol information. They can be used on any type
of digital communication link. On the other hand, any intelligent switching or
storing nodes between the sender and the receiver need to decrypt the data
stream before processing it.</p>

<div class="figure" id="figure-10-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-10-1.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 10.1</b> Link encryption.</i></p>
</div>

<p class="calibre9">This type of encryption is very effective. Because everything is encrypted, a
cryptanalyst can get no information about the structure of the information. He
has no idea who is talking to whom, how long the messages they are sending
are, what times of day they communicate, and so on. This is called <b class="calibre10">traffic-flow</b>
<b class="calibre10">security</b>: the enemy is not only denied access to the information, but also
access to the knowledge of where and how much information is flowing.</p>

<p class="calibre9">Security does not depend on any traffic management techniques. Key
management is also simple; only the two endpoints of the line need a common
key, and they can change their key independently from the rest of the network.</p>

<p class="calibre9">Imagine a synchronous communications line, encrypted using 1-bit CFB. After
initialization, the line can run indefinitely, recovering automatically from bit or
synchronization errors. The line encrypts whenever messages are sent from
one end to the other; otherwise it just encrypts and decrypts random data. Eve
has no idea when messages are being sent and when they are not; she has no
idea when messages begin and end. All she sees is an endless stream of
random-looking bits.</p>

<p class="calibre9">If the communications line is asynchronous, the same 1-bit CFB mode can be
used. The difference is that the adversary can get information about the rate of
transmission. If this information must be concealed, make some provision for
passing dummy messages during idle times.</p>

<p class="calibre9">The biggest problem with encryption at the physical layer is that each physical
link in the network needs to be encrypted: Leaving any link unencrypted
jeopardizes the security of the entire network. If the network is large, the cost
may quickly become prohibitive for this kind of encryption.</p>

<p class="calibre9">Additionally, every node in the network must be protected, since it processes
unencrypted data. If all the network’s users trust one another, and all nodes are
in secure locations, this may be tolerable. But this is unlikely. Even in a single
corporation, information might have to be kept secret within a department. If
the network accidentally misroutes information, anyone can read it. Table 10.2
summarizes the pros and cons of link-by-link encryption.</p>

<p id="table-10-2" class="calibre9"><b class="calibre10">Table 10.2 - Link-by-Link Encryption: Advantages and Disadvantages</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Advantages:</b></i></p>
<p class="calibre9">Easier operation, since it can be made transparent to the user. That is,
everything is encrypted before being sent over the link.</p>
<p class="calibre9">Only one set of keys per link is required.</p>
<p class="calibre9">Provides traffic-flow security, since any routing information is
encrypted.</p>
<p class="calibre9">Encryption is online.</p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Disadvantages:</b></i></p>
<p class="calibre9">Data is exposed in the intermediate nodes.</p>
<hr class="calibre63"/>

<h4 class="calibre8">End-to-End Encryption</h4>

<p class="calibre9">Another approach is to put encryption equipment between the network layer
and the transport layer. The encryption device must understand the data
according to the protocols up to layer three and encrypt only the transport data
units, which are then recombined with the unencrypted routing information
and sent to lower layers for transmission.</p>

<p class="calibre9">This approach avoids the encryption/decryption problem at the physical layer.
By providing end-to-end encryption, the data remains encrypted until it
reaches its final destination (see Figure 10.2). The primary problem with
end-to-end encryption is that the routing information for the data is not
encrypted; a good cryptanalyst can learn much from who is talking to whom,
at what times and for how long, without ever knowing the contents of those
conversations. Key management is also more difficult, since individual users
must make sure they have common keys.</p>

<div class="figure" id="figure-10-2">
<div class="image1">
<p class="calibre9"><img src="ac-figure-10-2.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 10.2</b> End-to-end encryption.</i></p>
</div>

<p class="calibre9">Building end-to-end encryption equipment is difficult. Each particular
communications system has its own protocols. Sometimes the interfaces
between the levels are not well-defined, making the task even more difficult.</p>

<p class="calibre9">If encryption takes place at a high layer of the communications architecture,
like the applications layer or the presentation layer, then it can be independent
of the type of communication network used. It is still end-to-end encryption,
but the encryption implementation does not have to bother about line codes,
synchronization between modems, physical interfaces, and so forth. In the
early days of electromechanical cryptography, encryption and decryption took
place entirely offline; this is only one step removed from that.</p>

<p class="calibre9">Encryption at these high layers interacts with the user software. This software
is different for different computer architectures, and so the encryption must be
optimized for different computer systems. Encryption can occur in the
software itself or in specialized hardware. In the latter case, the computer will
send the data to the specialized hardware for encryption before sending it to
lower layers of the communication architecture for transmission. This process
requires some intelligence and is not suitable for dumb terminals.
Additionally, there may be compatibility problems with different types of
computers.</p>

<p class="calibre9">The major disadvantage of end-to-end encryption is that it allows <b class="calibre10">traffic</b>
<b class="calibre10">analysis</b>. Traffic analysis is the analysis of encrypted messages: where they
come from, where they go to, how long they are, when they are sent, how
frequent or infrequent they are, whether they coincide with outside events like
meetings, and more. A lot of good information is buried in that data, and a
cryptanalyst will want to get his hands on it. Table 10.3 presents the positive
and negative aspects of end-to-end encryption.</p>

<p id="table-10-3" class="calibre9"><b class="calibre10">Table 10.3 - End-to-End Encryption: Advantages and Disadvantages</b></p>
<hr class="calibre63"/>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Advantages:</b></i></p>
<p class="calibre9">Higher secrecy level.</p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Disadvantages:</b></i></p>
<p class="calibre9">Requires a more complex key-management system.</p>
<p class="calibre9">Traffic analysis is possible, since routing information is not
encrypted.</p>
<p class="calibre9">Encryption is offline.</p>
<hr class="calibre63"/>

<h4 class="calibre8">Combining the Two</h4>

<p class="calibre9">Table 10.4, primarily from [<a href="Applied%20Cryptography_split_036.html#r1244" class="calibre5 pcalibre">1244</a>], compares link-by-link and end-to-end
encryption. Combining the two, while most expensive, is the most effective
way of securing a network. Encryption of each physical link makes any
analysis of the routing information impossible, while end-to-end encryption
reduces the threat of unencrypted data at the various nodes in the network. Key
management for the two schemes can be completely separate: The network
managers can take care of encryption at the physical level, while the individual
users have responsibility for end-to-end encryption.</p>

<table class="data-table1" id="table-10-4">
<caption class="calibre23">Table 10.4 - Comparing Link-by-Link and End-to-End Encryption</caption>
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre26">Link-by-link encryption</th>
<th class="calibre26">End-to-end encryption</th>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Security within Hosts</td></tr>
<tr class="calibre25">
<td class="calibre64">Message exposed in sending host</td>
<td class="calibre64">Message encrypted in sending host</td>
</tr>
<tr class="calibre25">
<td class="calibre64">Message exposed in intermediate nodes</td>
<td class="calibre64">Message encrypted inintermediate nodes</td>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Role of User</td></tr>
<tr class="calibre25">
<td class="calibre64">Applied by sending host</td>
<td class="calibre64">Applied by sending process</td>
</tr>
<tr class="calibre25">
<td class="calibre64">Invisible to user</td>
<td class="calibre64">User applies encryption</td>
</tr>
<tr class="calibre25">
<td class="calibre64">Host maintains encryption</td>
<td class="calibre64">User must find algorithm</td>
</tr>
<tr class="calibre25">
<td class="calibre64">One facility for all users</td>
<td class="calibre64">User selects encryption</td>
</tr>
<tr class="calibre25">
<td class="calibre64">Can be done in hardware</td>
<td class="calibre64">More easily done in software</td>
</tr>
<tr class="calibre25">
<td class="calibre64">All or no messages encrypted</td>
<td class="calibre64">User chooses to encrypt or not, for each message</td>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Implementation Concerns</td></tr>
<tr class="calibre25">
<td class="calibre64">Requires one key per host pair</td>
<td class="calibre64">Requires one key per user pair</td>
</tr>
<tr class="calibre25">
<td class="calibre64">Requires encryption hardware or software at each host</td>
<td class="calibre64">Requires encryption hardware or software at each node</td>
</tr>
<tr class="calibre25">
<td class="calibre65">Provides node authentication</td>
<td class="calibre65">Provides user authentication</td>
</tr>

</tbody></table>

<h3 id="10.4" class="calibre7">10.4 Encrypting Data for Storage</h3>

<p class="calibre9">Encrypting data for storage and later retrieval can also be thought of in the
Alice and Bob model. Alice is still sending a message to Bob, but in this case
“Bob” is Alice at some future time. However, the problem is fundamentally
different.</p>

<p class="calibre9">In communications channels, messages in transit have no intrinsic value. If
Bob doesn’t receive a particular message, Alice can always resend it. This is
not true for data encrypted for storage. If Alice can’t decrypt her message, she
can’t go back in time and re-encrypt it. She has lost it forever. This means that
encryption applications for data storage should have some mechanisms to
prevent unrecoverable errors from creeping into the ciphertext.</p>

<p class="calibre9">The encryption key has the same value as the message, only it is smaller. In
effect, cryptography converts large secrets into smaller ones. Being smaller,
they can be easily lost. Key management procedures should assume that the
same keys will be used again and again, and that data may sit on a disk for
years before being decrypted.</p>

<p class="calibre9">Furthermore, the keys will be around for a long time. A key used on a
communications link should, ideally, exist only for the length of the
communication. A key used for data storage might be needed for years, and
hence must be stored securely for years.</p>

<p class="calibre9">Other problems particular to encrypting computer data for storage were listed
in [<a href="Applied%20Cryptography_split_035.html#r357" class="calibre5 pcalibre">357</a>]:</p>

<ul class="calibre13">

<li class="calibre14">The data may also exist in plaintext form, either on another disk, in
another computer, or on paper. There is much more opportunity for a
cryptanalyst to perform a known-plaintext attack.
</li>
<li class="calibre14">In database applications, pieces of data may be smaller than the
block size of most algorithms. This will cause the ciphertext to be
considerably larger than the plaintext.
</li>
<li class="calibre14">The speed of I/O devices demands fast encryption and decryption,
and will probably require encryption hardware. In some applications,
special high-speed algorithms may be required.
</li>
<li class="calibre14">Safe, long-term storage for keys is required.
</li>
<li class="calibre14">Key management is much more complicated, since different people
need access to different files, different portions of the same file, and so
forth.
</li>

</ul>

<p class="calibre9">If the encrypted files are not structured as records and fields, such as text files,
retrieval is easier: The entire file is decrypted before use. If the encrypted files
are database files, this solution is problematic. Decrypting the entire database
to access a single record is inefficient, but encrypting records independently
might be susceptible to a block-replay kind of attack.</p>

<p class="calibre9">In addition, you must make sure the unencrypted file is erased after encryption
(see <a href="#10.9" class="calibre5 pcalibre">Section 10.9</a>). For further details and insights, consult [<a href="Applied%20Cryptography_split_035.html#r425" class="calibre5 pcalibre">425</a>,<a href="Applied%20Cryptography_split_035.html#r569" class="calibre5 pcalibre">569</a>].</p>

<h4 class="calibre8">Dereferencing Keys</h4>

<p class="calibre9">When encrypting a large hard drive, you have two options. You can encrypt all
the data using a single key. This gives a cryptanalyst a large amount of
ciphertext to analyze and makes it impossible to allow multiple users to see
only parts of the drive. Or, you can encrypt each file with a different key,
forcing users to memorize a different key for each file.</p>

<p class="calibre9">The solution is to encrypt each file with a separate key, and to encrypt the keys
with another key known by the users. Each user only has to remember that one
key. Different users can have different subsets of the file-encryption keys
encrypted with their key. And there can even be a master key under which
every file-encryption key is encrypted. This is even more secure because the
file-encryption keys are random and less susceptible to a dictionary attack.</p>

<h4 class="calibre8">Driver-Level vs. File-Level Encryption</h4>

<p class="calibre9">There are two ways to encrypt a hard drive: at the file level and at the driver
level. Encryption at the file level means that every file is encrypted separately.
To use a file that’s been encrypted, you must first decrypt the file, then use it,
and then re-encrypt it.</p>

<p class="calibre9">Driver-level encryption maintains a logical drive on the user’s machine that
has all data on it encrypted. If done well, this can provide security that, beyond
choosing good passwords, requires little worry on the part of the user. The
driver must be considerably more complex than a simple file-encryption
program, however, because it must deal with the issues of being an installed
device driver, allocation of new sectors to files, recycling of old sectors from
files, random-access read and update requests for any data on the logical disk,
and so on.</p>

<p class="calibre9">Typically, the driver prompts the user for a password before starting up. This
is used to generate the master decryption key, which may then be used to
decrypt actual decryption keys used on different data.</p>

<h4 class="calibre8">Providing Random Access to an Encrypted Drive</h4>

<p class="calibre9">Most systems expect to be able to access individual disk sectors randomly.
This adds some complication for using many stream ciphers and block ciphers
in any chaining mode. Several solutions are possible.</p>

<p class="calibre9">Use the sector address to generate a unique IV for each sector being encrypted
or decrypted. The drawback is that each sector will always be encrypted with
the same IV. Make sure this is not a security problem.</p>

<p class="calibre9">For the master key, generate a pseudo-random block as large as one sector.
(You can do this by running an algorithm in OFB mode, for example.) To
encrypt any sector, first XOR in this pseudo-random block, then encrypt
normally with a block cipher in ECB mode. This is called ECB+OFB (see
<a href="Applied%20Cryptography_split_018.html#15.4" class="calibre5 pcalibre">Section 15.4</a>).</p>

<p class="calibre9">Since CBC and CFB are error-recovering modes, you can use all but the first
block or two in the sector to generate the IV for that sector. For example, the
IV for sector 3001 may be the hash of the all but the first 128 bits of the
sector’s data. After generating the IV, encrypt normally in CBC mode. To
decrypt the sector, you use the second 64-bit block of the sector as an IV, and
decrypt the remainder of the sector. Then, using the decrypted data, you
regenerate the IV and decrypt the first 128 bits.</p>

<p class="calibre9">You can use a block cipher with a large enough block size that it can encrypt
the whole sector at once. Crab (see <a href="Applied%20Cryptography_split_017.html#14.6" class="calibre5 pcalibre">Section 14.6</a>) is an example.</p>

<h3 id="10.5" class="calibre7">10.5 Hardware Encryption versus Software Encryption</h3>

<h4 class="calibre8">Hardware</h4>

<p class="calibre9">Until very recently, all encryption products were in the form of specialized
hardware. These encryption/decryption boxes plugged into a communications
line and encrypted all the data going across that line. Although software
encryption is becoming more prevalent today, hardware is still the
embodiment of choice for military and serious commercial applications. The
NSA, for example, only authorizes encryption in hardware. There are several
reasons why this is so.</p>

<table class="data-table1" id="table-10-5">
<caption class="calibre23">Table 10.5 - Comparing File-Level and Driver-Level Encryption</caption>
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre26">File-Level Encryption</th>
<th class="calibre26">Driver-Level Encryption</th>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Benefits:</td></tr>
<tr class="calibre25">
<td class="calibre64">
Ease of implementation and use. <br class="calibre3"/>
Flexible. <br class="calibre3"/>
Relatively small performance penalty. <br class="calibre3"/>
Users can move files between different machines without problems. <br class="calibre3"/>
Users can back files up without problems. 
</td>
<td class="calibre64">Temporary files, work files, and so forth can be kept on the secure drive. <br class="calibre3"/>
It’s harder to forget to re-encrypt something on this kind of system. 
</td>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Security Issues:</td></tr>
<tr class="calibre25">
<td class="calibre64">
Potential leakage through security-unconscious programs. (Program a device-driver or may write file to disk for temporary storage, for example.) <br class="calibre3"/>
Bad implementations may always re-encrypt with same key for same password.
</td>
<td class="calibre64">
Lots of things can go wrong with memory-resident program. <br class="calibre3"/>
Bad implementations will allow chosen-plaintext, or even chosen-ciphertext attacks. <br class="calibre3"/>
If whole system is master-keyed under one password, loss of that password means that the attacker gets everything. <br class="calibre3"/>
A more limited set of ciphers can reasonably be used for this kind of application. For example, OFB stream ciphers would not work.
</td>
</tr>
<tr class="calibre25"><td class="title2" colspan="2">Usability Problems:</td></tr>
<tr class="calibre25">
<td class="calibre65">
User has to figure out what to do. <br class="calibre3"/>
There may be different passwords for different files. <br class="calibre3"/>
Manual encryption of selected files is the only access control.
</td>
<td class="calibre65">
There will be a performance penalty. <br class="calibre3"/>
The driver may interact in weird ways with Windows, OS/2 DOS emulation, device drivers, and so on.
</td>
</tr>
</tbody></table>

<p class="calibre39">The first is speed. As we will see in Part III, encryption algorithms consist of
many complicated operations on plaintext bits. These are not the sorts of
operations that are built into your run-of-the-mill computer. The two most
common encryption algorithms, DES and RSA, run inefficiently on
general-purpose processors. While some cryptographers have tried to make
their algorithms more suitable for software implementation, specialized
hardware will always win a speed race.</p>

<p class="calibre9">Additionally, encryption is often a computation-intensive task. Tying up the
computer’s primary processor for this is inefficient. Moving encryption to
another chip, even if that chip is just another processor, makes the whole
system faster.</p>

<p class="calibre9">The second reason is security. An encryption algorithm running on a
generalized computer has no physical protection. Mallory can go in with
various debugging tools and surreptitiously modify the algorithm without
anyone ever realizing it. Hardware encryption devices can be securely
encapsulated to prevent this. Tamperproof boxes can prevent someone from
modifying a hardware encryption device. Special-purpose VLSI chips can be
coated with a chemical such that any attempt to access their interior will result
in the destruction of the chip’s logic. The U.S. government’s Clipper and
Capstone chips (see <a href="Applied%20Cryptography_split_028.html#24.16" class="calibre5 pcalibre">Sections 24.16</a> and <a href="Applied%20Cryptography_split_028.html#24.17" class="calibre5 pcalibre">24.17</a>) are designed to be tamperproof.
The chips can be designed so that it is impossible for Mallory to read the
unencrypted key.</p>

<p class="calibre9">IBM developed a cryptographic system for encrypting data and
communications on mainframe computers [<a href="Applied%20Cryptography_split_035.html#r515" class="calibre5 pcalibre">515</a>,<a href="Applied%20Cryptography_split_036.html#r1027" class="calibre5 pcalibre">1027</a>]. It includes
tamper-resistant modules to hold keys. This system is discussed in <a href="Applied%20Cryptography_split_028.html#24.1" class="calibre5 pcalibre">Section 24.1</a>.</p>

<p class="calibre9">Electromagnetic radiation can sometimes reveal what is going on inside a
piece of electronic equipment. Dedicated encryption boxes can be shielded, so
that they leak no compromising information. General-purpose computers can
be shielded as well, but it is a far more complex problem. The U.S. military
calls this <b class="calibre10">TEMPEST</b>; it’s a subject well beyond the scope of this book.</p>

<p class="calibre9">The final reason for the prevalence of hardware is the ease of installation. Most
encryption applications don’t involve general-purpose computers. People may
wish to encrypt their telephone conversations, facsimile transmissions, or data
links. It is cheaper to put special-purpose encryption hardware in the
telephones, facsimile machines, and modems than it is to put in a
microprocessor and software.</p>

<p class="calibre9">Even when the encrypted data comes from a computer, it is easier to install a
dedicated hardware encryption device than it is to modify the computer’s
system software. Encryption should be invisible; it should not hamper the user.
The only way to do this in software is to write encryption deep into the
operating system. This isn’t easy. On the other hand, even a computer
neophyte can plug an encryption box between his computer and his external
modem.</p>

<p class="calibre9">The three basic kinds of encryption hardware on the market today are:
self-contained encryption modules (that perform functions such as password
verification and key management for banks), dedicated encryption boxes for
communications links, and boards that plug into personal computers.</p>

<p class="calibre9">Some encryption boxes are designed for certain types of communications
links, such as T-1 encryption boxes that are designed not to encrypt
synchronization bits. There are different boxes for synchronous and
asynchronous communications lines. Newer boxes tend to accept higher bit
rates and are more versatile.</p>

<p class="calibre9">Even so, many of these devices have some incompatibilities. Buyers should be
aware of this and be well-versed in their particular needs, lest they find
themselves the owners of encryption equipment unable to perform the task at
hand. Pay attention to restrictions in hardware type, operating system,
applications software, network, and so forth.</p>

<p class="calibre9">PC-board encryptors usually encrypt everything written to the hard disk and
can be configured to encrypt everything sent to the floppy disk and serial port
as well. These boards are not shielded against electromagnetic radiation or
physical interference, since there would be no benefit in protecting the boards
if the computer remained unaffected.</p>

<p class="calibre9">More companies are starting to put encryption hardware into their
communications equipment. Secure telephones, facsimile machines, and
modems are all available.</p>

<p class="calibre9">Internal key management for these devices is generally secure, although there
are as many different schemes as there are equipment vendors. Some schemes
are more suited for one situation than another, and buyers should know what
kind of key management is incorporated into the encryption box and what they
are expected to provide themselves.</p>

<h4 class="calibre8">Software</h4>

<p class="calibre9">Any encryption algorithm can be implemented in software. The disadvantages
are in speed, cost, and ease of modification (or manipulation). The advantages
are in flexibility and portability, ease of use, and ease of upgrade. The
algorithms written in C at the end of this book can be implemented, with little
modification, on any computer. They can be inexpensively copied and
installed on many machines. They can be incorporated into larger applications,
such as communications programs or word processors.</p>

<p class="calibre9">Software encryption programs are popular and are available for all major
operating systems. These are meant to protect individual files; the user
generally has to manually encrypt and decrypt specific files. It is important
that the key management scheme be secure: The keys should not be stored on
disk anywhere (or even written to a place in memory from where the processor
swaps out to disk). Keys and unencrypted files should be erased after
encryption. Many programs are sloppy in this regard, and a user has to choose
carefully.</p>

<p class="calibre9">Of course, Mallory can always replace the software encryption algorithm with
something lousy. But for most users, that isn’t a problem. If Mallory can break
into our office and modify our encryption program, he can also put a hidden
camera on the wall, a wiretap on the telephone, and a TEMPEST detector
down the street. If Mallory is that much more powerful than the user, the user
has lost the game before it starts.</p>

<h3 id="10.6" class="calibre7">10.6 Compression, Encoding, and Encryption</h3>

<p class="calibre9">Using a data compression algorithm together with an encryption algorithm
makes sense for two reasons:</p>

<p class="quote">Cryptanalysis relies on exploiting redundancies in the plaintext;
compressing a file before encryption reduces these redundancies.<br class="calibre3"/>
Encryption is time-consuming; compressing a file before encryption
speeds up the entire process.</p>

<p class="calibre9">The important thing to remember is to compress before encryption. If the
encryption algorithm is any good, the ciphertext will not be compressible; it
will look like random data. (This makes a reasonable test of an encryption
algorithm; if the ciphertext can be compressed, then the algorithm probably
isn’t very good.)</p>

<p class="calibre9">If you are going to add any type of transmission encoding or error detection
and recovery, remember to add that after encryption. If there is noise in the
communications path, decryption’s error-extension properties will only make
that noise worse. Figure 10.3 summarizes these steps.</p>

<div class="figure" id="figure-10-3">
<div class="image1">
<p class="calibre9"><img src="ac-figure-10-3.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 10.3</b> Encryption with compression and error control.</i></p>
</div>

<h3 id="10.7" class="calibre7">10.7 Detecting Encryption</h3>

<p class="calibre9">How does Eve detect an encrypted file? Eve is in the spy business, so this is an
important question. Imagine that she’s eavesdropping on a network where
messages are flying in all directions at high speeds; she has to pick out the
interesting ones. Encrypted files are certainly interesting, but how does she
know they are encrypted?</p>

<p class="calibre9">Generally, she relies on the fact that most popular encryption programs have
well-defined headers. Electronic-mail messages encrypted with either PEM or
PGP (see Sections <a href="Applied%20Cryptography_split_028.html#24.10" class="calibre5 pcalibre">24.10</a> and <a href="Applied%20Cryptography_split_028.html#24.12" class="calibre5 pcalibre">24.12</a>) are easy to identify for that reason.</p>

<p class="calibre9">Other file encryptors just produce a ciphertext file of seemingly random bits.
How can she distinguish it from any other file of seemingly random bits?
There is no sure way, but Eve can try a number of things:</p>

<ul class="calibre13">

<li class="calibre14">Examine the file. ASCII text is easy to spot. Other file formats, such
as TIFF, TeX, C, Postscript, G3 facsimile, or Microsoft Excel, have
standard identifying characteristics. Executable code is detectable, as
well. UNIX files often have “magic numbers” that can be detected.
</li>
<li class="calibre14">Try to uncompress the file, using the major compression algorithms.
If the file is compressed (and not encrypted), this should yield the original file.
</li>
<li class="calibre14">Try to compress the file. If the file is ciphertext (and the algorithm is
good), then the probability that the file can be appreciably compressed by a
general-purpose compression routine is small. (By appreciably, I mean more
than 1 or 2 percent.) If it is something else (a binary image or a binary data
file, for example) it probably can be compressed.
</li>

</ul>

<p class="calibre9">Any file that cannot be compressed and is not already compressed is probably
ciphertext. (Of course, it is possible to specifically make ciphertext that is
compressible.) Identifying the algorithm is a whole lot harder. If the algorithm
is good, you can’t. If the algorithm has some slight biases, it might be possible
to recognize those biases in the file. However, the biases have to be pretty
significant or the file has to be pretty big in order for this to work.</p>

<h3 id="10.8" class="calibre7">10.8 Hiding Ciphertext in Ciphertext</h3>

<p class="calibre9">Alice and Bob have been sending encrypted messages to each other for the
past year. Eve has been collecting them all, but she cannot decrypt any of
them. Finally, the secret police tire of all this unreadable ciphertext and arrest
the pair. “Give us your encryption keys,” they demand. Alice and Bob refuse,
but then they notice the thumbscrews. What can they do?</p>

<p class="calibre9">Wouldn’t it be nice to be able to encrypt a file such that there are two possible
decryptions, each with a different key. Alice could encrypt a real message to
Bob in one of the keys and some innocuous message in the other key. If Alice
were caught, she could surrender the key to the innocuous message and keep
the real key secret.</p>

<p class="calibre9">The easiest way to do this is with one-time pads. Let <i class="calibre12">P</i> be the plaintext, <i class="calibre12">D</i> the dummy plaintext, <i class="calibre12">C</i> the ciphertext, <i class="calibre12">K</i> the real key, and <i class="calibre12">K’</i> the dummy key.
Alice encrypts <i class="calibre12">P</i>:</p>

<p class="math"><i class="calibre12">P</i> ⊕ <i class="calibre12">K</i> = <i class="calibre12">C</i>
</p>

<p class="calibre9">Alice and Bob share <i class="calibre12">K</i>, so Bob can decrypt <i class="calibre12">C</i>:</p>

<p class="math"><i class="calibre12">C</i> ⊕ <i class="calibre12">K</i> = <i class="calibre12">P</i>
</p>

<p class="calibre9">If the secret police ever force them to surrender their key, they don’t surrender
 <i class="calibre12">K</i>, but instead surrender:</p>

<p class="math"><i class="calibre12">K’</i> = <i class="calibre12">C</i> ⊕ <i class="calibre12">D</i>
</p>

<p class="calibre9">The police then recover the dummy plaintext:</p>

<p class="math"><i class="calibre12">C</i> ⊕ <i class="calibre12">K’</i> = <i class="calibre12">D</i>
</p>

<p class="calibre9">Since these are one-time pads and <i class="calibre12">K</i> is completely random, there is no way to
prove that <i class="calibre12">K’</i> was not the real key. To make matters more convincing, Alice
and Bob should concoct some mildly incriminating dummy messages to take
the place of the really incriminating real messages. A pair of Israeli spies once
did this.</p>

<p class="calibre9">Alice could take <i class="calibre12">P</i> and encrypt it with her favorite algorithm and key <i class="calibre12">K</i> to get <i class="calibre12">C</i>. Then she takes <i class="calibre12">C</i> and XORs it with some piece of mundane
plaintext — <i class="calibre12">Pride and Prejudice</i> for example, to get <i class="calibre12">K’</i>. She stores both <i class="calibre12">C</i> and the XOR on her hard disk. Now, when the secret police interrogate her, she
can explain that she is an amateur cryptographer and that <i class="calibre12">K’</i> is a merely
one-time pad for <i class="calibre12">C</i>. The secret police might suspect something, but unless they know <i class="calibre12">K</i> they cannot prove that Alice’s explanation isn’t valid.</p>

<p class="calibre9">Another method is to encrypt <i class="calibre12">P</i> with a symmetric algorithm and <i class="calibre12">K</i>, and <i class="calibre12">D</i> with <i class="calibre12">K’</i>. Intertwine bits (or bytes) of the ciphertext to make the final ciphertexts. If the secret police demand the key, Alice gives them <i class="calibre12">K’</i> and says that the
alternating bits (or bytes) are random noise designed to frustrate cryptanalysis.
The trouble is the explanation is so implausible that the secret police will
probably not believe her (especially considering it is suggested in this book).</p>

<p class="calibre9">A better way is for Alice to create a dummy message, <i class="calibre12">D</i>, such that the
concatenation of <i class="calibre12">P</i> and <i class="calibre12">D</i>, compressed, is about the same size as <i class="calibre12">D</i>. Call this concatenation <i class="calibre12">P’</i>. Alice then encrypts <i class="calibre12">P’</i> with whatever algorithm she and Bob share to get <i class="calibre12">C</i>. Then she sends <i class="calibre12">C</i> to Bob. Bob decrypts <i class="calibre12">C</i> to get <i class="calibre12">P’</i>, and then <i class="calibre12">P</i>
and <i class="calibre12">D</i>. Then they both compute <i class="calibre12">C</i> ⊕ <i class="calibre12">D</i> = <i class="calibre12">K’</i>. This <i class="calibre12">K’</i> becomes the dummy one-time pad they use in case the secret police break their doors down. Alice
has to transmit <i class="calibre12">D</i> so that hers and Bob’s alibis match.</p>

<p class="calibre9">Another method is for Alice to take an innocuous message and run it through
some error-correcting code. Then she can introduce errors that correspond to
the secret encrypted message. On the receiving end, Bob can extract the errors
to reconstruct the secret message and decrypt it. He can also use the
error-correcting code to recover the innocuous message. Alice and Bob might
be hard pressed to explain to the secret police why they consistently get a 30
percent bit-error rate on an otherwise noise-free computer network, but in
some circumstances this scheme can work.</p>

<p class="calibre9">Finally, Alice and Bob can use the subliminal channels in their digital
signature algorithms (see <a href="Applied%20Cryptography_split_005.html#4.2" class="calibre5 pcalibre">Sections 4.2</a> and <a href="Applied%20Cryptography_split_026.html#23.3" class="calibre5 pcalibre">23.3</a>). This is undetectable, works
great, but has the drawback of only allowing 20 or so characters of subliminal
text to be sent per signed innocuous message. It really isn’t good for much
more than sending keys.</p>

<h3 id="10.9" class="calibre7">10.9 Destroying Information</h3>

<p class="calibre9">When you delete a file on most computers, the file isn’t really deleted. The
only thing deleted is an entry in the disk’s index file, telling the machine that
the file is there. Many software vendors have made a fortune selling
file-recovery software that recovers files after they have been deleted.</p>

<p class="calibre9">And there’s yet another worry: Virtual memory means your computer can read
and write memory to disk any time. Even if you don’t save it, you never know
when a sensitive document you are working on is shipped off to disk. This
means that even if you never save your plaintext data, your computer might do
it for you. And driver-level compression programs like Stacker and
DoubleSpace can make it even harder to predict how and where information is
stored on a disk.</p>

<p class="calibre9">To erase a file so that file-recovery software cannot read it, you have to
physically write over all of the file’s bits on the disk. According to the
National Computer Security Center [<a href="Applied%20Cryptography_split_036.html#r1148" class="calibre5 pcalibre">1148</a>]:</p>

<p class="quote">Overwriting is a process by which unclassified data are written to
storage locations that previously held sensitive data.... To purge
the...storage media, the DoD requires overwriting with a pattern,
then its complement, and finally with another pattern; e.g.,
overwrite first with 0011 0101, followed by 1100 1010, then 1001
0111. The number of times an overwrite must be accomplished
depends on the storage media, sometimes on its sensitivity, and
sometimes on different DoD component requirements. In any
case, a purge is not complete until a final overwrite is made using
unclassified data.</p>

<p class="calibre9">You may have to erase files or you may have to erase entire drives. You
should also erase all unused space on your hard disk.</p>

<p class="calibre9">Most commercial programs that claim to implement the DoD standard
overwrite three times: first with all ones, then with all zeros, and finally with a
repeating one-zero pattern. Given my general level of paranoia, I recommend
overwriting a deleted file seven times: the first time with all ones, the second
time with all zeros, and five times with a cryptographically secure
pseudo-random sequence. Recent developments at the National Institute of
Standards and Technology with electron-tunneling microscopes suggest even
that might not be enough. Honestly, if your data is sufficiently valuable,
assume that it is <i class="calibre12">impossible</i> to erase data completely off magnetic media. Burn or shred the media; it’s cheaper to buy media new than to lose your secrets.</p>

<div class="calibre6" id="calibre_pb_24"></div>
</div>






</body></html>
