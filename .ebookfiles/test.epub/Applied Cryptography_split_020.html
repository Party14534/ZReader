<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="17">Chapter 17 <br class="calibre3"/>
Other Stream Ciphers and Real Random-Sequence Generators</h1>

<h3 id="17.1" class="calibre7">17.1 RC4</h3>

<p class="calibre9">RC4 is a variable-key-size stream cipher developed in 1987 by Ron Rivest for
RSA Data Security, Inc. For seven years it was proprietary, and details of the
algorithm were only available after signing a nondisclosure agreement.</p>

<p class="calibre9">In September, 1994 someone posted source code to the Cypherpunks mailing
list — anonymously. It quickly spread to the Usenet newsgroup sci.crypt, and
via the Internet to ftp sites around the world. Readers with legal copies of RC4
confirmed compatibility. RSA Data Security, Inc. tried to put the genie back
into the bottle, claiming that it was still a trade secret even though it was
public; it was too late. It has since been discussed and dissected on Usenet,
distributed at conferences, and taught in cryptography courses.</p>

<p class="calibre9">RC4 is simple to describe. The algorithm works in OFB: The keystream is
independent of the plaintext. It has a 8 * 8 S-box: <i class="calibre12">S</i><sub class="calibre15">0</sub>, <i class="calibre12">S</i><sub class="calibre15">1</sub>, ..., <i class="calibre12">S</i><sub class="calibre15">255</sub>. The entries are a permutation of the numbers 0 through 255, and the permutation is a
function of the variable-length key. It has two counters, <i class="calibre12">i</i> and <i class="calibre12">j</i>, initialized to zero.</p>

<p class="calibre9">To generate a random byte, do the following:</p>

<p class="math-left"><i class="calibre12">i</i> = (<i class="calibre12">i</i> + 1) mod 256
<i class="calibre12">j</i> = (<i class="calibre12">j</i> + <i class="calibre12">S</i><sub class="calibre15">i</sub>) mod 256
swap <i class="calibre12">S</i><sub class="calibre15">i</sub> and <i class="calibre12">S</i><sub class="calibre15">j</sub>
<i class="calibre12">t</i> = (<i class="calibre12">S</i><sub class="calibre15">i</sub> + <i class="calibre12">S</i><sub class="calibre15">j</sub>) mod 256
<i class="calibre12">K</i> = <i class="calibre12">S</i><sub class="calibre15">t</sub>
</p>

<p class="calibre9">The byte <i class="calibre12">K</i> is XORed with the plaintext to produce ciphertext or XORed with
the ciphertext to produce plaintext. Encryption is fast — about 10 times faster
than DES.</p>

<p class="calibre9">Initializing the S-box is also easy. First, fill it linearly: <i class="calibre12">S</i><sub class="calibre15">0</sub> = 0, <i class="calibre12">S</i><sub class="calibre15">1</sub> = 1, ..., <i class="calibre12">S</i><sub class="calibre15">255</sub> =
255. Then fill another 256-byte array with the key, repeating the key as
necessary to fill the entire array: <i class="calibre12">K</i><sub class="calibre15">0</sub>, <i class="calibre12">K</i><sub class="calibre15">1</sub>, ..., <i class="calibre12">K</i><sub class="calibre15">255</sub>. Set the index <i class="calibre12">j</i> to zero. Then:</p>

<p class="math-left">for <i class="calibre12">i</i> = 0 to 255:
<i class="calibre12">j</i> = (<i class="calibre12">j</i> + <i class="calibre12">S</i><sub class="calibre15">i</sub> + <i class="calibre12">K</i><sub class="calibre15">i</sub>) mod 256
swap <i class="calibre12">S</i><sub class="calibre15">i</sub> and <i class="calibre12">S</i><sub class="calibre15">j</sub>
</p>

<p class="calibre9">And that’s it. RSADSI claims that the algorithm is immune to differential and
linear cryptanalysis, doesn’t seem to have any small cycles, and is highly
nonlinear. (There are no public cryptanalytic results. RC4 can be in about
2<sup class="calibre19">1700</sup> (256! × 256<sup class="calibre19">2</sup>) possible states: an enormous number.) The S-box slowly
evolves with use: <i class="calibre12">i</i> ensures that every element changes and <i class="calibre12">j</i> ensures that the elements change randomly. The algorithm is simple enough that most
programmers can quickly code it from memory.</p>

<p class="calibre9">It should be possible to generalize this idea to larger S-boxes and word sizes.
The previous version is 8-bit RC4. There’s no reason why you can’t define
16-bit RC4 with a 16 * 16 S-box (100K of memory) and a 16-bit word. You’d
have to iterate the initial setup a lot more times — 65,536 to keep with the
stated design — but the resulting algorithm should be faster.</p>

<p class="calibre9">RC4 has special export status if its key length is 40 bits or under (see <a href="Applied%20Cryptography_split_016.html#13.8" class="calibre5 pcalibre">Section 13.8</a>). 
This special export status has nothing to do with the secrecy of the
algorithm, although RSA Data Security, Inc. has hinted for years that it does.
The name is trademarked, so anyone who writes his own code has to call it
something else. Various internal documents by RSA Data Security, Inc. have
not yet been made public [<a href="Applied%20Cryptography_split_036.html#r1320" class="calibre5 pcalibre">1320</a>,<a href="Applied%20Cryptography_split_036.html#r1337" class="calibre5 pcalibre">1337</a>].</p>

<p class="calibre9">So, what’s the deal with RC4? It’s no longer a trade secret, so presumably
anyone can use it. However, RSA Data Security, Inc. will almost certainly sue
anyone who uses unlicensed RC4 in a commercial product. They probably
won’t win, but they will certainly make it cheaper for a company to license
than fight.</p>

<p class="calibre9">RC4 is in dozens of commercial cryptography products, including Lotus
Notes, Apple Computer’s AOCE, and Oracle Secure SQL. It is part of the
Cellular Digital Packet Data specification [<a href="Applied%20Cryptography_split_035.html#r37" class="calibre5 pcalibre">37</a>].</p>

<h3 id="17.2" class="calibre7">17.2 SEAL</h3>

<p class="calibre9">SEAL is a software-efficient stream cipher designed at IBM by Phil Rogaway
and Don Coppersmith [<a href="Applied%20Cryptography_split_036.html#r1340" class="calibre5 pcalibre">1340</a>]. The algorithm was optimized for 32-bit
processors: To run well it needs eight 32-bit registers and a cache of a few
kilobytes. Using a relatively slow operation, SEAL preprocesses the key
operation into a set of tables. These tables are then used to speed up encryption
and decryption.</p>

<h4 class="calibre8">Pseudo-random Function Family</h4>

<p class="calibre9">One novel feature of SEAL is that is isn’t really a traditional stream cipher: it
is a <b class="calibre10">pseudo-random function family</b>. Given a 160-bit key <i class="calibre12">k</i>, and a 32-bit <i class="calibre12">n</i>, SEAL stretches <i class="calibre12">n</i> into an <i class="calibre12">L-</i> bit string <i class="calibre12">k</i>(<i class="calibre12">n</i>). <i class="calibre12">L</i> can take any value less than 64
kilobytes. SEAL is supposed to enjoy the property that if <i class="calibre12">k</i> is selected at
random, then <i class="calibre12">k(n</i>) should be computationally indistinguishable from a random
<i class="calibre12">L-</i>bit function of <i class="calibre12">n</i>.</p>

<p class="calibre9">The practical effect of SEAL being a pseudo-random function family is that it
is useful in applications where traditional stream ciphers are not. With most
stream ciphers you generate a sequence of bits in one direction: Knowing the
key and a position <i class="calibre12">i</i>, the only way to determine the <i class="calibre12">i</i>th bit generated is to generate all the bits up until the <i class="calibre12">i</i>th one. But a pseudo-random function family is different: You get easy access at any desired position in the key stream. This
is very useful.</p>

<p class="calibre9">Imagine you need to secure a hard drive. You want to encrypt each and every
512-byte sector. With a pseudo-random function family like SEAL, you can
encrypt the contents of sector <i class="calibre12">n</i> by XORing it with <i class="calibre12">k</i>(<i class="calibre12">n</i>). It is as though the entire disk is XORed with a long pseudo-random string, where any piece of
that long string can be computed without any trouble.</p>

<p class="calibre9">A pseudo-random function family also simplifies the synchronization problem
encountered with standard stream ciphers. Suppose you send encrypted
messages over a channel that sometimes drops messages. With a
pseudo-random function family, you can encrypt under <i class="calibre12">k</i> the <i class="calibre12">n</i> th message you transmit, <i class="calibre12">x</i><sub class="calibre15">n</sub>, as <i class="calibre12">n</i> together with the XOR of <i class="calibre12">x</i><sub class="calibre15">n</sub> and <i class="calibre12">k</i>(<i class="calibre12">n</i>). The receiver doesn’t need to store any state to recover <i class="calibre12">x</i><sub class="calibre15">n</sub>, nor does he need to worry about lost
messages affecting the message decryption process.</p>

<h4 class="calibre8">Description of SEAL</h4>

<p class="calibre9">The inner loop of SEAL is shown by Figure 17.1. Three key-derived tables,
called <i class="calibre12">R, S</i>, and <i class="calibre12">T</i>, drive the algorithm. The preprocessing step maps the key <i class="calibre12">k</i>, to these tables using a procedure based on SHA (see <a href="Applied%20Cryptography_split_021.html#18.7" class="calibre5 pcalibre">Section 18.7</a>). The
2-kilobyte table, <i class="calibre12">T</i>, is a 9 * 32 bit S-box.</p>

<div class="figure" id="figure-17-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-1.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.1</b> The inner loop of SEAL.</i></p>
</div>

<p class="calibre9">SEAL also uses four 32-bit registers, <i class="calibre12">A, B, C</i>, and <i class="calibre12">D</i>, whose initial values are determined by <i class="calibre12">n</i> and the <i class="calibre12">k-</i> derived tables <i class="calibre12">R</i> and <i class="calibre12">T</i>. These registers get modified over several iterations, each one involving 8 rounds. In each round 9 bits of a
first register (either <i class="calibre12">A, B, C</i>, or <i class="calibre12">D</i>) are used to index into table <i class="calibre12">T</i>. The value retrieved from <i class="calibre12">T</i> is then added to or XORed with the contents of a second
register: again one of <i class="calibre12">A, B, C</i>, or <i class="calibre12">D</i>. The first register is then circularly shifted by nine positions. In some rounds the second register is further modified by
adding or XORing it with the (now shifted) first register. After 8 rounds of
this, <i class="calibre12">A, B, C</i>, and <i class="calibre12">D</i> are added to the keystream, each masked first by adding or XORing it with a certain word from <i class="calibre12">S</i>. The iteration is completed by adding to
<i class="calibre12">A</i> and <i class="calibre12">C</i> additional values dependent on <i class="calibre12">n</i>, <i class="calibre12">n</i><sub class="calibre15">1</sub>, <i class="calibre12">n</i><sub class="calibre15">2</sub>, <i class="calibre12">n</i><sub class="calibre15">3</sub>, <i class="calibre12">n</i><sub class="calibre15">4</sub>; exactly which one depends on the parity of the iteration number.</p>

<p class="calibre9">The important ideas in this design seem to be:</p>

<ol class="calibre17">

<li class="calibre14">Use a large, secret, key-derived S-box (<i class="calibre12">T</i>).
</li>
<li class="calibre14">Alternate arithmetic operations which don’t commute (addition and
XOR).
</li>
<li class="calibre14">Use an internal state maintained by the cipher which is not directly
manifest in the data stream (the <i class="calibre12">n</i><sub class="calibre15">i</sub> values which modify <i class="calibre12">A</i> and <i class="calibre12">C</i> at the end of each iteration).
</li>
<li class="calibre14">Vary the round function according to the round number, and vary the
iteration function according to the iteration number.
</li>

</ol>

<p class="calibre9">SEAL requires about five elementary machine operations to encrypt each byte
of text. It runs at 58 megabits per second on a 50 megahertz 486 machine. This
is probably the fastest software algorithm in the book.</p>

<p class="calibre9">On the other hand, SEAL must preprocess its key into internal tables. These
tables total roughly 3 kilobytes in size, and their calculation takes about 200
SHA computations. Thus, SEAL is not appropriate to use in situations where
you don’t have the time to perform the key setup or you don’t have the
memory to store the tables.</p>

<h4 class="calibre8">Security of SEAL</h4>

<p class="calibre9">SEAL is a new algorithm and has yet to be subjected to any published
cryptanalysis. This suggests caution. However, SEAL seems to be well
thought through. Its peculiarities do, in the end, make a good deal of sense.
And Don Coppersmith is generally regarded as the world’s cleverest
cryptanalyst.</p>

<h4 class="calibre8">Patents and Licenses</h4>

<p class="calibre9">SEAL is being patented [<a href="Applied%20Cryptography_split_035.html#r380" class="calibre5 pcalibre">380</a>]. Anyone wishing to license SEAL should
contact the <code class="calibre18">Director of Licenses, IBM Corporation, 500 Columbus Ave.,
Thurnwood, NY, 10594</code>.</p>

<h3 id="17.3" class="calibre7">17.3 WAKE</h3>

<p class="calibre9">WAKE is the Word Auto Key Encryption algorithm, invented by David
Wheeler [<a href="Applied%20Cryptography_split_036.html#r1589" class="calibre5 pcalibre">1589</a>]. It produces a stream of 32-bit words which can be XORed
with a plaintext stream to produce ciphertext, or XORed with a ciphertext
stream to produce plaintext. And it’s fast.</p>

<p class="calibre9">WAKE works in CFB; the previous ciphertext word is used to generate the
next key word. It also uses an S-box of 256 32-bit values. This S-box has a
special property: The high-order byte of all the entries is a permutation of all
possible bytes, and the low-order 3 bytes are random.</p>

<p class="calibre9">First, generate the S-box entries, <i class="calibre12">S</i><sub class="calibre15">i</sub>, from the key. Then initialize four registers with the key (or with another key): <i class="calibre12">a</i><sub class="calibre15">0</sub>, <i class="calibre12">b</i><sub class="calibre15">0</sub>, <i class="calibre12">c</i><sub class="calibre15">0</sub>, and <i class="calibre12">d</i><sub class="calibre15">0</sub>. To generate a 32-bit keystream word, <i class="calibre12">K</i><sub class="calibre15">i</sub>:</p>

<p class="math"><i class="calibre12">K</i><sub class="calibre15">i</sub> = <i class="calibre12">d</i><sub class="calibre15">i</sub>
</p>

<p class="calibre9">The ciphertext word <i class="calibre12">C</i><sub class="calibre15">i</sub>, is the plaintext word, <i class="calibre12">P</i><sub class="calibre15">i</sub> XORed with <i class="calibre12">K</i><sub class="calibre15">i</sub>.</p>

<p class="calibre9">Then, update the four registers:</p>

<p class="math-left"><i class="calibre12">a</i><sub class="calibre15">i+1</sub> = M(<i class="calibre12">a</i><sub class="calibre15">i</sub>, <i class="calibre12">d</i><sub class="calibre15">i</sub>)
<i class="calibre12">b</i><sub class="calibre15">i+1</sub> = M(<i class="calibre12">b</i><sub class="calibre15">i</sub>, <i class="calibre12">a</i><sub class="calibre15">i+1</sub>)
<i class="calibre12">c</i><sub class="calibre15">i+1</sub> = M(<i class="calibre12">c</i><sub class="calibre15">i</sub>, <i class="calibre12">b</i><sub class="calibre15">i+1</sub>)
<i class="calibre12">d</i><sub class="calibre15">i+1</sub> = M(<i class="calibre12">d</i><sub class="calibre15">i</sub>, <i class="calibre12">c</i><sub class="calibre15">i+1</sub>)
</p>

<p class="calibre9">Function M is</p>

<p class="math">M(<i class="calibre12">x,y</i>) = (<i class="calibre12">x</i> + <i class="calibre12">y</i>) &gt;&gt; 8 ⊕ <i class="calibre12">S</i><sub class="calibre15">(<i class="calibre22">x+y</i>) ^ 255</sub>
</p>

<p class="calibre9">This is shown in Figure 17.2. The operation &gt;&gt; is a right shift, not a rotation.
The low-order 8 bits of <i class="calibre12">x</i> + <i class="calibre12">y</i> are the input into the S-box. Wheeler gives a procedure for generating the S-box, but it isn’t really complete. Any algorithm
to generate random bytes and a random permutation will work.</p>

<div class="figure" id="figure-17-2">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-2.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.2</b> Wake.</i></p>
</div>

<p class="calibre9">WAKE’s biggest asset is that it is fast. However, it’s insecure against a
chosen-plaintext or chosen-ciphertext attack. It is being used in the current
version of Dr. Solomon’s Anti-Virus program.</p>

<h3 id="17.4" class="calibre7">17.4 Feedback with Carry Shift Registers</h3>

<p class="calibre9">A feedback with carry shift register, or FCSR, is similar to a LFSR. Both have
a shift register and a feedback function; the difference is that a FCSR also has
a carry register (see Figure 17.3). Instead of XORing all the bits in the tap
sequence, add the bits together and add in the contents of the carry register.
The result mod 2 becomes the new bit. The result divided by 2 becomes the
new content of the carry register.</p>

<div class="figure" id="figure-17-3">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-3.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.3</b> Feedback with carry shift register.</i></p>
</div>

<p class="calibre9">Figure 17.4 is an example of a 3-bit FCSR tapped at the first and second bit.
Its initial value is 001, and the initial contents of the carry register is 0. The
output bit is the right-most bit of the shift register.</p>

<table class="calibre90">
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre91">Shift Register</th>
<th class="calibre91">Carry Register</th>
</tr>
<tr class="calibre25"><td class="calibre92">0 0 1</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">1 0 0</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">0 1 0</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">1 0 1</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">1 1 0</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">1 1 1</td><td class="calibre92">0</td></tr>
<tr class="calibre25"><td class="calibre92">0 1 1</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">1 0 1</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">0 1 0</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">0 0 1</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">0 0 0</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">1 0 0</td><td class="calibre92">0</td></tr>
</tbody></table>

<div class="figure" id="figure-17-4">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-4.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.4</b> 3-bit FCSR.</i></p>
</div>

<p class="calibre9">Note that the final internal state (including the contents of the carry register) is
the same as the second internal state. The sequence cycles at this point, and has
a period of 10.</p>

<p class="calibre9">There are a few things to note here. First, the carry register is not a single bit; it is a number. The size of the carry register must be at least <i class="calibre12">log</i><sub class="calibre15">2</sub><i class="calibre12">t</i>, where <i class="calibre12">t</i> is the number of taps. There are only two taps in the previous example, so the carry
register only has to be 1 bit wide. If there were four taps, the carry register
would have to be 2 bits wide, and could be either 0, 1, 2, or 3.</p>

<p class="calibre9">Second, there is an initial transient before the FCSR settles down into its
repeating period. In the previous example, only one state never repeated. For
larger and more complicated FCSRs, there may be more.</p>

<p class="calibre9">Third, the maximum period of a FCSR is not 2<sup class="calibre19">n</sup> - 1, where <i class="calibre12">n</i> is the length of
the shift register. The maximum period is <i class="calibre12">q</i> - 1, where <i class="calibre12">q</i> is the <b class="calibre10">connection</b> <b class="calibre10">integer</b>. This number gives the taps and is defined by:</p>

<p class="math"><i class="calibre12">q</i> = 2 <i class="calibre12">q</i><sub class="calibre15">1</sub> + 2<sup class="calibre19">2</sup><i class="calibre12">q</i><sub class="calibre15">2</sub> + 2<sup class="calibre19">4</sup><i class="calibre12">q</i><sub class="calibre15">4</sub> + ... + 2<sup class="calibre19">n</sup><i class="calibre12">q</i><sub class="calibre15">n - 1</sub>
</p>

<p class="calibre9">(Yes, the <i class="calibre12">q</i> is are numbered from left to right.) And even worse, <i class="calibre12">q</i> has to be a prime for which 2 is a primitive root. The rest of this discussion assumes <i class="calibre12">q</i> is of this form.</p>

<p class="calibre9">In this example, <i class="calibre12">q</i> = 2*0 + 4*1 + 8*1 - 1 = 11. And 11 is a prime with 2 as a
primitive root. So the maximum period is 10.</p>

<p class="calibre9">Not all initial states give you the maximum period. For example, look at the
FCSR when the initial value is 101 and the carry register is set to 4.</p>

<table class="calibre90">
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre91">Shift Register</th>
<th class="calibre91">Carry Register</th>
</tr>
<tr class="calibre25"><td class="calibre92">1 0 1</td><td class="calibre92">4</td></tr>
<tr class="calibre25"><td class="calibre92">1 1 0</td><td class="calibre92">2</td></tr>
<tr class="calibre25"><td class="calibre92">1 1 1</td><td class="calibre92">1</td></tr>
<tr class="calibre25"><td class="calibre92">1 1 1</td><td class="calibre92">1</td></tr>
</tbody></table>

<p class="calibre9">At this point the register spits out a neverending stream of 1s.</p>

<p class="calibre9">Any initial state will result in one of four things. First, it is part of the
maximum period. Second, it will fall into the maximum period after an initial
transient. Third, it will fall into a sequence of all zeros after an initial transient.</p>

<p class="calibre9">Fourth, it will fall into a sequence of all ones after an initial transient.
There is a mathematical formula for determining what will happen to a given
initial state, but it’s much easier to just test it. Run the FCSR for a while. (If <i class="calibre12">m</i> is the initial memory, and <i class="calibre12">t</i> is the number of taps, then <i class="calibre12">log</i><sub class="calibre15">2</sub>(<i class="calibre12">t</i>) + <i class="calibre12">log</i><sub class="calibre15">2</sub>(<i class="calibre12">m</i>) + 1
steps are enough.) If it degenerates into a neverending stream of 0s or 1s
within <i class="calibre12">n</i> bits, where <i class="calibre12">n</i> is the length of the FCSR, don’t use it. If it doesn’t, then use it. Since the initial state of a FCSR corresponds to the key of the stream
cipher, this means that a FCSR-based generator will have a set of weak keys.</p>

<p class="calibre9">Table 17.1 lists all connection integers less than 10,000 for which 2 is a
primitive root. These all have maximum period <i class="calibre12">q</i> - 1. To turn one of these
numbers into a tap sequence, calculate the binary expansion of <i class="calibre12">q</i> + 1. For
example, 9949 would translate to taps on bits 1, 2, 3, 4, 6, 7, 9, 10, and 13,
because</p>

<p class="math">9950 = 2<sup class="calibre19">13</sup> + 2<sup class="calibre19">10</sup> + 2<sup class="calibre19">9</sup> + 2<sup class="calibre19">7</sup> + 2<sup class="calibre19">6</sup> + 2<sup class="calibre19">4</sup> + 2<sup class="calibre19">3</sup> + 2<sup class="calibre19">2</sup> + 2<sup class="calibre19">1</sup>
</p>

<p class="calibre9">Table 17.2 lists <i class="calibre12">all</i> the 4-tap tap sequences that result in a maximal-length
FCSR for shift register lengths of 32 bits, 64 bits, and 128 bits. Each of the
four values, <i class="calibre12">a, b, c</i>, and <i class="calibre12">d</i>, combine to generate <i class="calibre12">q</i>, a prime for which 2 is primitive.</p>

<p class="math"><i class="calibre12">q</i> = 2<sup class="calibre19"><i class="calibre22">a</i></sup> + 2<sup class="calibre19"><i class="calibre22">b</i></sup> + 2<sup class="calibre19"><i class="calibre22">c</i></sup> + 2<sup class="calibre19"><i class="calibre22">d</i></sup> - 1
</p>

<p class="calibre9">Any of these tap sequences can be used to create a FCSR with period <i class="calibre12">q</i> - 1.</p>

<table class="data-table1" id="table-17-1">
<caption class="calibre67">Table 17.1 - Connection Integers for Maximal-period FCSRs</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="calibre69">2</td><td class="calibre69">653</td><td class="calibre69">1549</td><td class="calibre69">2477</td><td class="calibre69">3539</td></tr>
<tr class="calibre25"><td class="calibre70">5</td><td class="calibre70">659</td><td class="calibre70">1571</td><td class="calibre70">2531</td><td class="calibre70">3547</td></tr>
<tr class="calibre25"><td class="calibre70">11</td><td class="calibre70">661</td><td class="calibre70">1619</td><td class="calibre70">2539</td><td class="calibre70">3557</td></tr>
<tr class="calibre25"><td class="calibre70">13</td><td class="calibre70">677</td><td class="calibre70">1621</td><td class="calibre70">2549</td><td class="calibre70">3571</td></tr>
<tr class="calibre25"><td class="calibre70">19</td><td class="calibre70">701</td><td class="calibre70">1637</td><td class="calibre70">2557</td><td class="calibre70">3581</td></tr>
<tr class="calibre25"><td class="calibre70">29</td><td class="calibre70">709</td><td class="calibre70">1667</td><td class="calibre70">2579</td><td class="calibre70">3613</td></tr>
<tr class="calibre25"><td class="calibre70">37</td><td class="calibre70">757</td><td class="calibre70">1669</td><td class="calibre70">2621</td><td class="calibre70">3637</td></tr>
<tr class="calibre25"><td class="calibre70">53</td><td class="calibre70">773</td><td class="calibre70">1693</td><td class="calibre70">2659</td><td class="calibre70">3643</td></tr>
<tr class="calibre25"><td class="calibre70">59</td><td class="calibre70">787</td><td class="calibre70">1733</td><td class="calibre70">2677</td><td class="calibre70">3659</td></tr>
<tr class="calibre25"><td class="calibre70">61</td><td class="calibre70">797</td><td class="calibre70">1741</td><td class="calibre70">2683</td><td class="calibre70">3677</td></tr>
<tr class="calibre25"><td class="calibre70">67</td><td class="calibre70">821</td><td class="calibre70">1747</td><td class="calibre70">2693</td><td class="calibre70">3691</td></tr>
<tr class="calibre25"><td class="calibre70">83</td><td class="calibre70">827</td><td class="calibre70">1787</td><td class="calibre70">2699</td><td class="calibre70">3701</td></tr>
<tr class="calibre25"><td class="calibre70">101</td><td class="calibre70">829</td><td class="calibre70">1861</td><td class="calibre70">2707</td><td class="calibre70">3709</td></tr>
<tr class="calibre25"><td class="calibre70">107</td><td class="calibre70">853</td><td class="calibre70">1867</td><td class="calibre70">2741</td><td class="calibre70">3733</td></tr>
<tr class="calibre25"><td class="calibre70">131</td><td class="calibre70">859</td><td class="calibre70">1877</td><td class="calibre70">2789</td><td class="calibre70">3779</td></tr>
<tr class="calibre25"><td class="calibre70">139</td><td class="calibre70">877</td><td class="calibre70">1901</td><td class="calibre70">2797</td><td class="calibre70">3797</td></tr>
<tr class="calibre25"><td class="calibre70">149</td><td class="calibre70">883</td><td class="calibre70">1907</td><td class="calibre70">2803</td><td class="calibre70">3803</td></tr>
<tr class="calibre25"><td class="calibre70">163</td><td class="calibre70">907</td><td class="calibre70">1931</td><td class="calibre70">2819</td><td class="calibre70">3851</td></tr>
<tr class="calibre25"><td class="calibre70">173</td><td class="calibre70">941</td><td class="calibre70">1949</td><td class="calibre70">2837</td><td class="calibre70">3853</td></tr>
<tr class="calibre25"><td class="calibre70">179</td><td class="calibre70">947</td><td class="calibre70">1973</td><td class="calibre70">2843</td><td class="calibre70">3877</td></tr>
<tr class="calibre25"><td class="calibre70">181</td><td class="calibre70">1019</td><td class="calibre70">1979</td><td class="calibre70">2851</td><td class="calibre70">3907</td></tr>
<tr class="calibre25"><td class="calibre70">197</td><td class="calibre70">1061</td><td class="calibre70">1987</td><td class="calibre70">2861</td><td class="calibre70">3917</td></tr>
<tr class="calibre25"><td class="calibre70">211</td><td class="calibre70">1091</td><td class="calibre70">1997</td><td class="calibre70">2909</td><td class="calibre70">3923</td></tr>
<tr class="calibre25"><td class="calibre70">227</td><td class="calibre70">1109</td><td class="calibre70">2027</td><td class="calibre70">2939</td><td class="calibre70">3931</td></tr>
<tr class="calibre25"><td class="calibre70">269</td><td class="calibre70">1117</td><td class="calibre70">2029</td><td class="calibre70">2957</td><td class="calibre70">3947</td></tr>
<tr class="calibre25"><td class="calibre70">293</td><td class="calibre70">1123</td><td class="calibre70">2053</td><td class="calibre70">2963</td><td class="calibre70">3989</td></tr>
<tr class="calibre25"><td class="calibre70">317</td><td class="calibre70">1171</td><td class="calibre70">2069</td><td class="calibre70">3011</td><td class="calibre70">4003</td></tr>
<tr class="calibre25"><td class="calibre70">347</td><td class="calibre70">1187</td><td class="calibre70">2083</td><td class="calibre70">3019</td><td class="calibre70">4013</td></tr>
<tr class="calibre25"><td class="calibre70">349</td><td class="calibre70">1213</td><td class="calibre70">2099</td><td class="calibre70">3037</td><td class="calibre70">4019</td></tr>
<tr class="calibre25"><td class="calibre70">373</td><td class="calibre70">1229</td><td class="calibre70">2131</td><td class="calibre70">3067</td><td class="calibre70">4021</td></tr>
<tr class="calibre25"><td class="calibre70">379</td><td class="calibre70">1237</td><td class="calibre70">2141</td><td class="calibre70">3083</td><td class="calibre70">4091</td></tr>
<tr class="calibre25"><td class="calibre70">389</td><td class="calibre70">1259</td><td class="calibre70">2213</td><td class="calibre70">3187</td><td class="calibre70">4093</td></tr>
<tr class="calibre25"><td class="calibre70">419</td><td class="calibre70">1277</td><td class="calibre70">2221</td><td class="calibre70">3203</td><td class="calibre70">4099</td></tr>
<tr class="calibre25"><td class="calibre70">421</td><td class="calibre70">1283</td><td class="calibre70">2237</td><td class="calibre70">3253</td><td class="calibre70">4133</td></tr>
<tr class="calibre25"><td class="calibre70">443</td><td class="calibre70">1291</td><td class="calibre70">2243</td><td class="calibre70">3299</td><td class="calibre70">4139</td></tr>
<tr class="calibre25"><td class="calibre70">461</td><td class="calibre70">1301</td><td class="calibre70">2267</td><td class="calibre70">3307</td><td class="calibre70">4157</td></tr>
<tr class="calibre25"><td class="calibre70">467</td><td class="calibre70">1307</td><td class="calibre70">2269</td><td class="calibre70">3323</td><td class="calibre70">4219</td></tr>
<tr class="calibre25"><td class="calibre70">491</td><td class="calibre70">1373</td><td class="calibre70">2293</td><td class="calibre70">3347</td><td class="calibre70">4229</td></tr>
<tr class="calibre25"><td class="calibre70">509</td><td class="calibre70">1381</td><td class="calibre70">2309</td><td class="calibre70">3371</td><td class="calibre70">4243</td></tr>
<tr class="calibre25"><td class="calibre70">523</td><td class="calibre70">1427</td><td class="calibre70">2333</td><td class="calibre70">3413</td><td class="calibre70">4253</td></tr>
<tr class="calibre25"><td class="calibre70">541</td><td class="calibre70">1451</td><td class="calibre70">2339</td><td class="calibre70">3461</td><td class="calibre70">4259</td></tr>
<tr class="calibre25"><td class="calibre70">547</td><td class="calibre70">1453</td><td class="calibre70">2357</td><td class="calibre70">3467</td><td class="calibre70">4261</td></tr>
<tr class="calibre25"><td class="calibre70">557</td><td class="calibre70">1483</td><td class="calibre70">2371</td><td class="calibre70">3469</td><td class="calibre70">4283</td></tr>
<tr class="calibre25"><td class="calibre70">563</td><td class="calibre70">1493</td><td class="calibre70">2389</td><td class="calibre70">3491</td><td class="calibre70">4349</td></tr>
<tr class="calibre25"><td class="calibre70">587</td><td class="calibre70">1499</td><td class="calibre70">2437</td><td class="calibre70">3499</td><td class="calibre70">4357</td></tr>
<tr class="calibre25"><td class="calibre70">613</td><td class="calibre70">1523</td><td class="calibre70">2459</td><td class="calibre70">3517</td><td class="calibre70">4363</td></tr>
<tr class="calibre25"><td class="calibre70">619</td><td class="calibre70">1531</td><td class="calibre70">2467</td><td class="calibre70">3533</td><td class="calibre70">4373</td></tr>
<tr class="calibre25"><td class="calibre70">4397</td><td class="calibre70">5693</td><td class="calibre70">6781</td><td class="calibre70">7717</td><td class="calibre70">8861</td></tr>
<tr class="calibre25"><td class="calibre70">4451</td><td class="calibre70">5701</td><td class="calibre70">6803</td><td class="calibre70">7757</td><td class="calibre70">8867</td></tr>
<tr class="calibre25"><td class="calibre70">4483</td><td class="calibre70">5717</td><td class="calibre70">6827</td><td class="calibre70">7789</td><td class="calibre70">8923</td></tr>
<tr class="calibre25"><td class="calibre70">4493</td><td class="calibre70">5741</td><td class="calibre70">6829</td><td class="calibre70">7829</td><td class="calibre70">8933</td></tr>
<tr class="calibre25"><td class="calibre70">4507</td><td class="calibre70">5749</td><td class="calibre70">6869</td><td class="calibre70">7853</td><td class="calibre70">8963</td></tr>
<tr class="calibre25"><td class="calibre70">4517</td><td class="calibre70">5779</td><td class="calibre70">6883</td><td class="calibre70">7877</td><td class="calibre70">8971</td></tr>
<tr class="calibre25"><td class="calibre70">4547</td><td class="calibre70">5813</td><td class="calibre70">6899</td><td class="calibre70">7883</td><td class="calibre70">9011</td></tr>
<tr class="calibre25"><td class="calibre70">4603</td><td class="calibre70">5827</td><td class="calibre70">6907</td><td class="calibre70">7901</td><td class="calibre70">9029</td></tr>
<tr class="calibre25"><td class="calibre70">4621</td><td class="calibre70">5843</td><td class="calibre70">6917</td><td class="calibre70">7907</td><td class="calibre70">9059</td></tr>
<tr class="calibre25"><td class="calibre70">4637</td><td class="calibre70">5851</td><td class="calibre70">6947</td><td class="calibre70">7933</td><td class="calibre70">9173</td></tr>
<tr class="calibre25"><td class="calibre70">4691</td><td class="calibre70">5869</td><td class="calibre70">6949</td><td class="calibre70">7949</td><td class="calibre70">9181</td></tr>
<tr class="calibre25"><td class="calibre70">4723</td><td class="calibre70">5923</td><td class="calibre70">6971</td><td class="calibre70">8053</td><td class="calibre70">9203</td></tr>
<tr class="calibre25"><td class="calibre70">4787</td><td class="calibre70">5939</td><td class="calibre70">7013</td><td class="calibre70">8069</td><td class="calibre70">9221</td></tr>
<tr class="calibre25"><td class="calibre70">4789</td><td class="calibre70">5987</td><td class="calibre70">7019</td><td class="calibre70">8093</td><td class="calibre70">9227</td></tr>
<tr class="calibre25"><td class="calibre70">4813</td><td class="calibre70">6011</td><td class="calibre70">7027</td><td class="calibre70">8117</td><td class="calibre70">9283</td></tr>
<tr class="calibre25"><td class="calibre70">4877</td><td class="calibre70">6029</td><td class="calibre70">7043</td><td class="calibre70">8123</td><td class="calibre70">9293</td></tr>
<tr class="calibre25"><td class="calibre70">4933</td><td class="calibre70">6053</td><td class="calibre70">7069</td><td class="calibre70">8147</td><td class="calibre70">9323</td></tr>
<tr class="calibre25"><td class="calibre70">4957</td><td class="calibre70">6067</td><td class="calibre70">7109</td><td class="calibre70">8171</td><td class="calibre70">9341</td></tr>
<tr class="calibre25"><td class="calibre70">4973</td><td class="calibre70">6101</td><td class="calibre70">7187</td><td class="calibre70">8179</td><td class="calibre70">9349</td></tr>
<tr class="calibre25"><td class="calibre70">4987</td><td class="calibre70">6131</td><td class="calibre70">7211</td><td class="calibre70">8219</td><td class="calibre70">9371</td></tr>
<tr class="calibre25"><td class="calibre70">5003</td><td class="calibre70">6173</td><td class="calibre70">7219</td><td class="calibre70">8221</td><td class="calibre70">9397</td></tr>
<tr class="calibre25"><td class="calibre70">5011</td><td class="calibre70">6197</td><td class="calibre70">7229</td><td class="calibre70">8237</td><td class="calibre70">9419</td></tr>
<tr class="calibre25"><td class="calibre70">5051</td><td class="calibre70">6203</td><td class="calibre70">7237</td><td class="calibre70">8243</td><td class="calibre70">9421</td></tr>
<tr class="calibre25"><td class="calibre70">5059</td><td class="calibre70">6211</td><td class="calibre70">7243</td><td class="calibre70">8269</td><td class="calibre70">9437</td></tr>
<tr class="calibre25"><td class="calibre70">5077</td><td class="calibre70">6229</td><td class="calibre70">7253</td><td class="calibre70">8291</td><td class="calibre70">9467</td></tr>
<tr class="calibre25"><td class="calibre70">5099</td><td class="calibre70">6269</td><td class="calibre70">7283</td><td class="calibre70">8293</td><td class="calibre70">9491</td></tr>
<tr class="calibre25"><td class="calibre70">5107</td><td class="calibre70">6277</td><td class="calibre70">7307</td><td class="calibre70">8363</td><td class="calibre70">9533</td></tr>
<tr class="calibre25"><td class="calibre70">5147</td><td class="calibre70">6299</td><td class="calibre70">7331</td><td class="calibre70">8387</td><td class="calibre70">9539</td></tr>
<tr class="calibre25"><td class="calibre70">5171</td><td class="calibre70">6317</td><td class="calibre70">7349</td><td class="calibre70">8429</td><td class="calibre70">9547</td></tr>
<tr class="calibre25"><td class="calibre70">5179</td><td class="calibre70">6323</td><td class="calibre70">7411</td><td class="calibre70">8443</td><td class="calibre70">9587</td></tr>
<tr class="calibre25"><td class="calibre70">5189</td><td class="calibre70">6373</td><td class="calibre70">7451</td><td class="calibre70">8467</td><td class="calibre70">9613</td></tr>
<tr class="calibre25"><td class="calibre70">5227</td><td class="calibre70">6379</td><td class="calibre70">7459</td><td class="calibre70">8539</td><td class="calibre70">9619</td></tr>
<tr class="calibre25"><td class="calibre70">5261</td><td class="calibre70">6389</td><td class="calibre70">7477</td><td class="calibre70">8563</td><td class="calibre70">9629</td></tr>
<tr class="calibre25"><td class="calibre70">5309</td><td class="calibre70">6397</td><td class="calibre70">7499</td><td class="calibre70">8573</td><td class="calibre70">9643</td></tr>
<tr class="calibre25"><td class="calibre70">5333</td><td class="calibre70">6469</td><td class="calibre70">7507</td><td class="calibre70">8597</td><td class="calibre70">9661</td></tr>
<tr class="calibre25"><td class="calibre70">5387</td><td class="calibre70">6491</td><td class="calibre70">7517</td><td class="calibre70">8627</td><td class="calibre70">9677</td></tr>
<tr class="calibre25"><td class="calibre70">5443</td><td class="calibre70">6547</td><td class="calibre70">7523</td><td class="calibre70">8669</td><td class="calibre70">9733</td></tr>
<tr class="calibre25"><td class="calibre70">5477</td><td class="calibre70">6619</td><td class="calibre70">7541</td><td class="calibre70">8677</td><td class="calibre70">9749</td></tr>
<tr class="calibre25"><td class="calibre70">5483</td><td class="calibre70">6637</td><td class="calibre70">7547</td><td class="calibre70">8693</td><td class="calibre70">9803</td></tr>
<tr class="calibre25"><td class="calibre70">5501</td><td class="calibre70">6653</td><td class="calibre70">7549</td><td class="calibre70">8699</td><td class="calibre70">9851</td></tr>
<tr class="calibre25"><td class="calibre70">5507</td><td class="calibre70">6659</td><td class="calibre70">7573</td><td class="calibre70">8731</td><td class="calibre70">9859</td></tr>
<tr class="calibre25"><td class="calibre70">5557</td><td class="calibre70">6691</td><td class="calibre70">7589</td><td class="calibre70">8741</td><td class="calibre70">9883</td></tr>
<tr class="calibre25"><td class="calibre70">5563</td><td class="calibre70">6701</td><td class="calibre70">7603</td><td class="calibre70">8747</td><td class="calibre70">9901</td></tr>
<tr class="calibre25"><td class="calibre70">5573</td><td class="calibre70">6709</td><td class="calibre70">7621</td><td class="calibre70">8803</td><td class="calibre70">9907</td></tr>
<tr class="calibre25"><td class="calibre70">5651</td><td class="calibre70">6733</td><td class="calibre70">7643</td><td class="calibre70">8819</td><td class="calibre70">9923</td></tr>
<tr class="calibre71"><td class="calibre72">5659</td><td class="calibre72">6763</td><td class="calibre72">7669</td><td class="calibre72">8821</td><td class="calibre72">9941</td></tr>
<tr class="calibre25"><td class="calibre70">5683</td><td class="calibre70">6779</td><td class="calibre70">7691</td><td class="calibre70">8837</td><td class="calibre70">9949</td></tr>
</tbody></table>

<br class="calibre3"/>

<table class="data-table1" id="table-17-2">
<caption class="calibre67">Table 17.2 - Tap Sequences for Maximal-length FCSRs</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="calibre69">(32, 6, 3, 2)</td><td class="calibre69">(64, 24, 19, 2)</td><td class="calibre69">(64, 59, 28, 2)</td><td class="calibre69">(96, 55, 53, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 7, 5, 2)</td><td class="calibre70">(64, 25, 3, 2)</td><td class="calibre70">(64, 59, 38, 2)</td><td class="calibre70">(96, 56, 9, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 8, 3, 2)</td><td class="calibre70">(64, 25, 4, 2)</td><td class="calibre70">(64, 59, 44, 2)</td><td class="calibre70">(96, 56, 51, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 13, 8, 2)</td><td class="calibre70">(64, 25, 11, 2)</td><td class="calibre70">(64, 60, 49, 2)</td><td class="calibre70">(96, 57, 3, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 13, 12, 2)</td><td class="calibre70">(64, 25, 19, 2)</td><td class="calibre70">(64, 61, 51, 2)</td><td class="calibre70">(96, 57, 17, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 15, 6, 2)</td><td class="calibre70">(64, 27, 5, 2)</td><td class="calibre70">(64, 63, 8, 2)</td><td class="calibre70">(96, 57, 47, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 16, 2, 1)</td><td class="calibre70">(64, 27, 16, 2)</td><td class="calibre70">(64, 63, 13, 2)</td><td class="calibre70">(96, 58, 35, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 16, 3, 2)</td><td class="calibre70">(64, 27, 22, 2)</td><td class="calibre70">(64, 63, 61, 2)</td><td class="calibre70">(96, 59, 46, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 16, 5, 2)</td><td class="calibre70">(64, 28, 19, 2)</td><td class="calibre70"/><td class="calibre70">(96, 60, 29, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 17, 5, 2)</td><td class="calibre70">(64, 28, 25, 2)</td><td class="calibre70">(96, 15, 5, 2)</td><td class="calibre70">(96, 60, 41, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 19, 2, 1)</td><td class="calibre70">(64, 29, 16, 2)</td><td class="calibre70">(96, 21, 17, 2)</td><td class="calibre70">(96, 60, 45, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 19, 5, 2)</td><td class="calibre70">(64, 29, 28, 2)</td><td class="calibre70">(96, 25, 19, 2)</td><td class="calibre70">(96, 61, 17, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 19, 9, 2)</td><td class="calibre70">(64, 31, 12, 2)</td><td class="calibre70">(96, 25, 20, 2)</td><td class="calibre70">(96, 63, 20, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 19, 12, 2)</td><td class="calibre70">(64, 32, 21, 2)</td><td class="calibre70">(96, 29, 15, 2)</td><td class="calibre70">(96, 65, 12, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 19, 17, 2)</td><td class="calibre70">(64, 35, 29, 2)</td><td class="calibre70">(96, 29, 17, 2)</td><td class="calibre70">(96, 65, 39, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 20, 17, 2)</td><td class="calibre70">(64, 36, 7, 2)</td><td class="calibre70">(96, 30, 3, 2)</td><td class="calibre70">(96, 65, 51, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 21, 9, 2)</td><td class="calibre70">(64, 37, 2, 1)</td><td class="calibre70">(96, 32, 21, 2)</td><td class="calibre70">(96, 67, 5, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 21, 15, 2)</td><td class="calibre70">(64, 37, 11, 2)</td><td class="calibre70">(96, 32, 27, 2)</td><td class="calibre70">(96, 67, 25, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 23, 8, 2)</td><td class="calibre70">(64, 39, 4, 2)</td><td class="calibre70">(96, 33, 5, 2)</td><td class="calibre70">(96, 67, 34, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 23, 21, 2)</td><td class="calibre70">(64, 39, 25, 2)</td><td class="calibre70">(96, 35, 17, 2)</td><td class="calibre70">(96, 68, 5, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 25, 5, 2)</td><td class="calibre70">(64, 41, 5, 2)</td><td class="calibre70">(96, 35, 33, 2)</td><td class="calibre70">(96, 68, 19, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 25, 12, 2)</td><td class="calibre70">(64, 41, 11, 2)</td><td class="calibre70">(96, 39, 21, 2)</td><td class="calibre70">(96, 69, 17, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 27, 25, 2)</td><td class="calibre70">(64, 41, 27, 2)</td><td class="calibre70">(96, 40, 25, 2)</td><td class="calibre70">(96, 69, 36, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 29, 19, 2)</td><td class="calibre70">(64, 43, 21, 2)</td><td class="calibre70">(96, 41, 12, 2)</td><td class="calibre70">(96, 70, 23, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 29, 20, 2)</td><td class="calibre70">(64, 43, 28, 2)</td><td class="calibre70">(96, 41, 27, 2)</td><td class="calibre70">(96, 71, 6, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 30, 3, 2)</td><td class="calibre70">(64, 45, 28, 2)</td><td class="calibre70">(96, 41, 35, 2)</td><td class="calibre70">(96, 71, 40, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 30, 7, 2)</td><td class="calibre70">(64, 45, 41, 2)</td><td class="calibre70">(96, 42, 35, 2)</td><td class="calibre70">(96, 72, 53, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 31, 5, 2)</td><td class="calibre70">(64, 47, 5, 2)</td><td class="calibre70">(96, 43, 14, 2)</td><td class="calibre70">(96, 73, 32, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 31, 9, 2)</td><td class="calibre70">(64, 47, 21, 2)</td><td class="calibre70">(96, 44, 23, 2)</td><td class="calibre70">(96, 77, 27, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(32, 31, 30, 2)</td><td class="calibre70">(64, 47, 30, 2)</td><td class="calibre70">(96, 45, 41, 2)</td><td class="calibre70">(96, 77, 31, 2)</td></tr>
<tr class="calibre25"><td class="calibre70"/><td class="calibre70">(64, 49, 19, 2)</td><td class="calibre70">(96, 47, 36, 2)</td><td class="calibre70">(96, 77, 32, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 3, 2, 1)</td><td class="calibre70">(64, 49, 20, 2)</td><td class="calibre70">(96, 49, 31, 2)</td><td class="calibre70">(96, 77, 33, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 14, 3, 2)</td><td class="calibre70">(64, 52, 29, 2)</td><td class="calibre70">(96, 51, 30, 2)</td><td class="calibre70">(96, 77, 71, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 15, 8, 2)</td><td class="calibre70">(64, 53, 8, 2)</td><td class="calibre70">(96, 53, 17, 2)</td><td class="calibre70">(96, 78, 39, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 17, 2, 1)</td><td class="calibre70">(64, 53, 43, 2)</td><td class="calibre70">(96, 53, 19, 2)</td><td class="calibre70">(96, 79, 4, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 17, 9, 2)</td><td class="calibre70">(64, 56, 39, 2)</td><td class="calibre70">(96, 53, 32, 2)</td><td class="calibre70">(96, 81, 80, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 17, 16, 2)</td><td class="calibre70">(64, 56, 45, 2)</td><td class="calibre70">(96, 53, 48, 2)</td><td class="calibre70">(96, 83, 14, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 19, 2, 1)</td><td class="calibre70">(64, 59, 5, 2)</td><td class="calibre70">(96, 54, 15, 2)</td><td class="calibre70">(96, 83, 26, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(64, 19, 18, 2)</td><td class="calibre70">(64, 59, 8, 2)</td><td class="calibre70">(96, 55, 44, 2)</td><td class="calibre70">(96, 83, 54, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 83, 60, 2)</td><td class="calibre70">(128, 31, 25, 2)</td><td class="calibre70">(128, 81, 55, 2)</td><td class="calibre70">(128, 105, 11, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 83, 65, 2)</td><td class="calibre70">(128, 33, 21, 2)</td><td class="calibre70">(128, 82, 67, 2)</td><td class="calibre70">(128, 105, 31, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 83, 78, 2)</td><td class="calibre70">(128, 35, 22, 2)</td><td class="calibre70">(128, 83, 60, 2)</td><td class="calibre70">(128, 105, 48, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 84, 65, 2)</td><td class="calibre70">(128, 37, 8, 2)</td><td class="calibre70">(128, 83, 61, 2)</td><td class="calibre70">(128, 107, 40, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 85, 17, 2)</td><td class="calibre70">(128, 41, 12, 2)</td><td class="calibre70">(128, 83, 77, 2)</td><td class="calibre70">(128, 107, 62, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 85, 31, 2)</td><td class="calibre70">(128, 42, 35, 2)</td><td class="calibre70">(128, 84, 15, 2)</td><td class="calibre70">(128,, 107102, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 85, 76, 2)</td><td class="calibre70">(128, 43, 25, 2)</td><td class="calibre70">(128, 84, 43, 2)</td><td class="calibre70">(128, 108, 35, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 85, 79, 2)</td><td class="calibre70">(128, 43, 42, 2)</td><td class="calibre70">(128, 85, 63, 2)</td><td class="calibre70">(128, 108, 73, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 86, 39, 2)</td><td class="calibre70">(128, 45, 17, 2)</td><td class="calibre70">(128, 87, 57, 2)</td><td class="calibre70">(128, 108, 75, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 86, 71, 2)</td><td class="calibre70">(128, 45, 27, 2)</td><td class="calibre70">(128, 87, 81, 2)</td><td class="calibre70">(128, 108, 89, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 87, 9, 2)</td><td class="calibre70">(128, 49, 9, 2)</td><td class="calibre70">(128, 89, 81, 2)</td><td class="calibre70">(128, 109, 11, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 87, 44, 2)</td><td class="calibre70">(128, 51, 9, 2)</td><td class="calibre70">(128, 90, 43, 2)</td><td class="calibre70">(128,, 109108, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 87, 45, 2)</td><td class="calibre70">(128, 54, 51, 2)</td><td class="calibre70">(128, 91, 9, 2)</td><td class="calibre70">(128, 110, 23, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 88, 19, 2)</td><td class="calibre70">(128, 55, 45, 2)</td><td class="calibre70">(128, 91, 13, 2)</td><td class="calibre70">(128, 111, 61, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 88, 35, 2)</td><td class="calibre70">(128, 56, 15, 2)</td><td class="calibre70">(128, 91, 44, 2)</td><td class="calibre70">(128, 113, 59, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 88, 43, 2)</td><td class="calibre70">(128, 56, 19, 2)</td><td class="calibre70">(128, 92, 35, 2)</td><td class="calibre70">(128, 114, 83, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 88, 79, 2)</td><td class="calibre70">(128, 56, 55, 2)</td><td class="calibre70">(128, 95, 94, 2)</td><td class="calibre70">(128, 115, 73, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 89, 35, 2)</td><td class="calibre70">(128, 57, 21, 2)</td><td class="calibre70">(128, 96, 23, 2)</td><td class="calibre70">(128,, 117105, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 89, 51, 2)</td><td class="calibre70">(128, 57, 37, 2)</td><td class="calibre70">(128, 96, 61, 2)</td><td class="calibre70">(128, 119, 30, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 89, 69, 2)</td><td class="calibre70">(128, 59, 29, 2)</td><td class="calibre70">(128, 97, 25, 2)</td><td class="calibre70">(128,, 119101, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 89, 87, 2)</td><td class="calibre70">(128, 59, 49, 2)</td><td class="calibre70">(128, 97, 68, 2)</td><td class="calibre70">(128, 120, 9, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 92, 51, 2)</td><td class="calibre70">(128, 60, 57, 2)</td><td class="calibre70">(128, 97, 72, 2)</td><td class="calibre70">(128, 120, 27, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 92, 71, 2)</td><td class="calibre70">(128, 61, 9, 2)</td><td class="calibre70">(128, 97, 75, 2)</td><td class="calibre70">(128, 120, 37, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 93, 32, 2)</td><td class="calibre70">(128, 61, 23, 2)</td><td class="calibre70">(128, 99, 13, 2)</td><td class="calibre70">(128, 120, 41, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 93, 39, 2)</td><td class="calibre70">(128, 61, 52, 2)</td><td class="calibre70">(128, 99, 14, 2)</td><td class="calibre70">(128, 120, 79, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 94, 35, 2)</td><td class="calibre70">(128, 63, 40, 2)</td><td class="calibre70">(128, 99, 26, 2)</td><td class="calibre70">(128, 120, 81, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 95, 4, 2)</td><td class="calibre70">(128, 63, 62, 2)</td><td class="calibre70">(128, 99, 54, 2)</td><td class="calibre70">(128, 121, 5, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 95, 16, 2)</td><td class="calibre70">(128, 67, 41, 2)</td><td class="calibre70">(128, 99, 56, 2)</td><td class="calibre70">(128, 121, 67, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 95, 32, 2)</td><td class="calibre70">(128, 69, 33, 2)</td><td class="calibre70">(128, 99, 78, 2)</td><td class="calibre70">(128, 121, 95, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 95, 44, 2)</td><td class="calibre70">(128, 71, 53, 2)</td><td class="calibre70">(128, 100, 13, 2)</td><td class="calibre70">(128, 121, 96, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(96, 95, 45, 2)</td><td class="calibre70">(128, 72, 15, 2)</td><td class="calibre70">(128, 100, 39, 2)</td><td class="calibre70">(128, 123, 40, 2)</td></tr>
<tr class="calibre25"><td class="calibre70"/><td class="calibre70">(128, 72, 41, 2)</td><td class="calibre70">(128, 101, 44, 2)</td><td class="calibre70">(128, 123, 78, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(128, 5, 4, 2)</td><td class="calibre70">(128, 73, 5, 2)</td><td class="calibre70">(128, 101, 97, 2)</td><td class="calibre70">(128, 124, 41, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(128, 15, 4, 2)</td><td class="calibre70">(128, 73, 65, 2)</td><td class="calibre70">(128, 103, 46, 2)</td><td class="calibre70">(128, 124, 69, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(128, 21, 19, 2)</td><td class="calibre70">(128, 73, 67, 2)</td><td class="calibre70">(128, 104, 13, 2)</td><td class="calibre70">(128, 124, 81, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(128, 25, 5, 2)</td><td class="calibre70">(128, 75, 13, 2)</td><td class="calibre70">(128, 104, 19, 2)</td><td class="calibre70">(128, 125, 33, 2)</td></tr>
<tr class="calibre71"><td class="calibre72">(128, 26, 11, 2)</td><td class="calibre72">(128, 80, 39, 2)</td><td class="calibre72">(128, 104, 35, 2)</td><td class="calibre72">(128, 125, 43, 2)</td></tr>
<tr class="calibre25"><td class="calibre70">(128, 27, 25, 2)</td><td class="calibre70">(128, 80, 53, 2)</td><td class="calibre70">(128, 105, 7, 2)</td><td class="calibre70">(128, 127, 121, 2)</td></tr>
</tbody></table>


<p class="calibre39">The idea of using FCSRs for cryptography is still very new; it is being
pioneered by Andy Klapper and Mark Goresky [<a href="Applied%20Cryptography_split_036.html#r844" class="calibre5 pcalibre">844</a>,<a href="Applied%20Cryptography_split_036.html#r845" class="calibre5 pcalibre">845</a>,<a href="Applied%20Cryptography_split_035.html#r654" class="calibre5 pcalibre">654</a>,<a href="Applied%20Cryptography_split_036.html#r843" class="calibre5 pcalibre">843</a>,<a href="Applied%20Cryptography_split_036.html#r846" class="calibre5 pcalibre">846</a>]. Just as
the analysis of LFSRs is based on the addition of primitive polynomials mod
2, analysis of FCSRs is based on addition over something called the <b class="calibre10">2-adic</b>
numbers. The theory is well beyond the scope of this book, but there seems to
be a 2-adic analog for everything. Just as you can define linear complexity,
you can define 2-adic complexity. There is even a 2-adic analog to the
Berlekamp-Massey algorithm. What this means is that the list of potential
stream ciphers has just doubled — at least. Anything you can do with a LFSR
you can do with a FCSR.</p>

<p class="calibre9">There are further enhancements to this sort of idea, ones that involve multiple
carry registers. The analysis of these sequence generators is based on addition
over the ramified extensions of the 2-adic numbers [<a href="Applied%20Cryptography_split_036.html#r845" class="calibre5 pcalibre">845</a>,<a href="Applied%20Cryptography_split_036.html#r846" class="calibre5 pcalibre">846</a>].</p>

<h3 id="17.5" class="calibre7">17.5 Stream Ciphers Using FCSRs</h3>

<p class="calibre9">There aren’t any FCSR stream ciphers in the literature; the theory is still too
new. In the interests of getting the ball rolling, I propose some here. I am
taking two different tacks: I am proposing FCSR stream ciphers that are
identical to previously proposed LFSR generators, and I am proposing stream
ciphers that use both FCSRs and LFSRs. The security of the former can
probably be analyzed using 2-adic numbers; the latter cannot be analyzed
using algebraic techniques — they can probably only be analyzed indirectly. In
any case, it is important to choose LFSRs and FCSRs whose periods are
relatively prime.</p>

<p class="calibre9">All this will come later. Right now I know of no implementation or analysis of
any of these ideas. Wait some years and scan the literature before you trust any
of them.</p>

<h4 class="calibre8">Cascade Generators</h4>

<p class="calibre9">There are two ways to use FCSRs in a cascade generator:</p>

<ul class="calibre13">

<li class="calibre14">FCSR Cascade. The Gollmann cascade with FCSRs instead of
LFSRs.
</li>
<li class="calibre14">LFSR/FCSR Cascade. The Gollmann cascade with the generators
alternating between LFSRs and FCSRs.
</li>

</ul>

<h4 class="calibre8">FCSR Combining Generators</h4>

<p class="calibre9">These generators use a variable number of LFSRs and/or FCSRs, and a variety
of functions to combine them. The XOR operation destroys the algebraic
properties of FCSRs, so it makes sense to use it to combine them. The
generator, shown in Figure 17.5, uses a variable number of FCSRs. Its output
is the XOR of the outputs of the individual FCSRs.</p>

<div class="figure" id="figure-17-5">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-5.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.5</b> Combining Generators.</i></p>
</div>

<p class="calibre9">Other generators along similar lines are:</p>

<ul class="calibre13">

<li class="calibre14">FCSR Parity Generator. All registers are FCSRs and the combining
function is XOR.
</li>
<li class="calibre14">LFSR/FCSR Parity Generator. Registers are a mix of LFSRs and
FCSRs and the combining function is XOR.
</li>
<li class="calibre14">FCSR Threshold Generator. All registers are FCSRs and the
combining function is the majority function.
</li>
<li class="calibre14">LFSR/FCSR Threshold Generator. Registers are a mix of LFSRs and
FCSRs and the combining function is the majority function.
</li>
<li class="calibre14">FCSR Summation Generator. All registers are FCSRs and the
combining function is addition with carry.
</li>
<li class="calibre14">LFSR/FCSR Summation Generator. Registers are a mix of LFSRs
and FCSRs and the combining function is addition with carry.
</li>

</ul>

<h4 class="calibre8">LFSR/FCSR Summation/Parity Cascade</h4>

<p class="calibre9">The theory is that addition with carry destroys the algebraic properties of
LFSRs, and that XOR destroys the algebraic properties of FCSRs. This
generator combines those ideas, as used in the LFSR/FCSR Summation
Generator and the LFSR/FCSR Parity Generator just listed, with the Gollmann
cascade.</p>

<p class="calibre9">The generator is a series of arrays of registers, with the clock of each array
controlled by the output of the previous array. Figure 17.6 is one stage of this
generator. The first array of LFSRs is clocked and the results are combined
using addition with carry. If the output of this combining function is 1, then
the next array (of FCSRs) is clocked and the output of those FCSRs is
combined with the output of the previous combining function using XOR. If
the output of the first combining function is 0, then the array of FCSRs is not
clocked and the output is simply added to the carry from the previous round. If
the output of this second combining function is 1, then the third array of
LFSRs is clocked, and so on.</p>

<div class="figure" id="figure-17-6">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-6.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.6</b> Concoction Generator.</i></p>
</div>

<p class="calibre9">This generator uses a lot of registers: <i class="calibre12">n*m</i>, where <i class="calibre12">n</i> is the number of stages and <i class="calibre12">m</i> is the number of registers per stage. I recommend <i class="calibre12">n</i> = 10 and <i class="calibre12">m</i> = 5.</p>

<h4 class="calibre8">Alternating Stop-and-Go Generators</h4>

<p class="calibre9">These generators are stop-and-go generators with FCSRs instead of some
LFSRs. Additionally, the XOR operation can be replaced with an addition with
carry (see Figure 17.7).</p>

<ul class="calibre13">

<li class="calibre14">FCSR Stop-and-Go Generator. Register-1, Register-2, and Register-3
are FCSRs. The combining operation is XOR.
</li>
<li class="calibre14">FCSR/LFSR Stop-and-Go Generator. Register-1 is a FCSR, and
Registers-2 and -3 are LFSRs. The combining operation is addition with
carry.
</li>
<li class="calibre14">LFSR/FCSR Stop-and-Go Generator. Register-1 is a LFSR, and
Registers-2 and -3 are FCSRs. The combining operation is XOR.
</li>

</ul>

<div class="figure" id="figure-17-7">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-7.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.7</b> Alternating stop-and-go generators.</i></p>
</div>

<h4 class="calibre8">Shrinking Generators</h4>

<p class="calibre9">There are four basic generator types using FCSRs:</p>

<ul class="calibre13">

<li class="calibre14">FCSR Shrinking Generator. A shrinking generator with FCSRs
instead of LFSRs.
</li>
<li class="calibre14">FCSR/LFSR Shrinking Generator. A shrinking generator with a
LFSR shrinking a FCSR.
</li>
<li class="calibre14">LFSR/FCSR Shrinking Generator: A shrinking generator with a
FCSR shrinking a LFSR.
</li>
<li class="calibre14">FCSR Self-Shrinking Generator. A self-shrinking generator with a
FCSR instead of a LFSR.
</li>

</ul>

<h3 id="17.6" class="calibre7">17.6 Nonlinear-Feedback Shift Registers</h3>

<p class="calibre9">It is easy to imagine a more complicated feedback sequence than the ones used
in LFSRs or FCSRs. The problem is that there isn’t any mathematical theory
that can analyze them. You’ll get something, but who knows what it is? In
particular, here are some problems with nonlinear-feedback shift register
sequences.</p>

<ul class="calibre13">

<li class="calibre14">There may be biases, such as more ones than zeros or fewer runs than
expected, in the output sequence.
</li>
<li class="calibre14">The maximum period of the sequence may be much lower than
expected.
</li>
<li class="calibre14">The period of the sequence might be different for different starting
values.
</li>
<li class="calibre14">The sequence may appear random for a while, but then “dead end”
into a single value. (This can easily be solved by XORing the nonlinear
function with the rightmost bit.)
</li>

</ul>

<p class="calibre9">On the plus side, if there is no theory to analyze nonlinear-feedback shift
registers for security, there are few tools to cryptanalyze stream ciphers based
on them. We can use nonlinear-feedback shift registers in stream-cipher
design, but we have to be careful.</p>

<p class="calibre9">In a nonlinear-feedback shift register, the feedback function can be anything
you want (see Figure 17.8).</p>

<div class="figure" id="figure-17-8">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-8.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.8</b> A nonlinear-feedback shift register (probably insecure).</i></p>
</div>

<div class="figure" id="figure-17-9">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-9.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.9</b> 3-bit nonlinear feedback shift register.</i></p>
</div>

<p class="calibre9">Figure 17.9 is a 3-bit shift register with the following feedback function: The
new bit is the first bit times the second bit. If it is initialized with the value
110, it produces the following sequence of internal states:</p>

<pre class="calibre20">1 1 0
0 1 1
1 0 1
0 1 0
0 0 1
0 0 0
0 0 0
</pre>

<p class="calibre9">And so on forever.</p>

<p class="calibre9">The output sequence is the string of least significant bits:</p>

<pre class="calibre20">0 1 1 0 1 0 0 0 0 0 0 0 ....
</pre>

<p class="calibre9">This isn’t terribly useful.</p>

<p class="calibre9">It gets even worse. If the initial value is 100, it produces 010, 001, then repeats
forever at 000. If the initial value is 111, it repeats itself forever right from the
start.</p>

<p class="calibre9">Some work has been done on computing the linear complexity of the product
of two LFSRs [<a href="Applied%20Cryptography_split_036.html#r1650" class="calibre5 pcalibre">1650</a>,<a href="Applied%20Cryptography_split_035.html#r726" class="calibre5 pcalibre">726</a>,<a href="Applied%20Cryptography_split_036.html#r1364" class="calibre5 pcalibre">1364</a>,<a href="Applied%20Cryptography_split_035.html#r630" class="calibre5 pcalibre">630</a>,<a href="Applied%20Cryptography_split_035.html#r658" class="calibre5 pcalibre">658</a>,<a href="Applied%20Cryptography_split_035.html#r659" class="calibre5 pcalibre">659</a>]. A construction that involved
computing LFSRs over a field of odd characteristic [<a href="Applied%20Cryptography_split_035.html#r310" class="calibre5 pcalibre">310</a>] is insecure [<a href="Applied%20Cryptography_split_036.html#r842" class="calibre5 pcalibre">842</a>].</p>

<h3 id="17.7" class="calibre7">17.7 Other Stream Ciphers</h3>

<p class="calibre9">Many other stream ciphers have appeared in the literature here and there. Here
are some of them.</p>

<h4 class="calibre8">Pless Generator</h4>

<p class="calibre9">This generator is designed around the capabilities of the J-K flip-flop [<a href="Applied%20Cryptography_split_036.html#r1250" class="calibre5 pcalibre">1250</a>].
Eight LFSRs drive four J-K flip-flops; each flip-flop acts as a nonlinear
combiner for two of the LFSRs. To avoid the problem that knowledge of an
output of the flip-flop identifies both the source and value of the next output
bit, clock the four flip-flops and then interleave the outputs to yield the final
keystream.</p>

<p class="calibre9">This algorithm has been cryptanalyzed by attacking each of the four flip-flops
independently [<a href="Applied%20Cryptography_split_036.html#r1356" class="calibre5 pcalibre">1356</a>]. Additionally, combining J-K flip-flops is
cryptographically weak; generators of this type succumb to correlation attacks
[<a href="Applied%20Cryptography_split_036.html#r1451" class="calibre5 pcalibre">1451</a>].</p>

<h4 class="calibre8">Cellular Automaton Generator</h4>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_036.html#r1608" class="calibre5 pcalibre">1608</a>,<a href="Applied%20Cryptography_split_036.html#r1609" class="calibre5 pcalibre">1609</a>], Steve Wolfram proposed using a one-dimensional cellular
automaton as a pseudo-random-number generator. Cellular automata is not the
subject of this book, but Wolfram’s generator consisted of a one-dimensional
array of bits, <i class="calibre12">a</i><sub class="calibre15">1</sub>, <i class="calibre12">a</i><sub class="calibre15">2</sub>, <i class="calibre12">a</i><sub class="calibre15">3</sub>, ..., <i class="calibre12">a</i><sub class="calibre15">k</sub>, ..., <i class="calibre12">a</i><sub class="calibre15">n</sub>, and an update function:</p>

<p class="math"><i class="calibre12">a'</i><sub class="calibre15">k</sub> = <i class="calibre12">a</i><sub class="calibre15">k</sub>-1 ⊕ (<i class="calibre12">a</i><sub class="calibre15">k</sub> ∨ <i class="calibre12">a</i><sub class="calibre15">k</sub>+1)
</p>

<p class="calibre9">The bit is extracted from one of the <i class="calibre12">a</i><sub class="calibre15">k</sub> values; which one really doesn’t matter.</p>

<p class="calibre9">The generator’s behavior appears to be quite random. However, there is a
known-plaintext attack against these generators [<a href="Applied%20Cryptography_split_036.html#r1052" class="calibre5 pcalibre">1052</a>]. This attack works on a
PC with values of <i class="calibre12">n</i> up to 500 bits. Additionally, Paul Bardell proved that the output of a cellular automaton can also be generated by a linear-feedback shift
register of equal length and is therefore no more secure [<a href="Applied%20Cryptography_split_035.html#r83" class="calibre5 pcalibre">83</a>].</p>

<h4 class="calibre8">1/p Generator</h4>

<p class="calibre9">This generator was proposed, and then cryptanalyzed, in [<a href="Applied%20Cryptography_split_035.html#r193" class="calibre5 pcalibre">193</a>]. If the internal
state of the generator at time <i class="calibre12">t</i> is <i class="calibre12">x</i><sub class="calibre15">t</sub>, then</p>

<p class="math"><i class="calibre12">x</i><sub class="calibre15">t+1</sub> = <i class="calibre12">bx</i><sub class="calibre15">t</sub> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">The output of the generator is the least significant bit of <i class="calibre12">x</i><sub class="calibre15">t</sub> div <i class="calibre12">p</i>, where div is the truncated integer division. For maximum period, the constants <i class="calibre12">b</i> and <i class="calibre12">p</i>
should be chosen so that <i class="calibre12">p</i> is prime and <i class="calibre12">b</i> is a primitive root mod <i class="calibre12">p</i>.
Unfortunately, this generator isn’t secure. (Note that for <i class="calibre12">b</i> = 2, an FCSR with a connection integer <i class="calibre12">p</i> outputs the reverse of this sequence.)</p>

<h4 class="calibre8">crypt(1)</h4>

<p class="calibre9">The original UNIX encryption algorithm, crypt(1), is a stream cipher based on
the same ideas as the Enigma. This is a 256-element, single-rotor substitution
cipher with a reflector. Both the rotor and the reflector are generated from the
key. This algorithm is far simpler than the World War II German Enigma and,
for a skilled cryptanalyst, very easy to break [<a href="Applied%20Cryptography_split_036.html#r1576" class="calibre5 pcalibre">1576</a>,<a href="Applied%20Cryptography_split_036.html#r1299" class="calibre5 pcalibre">1299</a>]. A public-domain
UNIX program, called Crypt Breakers Workbench (CBW), can be used to
break files encrypted with crypt(1).</p>

<h4 class="calibre8">Other Schemes</h4>

<p class="calibre9">Another generator is based on the knapsack problem (see <a href="Applied%20Cryptography_split_022.html#19.2" class="calibre5 pcalibre">Section 19.2</a>) [<a href="Applied%20Cryptography_split_036.html#r1363" class="calibre5 pcalibre">1363</a>].
CRYPTO-LEGGO is insecure [<a href="Applied%20Cryptography_split_035.html#r301" class="calibre5 pcalibre">301</a>]. Joan Daemen has developed SubStream,
Jam, and StepRightUp [<a href="Applied%20Cryptography_split_035.html#r402" class="calibre5 pcalibre">402</a>]; they are all too new to comment on. Many other
algorithms are described in the literature, and even more are kept secret and
incorporated into equipment.</p>

<h3 id="17.8" class="calibre7">17.8 System-Theoretic Approach to Stream-Cipher Design</h3>

<p class="calibre9">In practice, stream-cipher design is a lot like block-cipher design. It involves
more mathematical theory, but in the end a cryptographer proposes a design
and then tries to analyze it.</p>

<p class="calibre9">According to Rainer Rueppel, there are four different approaches to the
construction of stream ciphers [<a href="Applied%20Cryptography_split_036.html#r1360" class="calibre5 pcalibre">1360</a>,<a href="Applied%20Cryptography_split_036.html#r1362" class="calibre5 pcalibre">1362</a>]:</p>

<ul class="calibre13">

<li class="calibre14">System-theoretic approach. Try to make sure that each design creates
a difficult and unknown problem for the cryptanalyst, using a set of
fundamental design principles and criteria.
</li>
<li class="calibre14">Information-theoretic approach. Try to keep the cryptanalyst in the
dark about the plaintext. No matter how much work the cryptanalyst
invests, he will never get a unique solution.
</li>
<li class="calibre14">Complexity-theoretic approach. Try to base the cryptosystem on, or
make it equivalent to, some known and difficult problem such as
factoring or taking discrete logarithms.
</li>
<li class="calibre14">Randomized approach. Try to generate an unmanageably large
problem by forcing the cryptanalyst to examine lots of useless data in
his attempts at cryptanalysis.
</li>

</ul>

<p class="calibre9">The approaches differ in their assumptions about the capabilities and
opportunities of the cryptanalyst, the definition of cryptographic success, and
the notion of security. Most of the research in this field is theoretical, but there
are some good stream ciphers among the impractical ones.</p>

<p class="calibre9">The system-theoretic approach was used in all the stream ciphers previously
listed; it produces most of the stream ciphers that are practical enough to be
used in the real world. A cryptographer designs keystream generators that have
testable security properties — period, distribution of bit patterns, linear
complexity, and so on — and not ciphers based on mathematical theory. The
cryptographer also studies various cryptanalytic techniques against these
generators and makes sure the generators are immune to these attacks.</p>

<p class="calibre9">Over the years, the approach has resulted in a set of design criteria for stream
ciphers [<a href="Applied%20Cryptography_split_036.html#r1432" class="calibre5 pcalibre">1432</a>,<a href="Applied%20Cryptography_split_035.html#r99" class="calibre5 pcalibre">99</a>,<a href="Applied%20Cryptography_split_036.html#r1357" class="calibre5 pcalibre">1357</a>,<a href="Applied%20Cryptography_split_036.html#r1249" class="calibre5 pcalibre">1249</a>]. These were discussed by Rueppel in [<a href="Applied%20Cryptography_split_036.html#r1362" class="calibre5 pcalibre">1362</a>], in
which he details the theory behind them.</p>

<ul class="calibre13">

<li class="calibre14">Long period, no repetitions.
</li>
<li class="calibre14">Linear complexity criteria — large linear complexity, linear
complexity profile, local linear complexity, and so forth.
</li>
<li class="calibre14">Statistical criteria such as ideal <i class="calibre12">k</i>-tuple distributions.
</li>
<li class="calibre14">Confusion — every keystream bit must be a complex transformation
of all or most of the key bits.
</li>
<li class="calibre14">Diffusion — redundancies in substructures must be dissipated into
long-range statistics.
</li>
<li class="calibre14">Nonlinearity criteria for Boolean functions like <i class="calibre12">m</i> th-order correlation
immunity, distance to linear functions, avalanche criterion, and so on.
</li>

</ul>

<p class="calibre9">This list of design criteria is not unique for stream ciphers designed by the
system-theoretic approach; it is true for all stream ciphers. It is even true for all
block ciphers. The unique point about the system-theoretic approach is that
stream ciphers are designed to satisfy these goals directly.</p>

<p class="calibre9">The major problem with these cryptosystems is that nothing can be proven
about their security; the design criteria have never been proved to be either
necessary or sufficient for security. A keystream generator may satisfy all the
design principles, but could still turn out to be insecure. Another could turn out
to be secure. There is still some magic to the process.</p>

<p class="calibre9">On the other hand, breaking each of these keystream generators is a different
problem for a cryptanalyst. If enough different generators are out there, it may
not be worth the cryptanalyst’s time to try to break each one. He may better
achieve fame and glory by figuring out better ways to factor large numbers or
calculating discrete logarithms.</p>

<h3 id="17.9" class="calibre7">17.9 Complexity-Theoretic Approach to Stream-Cipher Design</h3>

<p class="calibre9">Rueppel also delineated a complexity-theoretic approach to stream-cipher
design. Here, a cryptographer attempts to use complexity theory to prove that
his generators are secure. Consequently, the generators tend to be more
complicated, based on the same sorts of hard problems as public-key
cryptography. And like public-key algorithms, they tend to be slow and
cumbersome.</p>

<h4 class="calibre8">Shamir’s Pseudo-Random-Number Generator</h4>

<p class="calibre9">Adi Shamir used the RSA algorithm as a pseudo-random-number generator
[<a href="Applied%20Cryptography_split_036.html#r1417" class="calibre5 pcalibre">1417</a>]. While Shamir showed that predicting the output of the
pseudo-random-number generator is equivalent to breaking RSA, potential
biases in the output were demonstrated in [<a href="Applied%20Cryptography_split_036.html#r1401" class="calibre5 pcalibre">1401</a>,<a href="Applied%20Cryptography_split_035.html#r200" class="calibre5 pcalibre">200</a>].</p>

<h4 class="calibre8">Blum-Micali Generator</h4>

<p class="calibre9">This generator gets its security from the difficulty of computing discrete
logarithms [<a href="Applied%20Cryptography_split_035.html#r200" class="calibre5 pcalibre">200</a>]. Let <i class="calibre12">g</i> be a prime and <i class="calibre12">p</i> be an odd prime. A key <i class="calibre12">x</i><sub class="calibre15">0</sub>, starts off the process:</p>

<p class="math"><i class="calibre12">x</i><sub class="calibre15">i+1</sub> = <i class="calibre12">g<sup class="calibre19">x<sub class="calibre16">i</sub></sup></i> mod <i class="calibre12">p</i>
</p>

<p class="calibre9">The output of the generator is 1 if <i class="calibre12">x</i><sub class="calibre15">i</sub> &lt; (<i class="calibre12">p</i> - 1)/2, and 0 otherwise.</p>

<p class="calibre9">If <i class="calibre12">p</i> is large enough so that computing discrete logarithms mod <i class="calibre12">p</i> is infeasible, then this generator is secure. Additional theoretical results can be found in
[<a href="Applied%20Cryptography_split_036.html#r1627" class="calibre5 pcalibre">1627</a>, <a href="Applied%20Cryptography_split_036.html#r986" class="calibre5 pcalibre">986</a>, <a href="Applied%20Cryptography_split_036.html#r985" class="calibre5 pcalibre">985</a>, <a href="Applied%20Cryptography_split_036.html#r1237" class="calibre5 pcalibre">1237</a>, <a href="Applied%20Cryptography_split_036.html#r896" class="calibre5 pcalibre">896</a>, <a href="Applied%20Cryptography_split_035.html#r799" class="calibre5 pcalibre">799</a>].</p>

<h4 class="calibre8">RSA</h4>

<p class="calibre9">This RSA generator [<a href="Applied%20Cryptography_split_035.html#r35" class="calibre5 pcalibre">35</a>,<a href="Applied%20Cryptography_split_035.html#r36" class="calibre5 pcalibre">36</a>] is a modification of [<a href="Applied%20Cryptography_split_035.html#r200" class="calibre5 pcalibre">200</a>]. The initial parameters
are a modulus <i class="calibre12">N</i> which is the product of two large primes <i class="calibre12">p</i> and <i class="calibre12">q</i>, an integer <i class="calibre12">e</i> which is relatively prime to (<i class="calibre12">p</i> - 1) (<i class="calibre12">q</i> - 1), and a random seed <i class="calibre12">x</i><sub class="calibre15">0</sub>, where <i class="calibre12">x</i><sub class="calibre15">0</sub> is less than <i class="calibre12">N</i>.</p>

<p class="math"><i class="calibre12">x</i><sub class="calibre15">i+1</sub> = <i class="calibre12">x</i><sup class="calibre19">e</sup><sub class="calibre15">i</sub> mod <i class="calibre12">N</i>
</p>

<p class="calibre9">The output of the generator is the least significant bit of <i class="calibre12">x</i><sub class="calibre15">i</sub>. The security of this generator is based on the difficulty of breaking RSA. If <i class="calibre12">N</i> is large enough, then the generator is secure. Additional theory can be found in
[<a href="Applied%20Cryptography_split_036.html#r1569" class="calibre5 pcalibre">1569</a>,<a href="Applied%20Cryptography_split_036.html#r1570" class="calibre5 pcalibre">1570</a>,<a href="Applied%20Cryptography_split_036.html#r1571" class="calibre5 pcalibre">1571</a>,<a href="Applied%20Cryptography_split_035.html#r30" class="calibre5 pcalibre">30</a>,<a href="Applied%20Cryptography_split_035.html#r354" class="calibre5 pcalibre">354</a>].</p>

<h4 class="calibre8">Blum, Blum, and Shub</h4>

<p class="calibre9">The simplest and most efficient complexity-theoretic generator is called the
Blum, Blum, and Shub generator, after its inventors. Mercifully, we shall
abbreviate it to <b class="calibre10">BBS</b>, although it is sometimes called the quadratic residue
generator [<a href="Applied%20Cryptography_split_035.html#r193" class="calibre5 pcalibre">193</a>].</p>

<p class="calibre9">The theory behind the BBS generator has to do with quadratic residues modulo
<i class="calibre12">n</i> (see <a href="Applied%20Cryptography_split_014.html#11.3" class="calibre5 pcalibre">Section 11.3</a>). Here’s how it works.</p>

<p class="calibre9">First find two large prime numbers, <i class="calibre12">p</i> and <i class="calibre12">q</i>, which are congruent to 3 modulo 4. The product of those numbers, <i class="calibre12">n</i>, is a Blum integer. Choose another random
integer, <i class="calibre12">x</i>, which is relatively prime to <i class="calibre12">n</i>. Compute</p>

<p class="math"><i class="calibre12">x</i><sub class="calibre15">0</sub> = <i class="calibre12">x</i><sup class="calibre19">2</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">That’s the seed for the generator.</p>

<p class="calibre9">Now you can start computing bits. The <i class="calibre12">i</i>th pseudo-random bit is the least
significant bit of <i class="calibre12">x</i><sub class="calibre15">i</sub>, where</p>

<p class="math">x<sub class="calibre15">i</sub> = <i class="calibre12">x</i><sub class="calibre15">i-1</sub><sup class="calibre19">2</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">The most intriguing property of this generator is that you don’t have to iterate
through all <i class="calibre12">i</i> - 1 bits to get the <i class="calibre12">i</i> th bit. If you know <i class="calibre12">p</i> and <i class="calibre12">q</i>, you can compute the <i class="calibre12">i</i>th bit directly.</p>

<p class="math">b<sub class="calibre15">i</sub> is the least significant bit of <i class="calibre12">x</i><sub class="calibre15">i</sub>, where <i class="calibre12">x</i><sub class="calibre15">i</sub> = <i class="calibre12">x</i><sub class="calibre15">0</sub><sup class="calibre19">(2<sup class="calibre66">i</sup>) mod ((<i class="calibre22">p</i>-1)(<i class="calibre22">q</i>-1))</sup> mod <i class="calibre12">n</i>
</p>

<p class="calibre9">This property means you can use this cryptographically strong
pseudo-random-bit generator as a stream cryptosystem for a random-access
file.</p>

<p class="calibre9">The security of this scheme rests on the difficulty of factoring <i class="calibre12">n</i>. You can
make <i class="calibre12">n</i> public, so anyone can generate bits using the generator. However,
unless a cryptanalyst can factor <i class="calibre12">n</i>, he can never predict the output of the
generator — not even with a statement like: “The next bit has a 51 percent
chance of being a 1.”</p>

<p class="calibre9">More strongly, the BBS generator is <b class="calibre10">unpredictable to the left</b> and
<b class="calibre10">unpredictable to the right</b>. This means that given a sequence generated by
the generator, a cryptanalyst cannot predict the next bit in the sequence nor the
previous bit in the sequence. This is not security based on some complicated
bit generator that no one understands, but the mathematics behind factoring <i class="calibre12">n</i>.</p>

<p class="calibre9">This algorithm is slow, but there are speedups. As it turns out, you can use
more than the least significant bit of each <i class="calibre12">x</i><sub class="calibre15">i</sub> as a pseudo-random bit. According to [<a href="Applied%20Cryptography_split_036.html#r1569" class="calibre5 pcalibre">1569</a>, <a href="Applied%20Cryptography_split_036.html#r1570" class="calibre5 pcalibre">1570</a>, <a href="Applied%20Cryptography_split_036.html#r1571" class="calibre5 pcalibre">1571</a>, <a href="Applied%20Cryptography_split_035.html#r35" class="calibre5 pcalibre">35</a>, <a href="Applied%20Cryptography_split_035.html#r36" class="calibre5 pcalibre">36</a>], if <i class="calibre12">n</i> is the length of <i class="calibre12">x</i><sub class="calibre15">i</sub>, the least significant <i class="calibre12">log</i><sub class="calibre15">2</sub><i class="calibre12">n</i> bits of <i class="calibre12">x</i><sub class="calibre15">i</sub> can be used. The BBS generator is comparatively slow and isn’t
useful for stream ciphers. However, for high-security applications, such as key
generation, this generator is the best of the lot.</p>

<h3 id="17.10" class="calibre7">17.10 Other Approaches to Stream-Cipher Design</h3>

<p class="calibre9">In an information-theoretic approach to stream ciphers, the cryptanalyst is
assumed to have unlimited time and computing power. The only practical
stream cipher that is secure against an adversary like this is a one-time pad (see
<a href="Applied%20Cryptography_split_001.html#1.5" class="calibre5 pcalibre">Section 1.5</a>). Since bits would be impractical on a pad, this is sometimes called
a <b class="calibre10">one-time tape</b>. Two magnetic tapes, one at the encryption end and the other
at the decryption end, would have the same random keystream on them. To
encrypt, simply XOR the plaintext with the bits on the tape. To decrypt, XOR
the ciphertext with the bits on the other, identical, tape. You never use the
same keystream bits twice. Since the keystream bits are truly random, no one
can predict the keystream. If you burn the tapes when you are through with
them, you’ve got perfect secrecy (assuming no one else has copies of the tape).</p>

<p class="calibre9">Another information-theoretic stream cipher, developed by Claus Schnorr,
assumes that the cryptanalyst only has access to a limited number of ciphertext
bits [<a href="Applied%20Cryptography_split_036.html#r1395" class="calibre5 pcalibre">1395</a>]. The results are highly theoretical and have no practical value, at
least not yet. For more details, consult [<a href="Applied%20Cryptography_split_036.html#r1361" class="calibre5 pcalibre">1361</a>,<a href="Applied%20Cryptography_split_036.html#r1643" class="calibre5 pcalibre">1643</a>,<a href="Applied%20Cryptography_split_036.html#r1193" class="calibre5 pcalibre">1193</a>].</p>

<p class="calibre9">In a randomized stream cipher, the cryptographer tries to ensure that the
cryptanalyst has an infeasibly large problem to solve. The objective is to
increase the number of bits the cryptanalyst has to work with, while keeping
the secret key small. This can be done by making use of a large public random
string for encryption and decryption. The key would specify which parts of the
large random string are to be used for encryption and decryption. The
cryptanalyst, not knowing the key, is forced to pursue a brute-force search
through the random string. The security of this sort of cipher can be expressed
by the average number of bits a cryptanalyst must examine before the chances
of determining the key improve over pure guessing.</p>

<h4 class="calibre8">Rip van Winkle Cipher</h4>

<p class="calibre9">James Massey and Ingemar Ingemarsson proposed the Rip van Winkle cipher
[<a href="Applied%20Cryptography_split_036.html#r1011" class="calibre5 pcalibre">1011</a>], so named because the receiver has to receive 2<sup class="calibre19">n</sup> bits of ciphertext
before attempting decryption. The algorithm, illustrated in Figure 17.10, is
simple to implement, provably secure, and completely impractical. Simply
XOR the plaintext with the keystream, and delay the keystream by 0 to 20
years — the exact delay is part of the key. In Massey’s words: “One can easily
guarantee that the enemy cryptanalyst will need thousands of years to break
the cipher, if one is willing to wait millions of years to read the plaintext.”
Further work on this idea can be found in [<a href="Applied%20Cryptography_split_036.html#r1577" class="calibre5 pcalibre">1577</a>,<a href="Applied%20Cryptography_split_035.html#r755" class="calibre5 pcalibre">755</a>].</p>

<div class="figure" id="figure-17-10">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-10.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.10</b> Rip van Winkle cipher.</i></p>
</div>

<h4 class="calibre8">Diffie’s Randomized Stream Cipher</h4>

<p class="calibre9">This scheme was first proposed by Whitfield Diffie [<a href="Applied%20Cryptography_split_036.html#r1362" class="calibre5 pcalibre">1362</a>]. The data are 2n
random sequences. The key is <i class="calibre12">k</i>, a random <i class="calibre12">n-</i> bit string. To encrypt a message, Alice uses the <i class="calibre12">k</i>th random string as a one-time pad. She then sends the
ciphertext plus the 2<sup class="calibre19"><i class="calibre22">n</i></sup> random strings over 2<sup class="calibre19"><i class="calibre22">n</i></sup> + 1 different communications channels.</p>

<p class="calibre9">Bob knows <i class="calibre12">k</i>, so he can easily choose which one-time pad to decrypt the
message with. Eve has no choice but to examine the random sequences one at
a time until she finds the correct one-time pad. Any attack must examine an
expected number of bits which is in O(2<sup class="calibre19"><i class="calibre22">n</i></sup>). Rueppel points out that if you send <i class="calibre12">n</i> random strings instead of 2<sup class="calibre19"><i class="calibre22">n</i></sup>, and if the key is used to specify a linear combination of those random strings, the security is the same.</p>

<h4 class="calibre8">Maurer’s Randomized Stream Cipher</h4>

<p class="calibre9">Ueli Maurer described a scheme based on XORing the plaintext with several
large public random-bit sequences [<a href="Applied%20Cryptography_split_036.html#r1034" class="calibre5 pcalibre">1034</a>,<a href="Applied%20Cryptography_split_036.html#r1029" class="calibre5 pcalibre">1029</a>,<a href="Applied%20Cryptography_split_036.html#r1030" class="calibre5 pcalibre">1030</a>]. The key is the set of
starting positions within each sequence. This turns out to be provably almost
secure, with a calculable probability of being broken based on how much
memory the attacker has at his disposal, without regard to the amount of
computing power he has. Maurer claims that this scheme would be practical
with about 100 different sequences of 10<sup class="calibre19">20</sup> random bits each. Digitizing the
face of the moon might be one way to get this many bits.</p>

<h3 id="17.11" class="calibre7">17.11 Cascading Multiple Stream Ciphers</h3>

<p class="calibre9">If performance is no issue, there’s no reason not to choose multiple stream
ciphers and cascade them. Simply XOR the output of each generator with the
plaintext to get the ciphertext. Ueli Maurer’s result (see <a href="Applied%20Cryptography_split_018.html#15.7" class="calibre5 pcalibre">Section 15.7</a>) says that
if the generators have independent keys, then the security of the cascade is at
least as secure as the strongest algorithm in the cascade. It is probably much
more secure than that.</p>

<p class="calibre9">Stream ciphers can be combined in all the same ways as block ciphers (see
<a href="Applied%20Cryptography_split_018.html#15" class="calibre5 pcalibre">Chapter 15</a>). Stream ciphers can be cascaded (see <a href="Applied%20Cryptography_split_018.html#15.7" class="calibre5 pcalibre">Section 15.7</a>) with other
stream ciphers, or together with block ciphers.</p>

<p class="calibre9">A clever trick is to use one algorithm, either a block or stream algorithm, to
frequently rekey a fast stream algorithm (which could even be a block
algorithm in OFB mode). The fast algorithm could be weak, since a
cryptanalyst would never see very much plaintext encrypted with any one key.</p>

<p class="calibre9">There’s a trade-off between the size of the fast algorithm’s internal state
(which may impact security) and how often you can afford to rekey. The rekey
needs to be relatively fast; algorithms that have a long key setup routine aren’t
suitable for this kind of application. And the rekeying should be independent
of the internal state of the fast algorithm.</p>

<h3 id="17.12" class="calibre7">17.12 Choosing a Stream Cipher</h3>

<p class="calibre9">If the study of stream ciphers offers any lessons, it’s that new types of attacks
are invented with alarming regularity. Classically, stream ciphers have been
based on considerable mathematical theory. This theory can be used to prove
good properties about the cipher, but can also be used to find new attacks
against the cipher. I worry about any stream cipher based solely on LFSRs for
this reason.</p>

<p class="calibre9">I prefer stream ciphers that are designed more along the lines of block ciphers:
nonlinear transformations, large S-boxes, and so on. RC4 is my favorite, and
SEAL is a close second. I would be very interested in seeing cryptanalytic
results against my generators that combine LFSRs and FCSRs; this seems to
be a very fruitful area of stream-cipher research to mine for actual designs. Or,
you can use a block cipher in OFB or CFB to get a stream cipher.</p>

<p class="calibre9">Table 17.3 gives some timing measurements for some algorithms. These are
meant for comparison purposes only.</p>

<table class="data-table1" id="table-17-3">
<caption class="calibre67">Table 17.3 - Encryption Speeds of Some Stream Ciphers on a 33MHz 486SX</caption>
<tbody class="calibre24"><tr class="calibre68">
<th class="calibre26">Algorithm</th>
<th class="calibre26">Encryption Speed (Kilobytes/Second)</th>
</tr>
<tr class="calibre25"><td class="calibre70">A5</td><td class="calibre70">5</td></tr>
<tr class="calibre25"><td class="calibre70">PIKE</td><td class="calibre70">62</td></tr>
<tr class="calibre71"><td class="calibre72">RC4</td><td class="calibre72">164</td></tr>
<tr class="calibre25"><td class="calibre70">SEAL</td><td class="calibre70">381</td></tr>
</tbody></table>

<h3 id="17.13" class="calibre7">17.13 Generating Multiple Streams from a Single Pseudo-Random-Sequence Generator</h3>

<p class="calibre9">If you need to encrypt multiple channels of communications in a single box — a
multiplexer, for example — the easy solution is to use a different
pseudo-random-sequence generator for each stream. This has two problems: It
requires more hardware, and all the different generators have to be
synchronized. It would be simpler to use a single generator.</p>

<p class="calibre9">One solution is to clock the generator multiple times. If you want three
independent streams, clock the generator three times and send 1 bit into each
stream. This technique works, but you may have trouble clocking the generator
as fast as you would like. For example, if you can only clock the generator
three times as fast as the data stream, you can only create three streams.
Another way is to use the same sequence for each channel — perhaps with a
variable time delay. This is insecure.</p>

<p class="calibre9">A really clever idea [<a href="Applied%20Cryptography_split_036.html#r1489" class="calibre5 pcalibre">1489</a>], patented by the NSA, is shown in Figure 17.11.
Dump the output of your favorite generator into an <i class="calibre12">m-</i>bit simple shift register.
At each clock pulse, shift the register one to the right. Then, for each output
stream, AND the register with a different <i class="calibre12">m-</i> bit control vector viewed as a
unique identifier for the desired output stream, then XOR all the bits together
to get the output bit for that stream. If you want several output streams in
parallel, you need a separate control vector and an XOR/AND logic array for
each output stream.</p>

<div class="figure" id="figure-17-11">
<div class="image1">
<p class="calibre9"><img src="ac-figure-17-11.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 17.11</b> Multiple-bit generator.</i></p>
</div>

<p class="calibre9">There are some things to watch out for. If any of the streams are linear
combinations of other streams, then the system can be broken. But if you are
clever, this is an easy and secure way to solve the problem.</p>

<h3 id="17.14" class="calibre7">17.14 Real Random-Sequence Generators</h3>

<p class="calibre9">Sometimes cryptographically secure pseudo-random numbers are not good
enough. Many times in cryptography, you want real random numbers. Key
generation is a prime example. It’s fine to generate random cryptographic keys
based on a pseudo-random sequence generator, but if an adversary gets a copy
of that generator and the master key, the adversary can create the same keys
and break your cryptosystem, no matter how secure your algorithms are. A
random-sequence generator’s sequences cannot be reproduced. No one, not
even you, can reproduce the bit sequence out of those generators.</p>

<p class="calibre9">There is a large philosophical debate over whether any of these techniques
actually produces real random bits. I am not going to address that debate. The
point here is to produce bits that have the same statistical properties as random
bits and are not reproducible.</p>

<p class="calibre9">The important thing about any real random-sequence generator is that it be
tested. There is a wealth of literature on this topic. Tests of randomness can be
found in [<a href="Applied%20Cryptography_split_036.html#r863" class="calibre5 pcalibre">863</a>,<a href="Applied%20Cryptography_split_035.html#r99" class="calibre5 pcalibre">99</a>]. Maurer showed that all these tests can be derived from
trying to compress the sequence [<a href="Applied%20Cryptography_split_036.html#r1031" class="calibre5 pcalibre">1031</a>,<a href="Applied%20Cryptography_split_036.html#r1032" class="calibre5 pcalibre">1032</a>]. If you can compress a random
sequence, then it is not truly random.</p>

<p class="calibre9">Anyhow, what we have here is a whole lot of black magic. The primary point
is to generate a sequence of bits that your adversary is unlikely to guess. It
doesn’t sound like much, but it’s harder than you think. I can’t prove that any
of these techniques generates random bits. These techniques produce a
sequence of bits that cannot be easily reproduced. For some details, see
[<a href="Applied%20Cryptography_split_036.html#r1375" class="calibre5 pcalibre">1375</a>,<a href="Applied%20Cryptography_split_036.html#r1376" class="calibre5 pcalibre">1376</a>,<a href="Applied%20Cryptography_split_035.html#r511" class="calibre5 pcalibre">511</a>].</p>

<h4 class="calibre8">RAND Tables</h4>

<p class="calibre9">Back in 1955, when computers were still new, the Rand Corporation published
a book that contained a million random digits [<a href="Applied%20Cryptography_split_036.html#r1289" class="calibre5 pcalibre">1289</a>]. Their method is
described in the book:</p>

<p class="quote">The random digits in the book were produced by rerandomization
of a basic table generated by an electronic roulette wheel. Briefly,
a random frequency pulse source, providing on the average about
100,000 pulses per second, was gated about once per second by a
constant frequency pulse. Pulse standardization circuits passed the
pulses through a 5-place binary counter. In principle the machine
was a 32-place roulette wheel which made, on the average, about
3000 revolutions per trial and produced one number per second.
A binary-to-decimal converter was used which converted 20 of
the 32 numbers (the other twelve were discarded) and retained
only the final digit of two-digit numbers; this final digit was fed
into an IBM punch to produce finally a punched card table of
random digits.</p>

<p class="calibre9">The book goes on to discuss the results of various randomness tests on the
data. It also suggests how to use the book to find a random number:</p>

<p class="quote">The lines of the digit table are numbered from 00000 to 19999. In
any use of the table, one should first find a random starting
position. A common procedure for doing this is to open the book
to an unselected page of the digit table and blindly choose a
five-digit number; this number with the first digit reduced modulo
2 determines the starting line; the two digits to the right of the
initially selected five-digit number are reduced modulo 50 to
determine the starting column in the starting line. To guard
against the tendency of books to open repeatedly at the same page
and the natural tendency of a person to choose a number toward
the center of the page: every five-digit number used to determine
a starting position should be marked and not used a second time
for this purpose.</p>

<p class="calibre9">The meat of the book is the “Table of Random Digits.” It lists them in 5-digit
groups — “<code class="calibre18">10097 32533 76520 13586 ...</code>” — 50 on a line and 50 lines on a page.
The table goes on for 400 pages and, except for a particularly racy section on
page 283 which reads “<code class="calibre18">69696</code>,” makes for a boring read. The book also
includes a table of 100,000 normal deviates.</p>

<p class="calibre9">The interesting thing about the RAND book is not its million random digits,
but that they were created before the computer revolution. Many cryptographic
algorithms use arbitrary constants — so-called “magic numbers.” Choosing
magic numbers from the RAND tables ensures that they haven’t been specially
chosen for some nefarious reason. Khafre does this, for example.</p>

<h4 class="calibre8">Using Random Noise</h4>

<p class="calibre9">The best way to collect a large number of random bits is to tap the natural
randomness of the real world. Often this method requires specialized
hardware, but you can play tricks with computers.</p>

<p class="calibre9">Find an event that happens regularly but randomly: atmospheric noise peaking
at a certain threshold, a toddler falling while learning to walk, or some such.
Measure the time interval between one event and the next event. Record it.
Measure the time interval between the second event and the third event.
Record it as well. If the first time interval is greater than the second, output 1
as the bit. If the second time interval is greater than the first, output 0 as the
event. Do it again for the next event.</p>

<p class="calibre9">Throw a dart at the New York Stock Exchange closing prices in your local
newspaper. Compare the closing price of the stock you hit with the closing
price of the stock directly above it. If the one you hit is more, output 0; if it
less, output 1.</p>

<p class="calibre9">Hook a Geiger counter up to your computer, count emissions over a fixed time
interval, and keep the least significant bit. Or measure the time between
successive ticks. (Since the radioactive source is decaying, the average time
between successive ticks is continuously getting longer. You want to choose a
source with the half life long enough to make this negligible — like plutonium.
Or, if you’re worried about your health, you can apply appropriate statistical
corrections.)</p>

<p class="calibre9">G. B. Agnew proposed a real random-bit generator, suitable for integration
into a VLSI device [<a href="Applied%20Cryptography_split_035.html#r21" class="calibre5 pcalibre">21</a>]. It is a metal insulator semiconduction capacitor
(MISC). Two of them are placed in close proximity, and the random bit is a
function of the difference in charge between the two. Another random-number
generator generates a random-bit stream based on the frequency instability in a
free-running oscillator [<a href="Applied%20Cryptography_split_035.html#r535" class="calibre5 pcalibre">535</a>]. A commercial chip from AT&amp;T generates
random numbers from the same phenomenon [<a href="Applied%20Cryptography_split_035.html#r67" class="calibre5 pcalibre">67</a>]. M. Gude built a
random-number generator that collected random bits from physical
phenomena, such as radioactive decay [<a href="Applied%20Cryptography_split_035.html#r668" class="calibre5 pcalibre">668</a>,<a href="Applied%20Cryptography_split_035.html#r669" class="calibre5 pcalibre">669</a>]. Manfield Richter developed
a random-number generator based on thermal noise from a semiconductor
diode [<a href="Applied%20Cryptography_split_036.html#r1309" class="calibre5 pcalibre">1309</a>].</p>

<p class="calibre9">Supposedly the time intervals between successive 2e4 light emissions from a
trapped mercury atom are random. Use that. Better yet, find a semiconductor
company that makes random-number-generation chips; they are out there.</p>

<p class="calibre9">There is also a random-number generator that uses the computer’s disk drive
[<a href="Applied%20Cryptography_split_035.html#r439" class="calibre5 pcalibre">439</a>]. It measures the time required to read a disk block and uses the variation
in that time as a random number source. It filters the timing data to remove
structure that comes from quantization, then applies a fast Fourier transform to
vectors of the numbers. This removes bias and correlation. Finally, it uses the
spectral angles for frequencies in (0, π), normalized to the unit interval, as the
random bits. A large part of the variation in disk rotation speed is caused by air
turbulence, so there is randomness in the system. There are caveats, though. If
you keep too many bits of the output, you are using the fast Fourier transform
as a random-number generator and risk predictability. And it’s best to read the
same disk block over and over, so that your filtering doesn’t have to remove
structure that comes from the disk-scheduler. An implementation of this
system was able to collect about 100 bits per minute [<a href="Applied%20Cryptography_split_035.html#r439" class="calibre5 pcalibre">439</a>].</p>

<h4 class="calibre8">Using the Computer’s Clock</h4>

<p class="calibre9">If you want a single random bit (or even a few), take the least significant bit
from any clock register. This might not be terribly random in a UNIX system
because of various potential synchronizations, but it works on some personal
computers.</p>

<p class="calibre9">Beware of getting too many bits this way. Executing the same subroutine
several times in succession could easily skew bits generated in this manner.
For example, if each bit generation subroutine takes an even number of clock
ticks to execute, you will get an endless stream of the same bit out of the
generator. If each subroutine takes an odd number of clock ticks to execute,
you will get an endless stream of alternating bits out of the generator. Even if
the resonance isn’t this obvious, the resultant bit stream will be far from
random.</p>

<p class="calibre9">One random-number generator works this way [<a href="Applied%20Cryptography_split_036.html#r918" class="calibre5 pcalibre">918</a>]:</p>

<p class="quote">Our truly random number generator...works by setting an alarm
and then incrementing a counter register rapidly in the CPU until
an interrupt occurs. The contents of the register are then XORed
with the contents of an output buffer byte (truncating the
register’s data to 8 bits). After each byte of the output buffer is
filled, the buffer is further processed by doing a right, circular
shift of each character by 2 bits. This has the effect of moving the
most active (and random) least significant bits into the most
significant positions. The entire process is then repeated 3 times.
Finally each character of the buffer has been touched by the two
most random bits of the counter register after interrupts. That is
4<i class="calibre12">n</i> interrupts have occurred where <i class="calibre12">n</i> is the number of desired
random bytes.</p>

<p class="calibre9">This method is very sensitive to the randomness of system interrupts and the
granularity of the clock. The output looked pretty good when tested on real
UNIX machines.</p>

<h4 class="calibre8">Measuring Keyboard Latency</h4>

<p class="calibre9">People’s typing patterns are both random and nonrandom. They are
nonrandom enough that they can be used as a means of identification, but they
are random enough that they can be used to generate random bits. Measure the
time between successive keystrokes, then take the least significant bits of those
measurements. These bits are going to be pretty random. This technique may
not work on a UNIX terminal, since the keystrokes pass through filters and
other mechanisms before they get to your program, but it will work on most
personal computers.</p>

<p class="calibre9">Ideally, you only want to collect one random bit per keystroke. Collecting more may skew the results, depending on how good a typist is sitting at the keyboard. This technique is limited, though. While it’s easy to have someone type 100 words or so when it is time to generate a key, it isn’t reasonable to ask the typist to type a 100,000-word essay to generate a keystream for a one-time pad.</p>

<h4 class="calibre8">Biases and Correlations</h4>

<p class="calibre9">A major problem with all these systems is that there could be nonrandomness in the generated sequence. The underlying physical processes might be random, but many kinds of measuring instruments are between the digital part of the computer and the physical process. Those instruments could easily introduce problems.</p>

<p class="calibre9">A way to eliminate <b class="calibre10">bias</b>, or skew, is to XOR several bits together. If a random bit is biased toward 0 by a factor <i class="calibre12">e</i>, then the probability of 0 can be written as:</p>

<p class="math-left">P(0) = .5 + <i class="calibre12">e</i>
</p>

<p class="calibre9">XORing two of these bits together yields:</p>

<p class="math-left">P(0) = (.5 + <i class="calibre12">e</i>)<sup class="calibre19">2</sup> + (.5 - <i class="calibre12">e</i>)<sup class="calibre19">2</sup> = .5 + 2 <i class="calibre12">e</i><sup class="calibre19">2</sup>
</p>

<p class="calibre9">By the same calculation, XORing 4 bits together yields:</p>

<p class="math-left">P(0) = .5 + 8<i class="calibre12">e</i><sup class="calibre19">4</sup>
</p>

<p class="calibre9">XORing <i class="calibre12">m</i> bits will exponentially converge to an equal probability of 0 and 1. If you know the maximum bias you are willing to accept for your application, you can calculate how many bits you need to XOR together to get random bits below that bias.</p>

<p class="calibre9">An even better method is to look at the bits in pairs. If the 2 bits are the same, discard them and look at the next pair. If the 2 bits are different, take the first bit as the output of the generator. This eliminates bias completely. Other techniques for reducing bias use transition mappings, compression, and fast Fourier transforms [<a href="Applied%20Cryptography_split_035.html#r511" class="calibre5 pcalibre">511</a>].</p>

<p class="calibre9">The potential problem with both methods is that if there is a <b class="calibre10">correlation</b> between adjacent bits, then these methods will increase the bias. One way to correct this is to use multiple random sources. Take four different random sources and XOR the bits together; or take two random sources, and look at those bits in pairs.</p>

<p class="calibre9">For example, take a radioactive source and hook a Geiger counter to your computer. Take a pair of noisy diodes and record as an event every time the noise exceeds a certain peak. Measure atmospheric noise. Get a random bit from each and XOR them together to produce the random bit. The possibilities are endless.</p>

<p class="calibre9">The mere fact that a random-number generator has a bias does not necessarily mean that it is unusable. It just means that it is less secure. For example, consider the problem of Alice generating a triple-DES 168-bit key.
All she has is a random-bit generator with a bias toward 0: It produces 55 percent 0s and 45 percent 1s. This means that there are only 0.99277 bits of entropy per key bit, as opposed to 1 bit of entropy if the generator were perfect. Mallory, trying to break the key, can optimize his brute-force search to try the most probable key
first (000...0), and work toward the least probable key (111...1). Because of the bias, Mallory can expect to find the key in 2<sup class="calibre19">109</sup> attempts. If there were no bias, Mallory would expect to make 2<sup class="calibre19">111</sup> attempts. The resultant key is less secure, but not appreciably so.</p>

<h4 class="calibre8">Distilling Randomness</h4>

<p class="calibre9">In general, the best way to generate random numbers is to find a whole lot of seemingly random events and distill randomness from them. This randomness can then be stored in a pool or reservoir that applications can draw on as needed. One-way hash functions are ready-made for the job; they’re fast, so you can shovel quite a bit through them without worrying too much about performance or the actual randomness of each observation.
Hash almost anything you can find that has at least some randomness. Try:</p>

<ul class="calibre13">

<li class="calibre14">A copy of every keystroke
</li>
<li class="calibre14">Mouse commands
</li>
<li class="calibre14">The sector number, time of day, and seek latency for every disk operation
</li>
<li class="calibre14">Actual mouse position
</li>
<li class="calibre14">Number of current scanline of monitor
</li>
<li class="calibre14">Contents of the actually displayed image
</li>
<li class="calibre14">Contents of FATs, kernel tables, and so on
</li>
<li class="calibre14">Access/modify times of /dev/tty
</li>
<li class="calibre14">CPU load
</li>
<li class="calibre14">Arrival times of network packets
</li>
<li class="calibre14">Input from a microphone
</li>
<li class="calibre14">/dev/audio without a microphone attached
</li>

</ul>

<p class="calibre9">If your system uses separate crystal oscillators for its CPU and time-of-day clocks, try reading the time of day in a tight loop. On some (but not all) systems this will reflect the random phase jitter between the two oscillators.</p>

<p class="calibre9">Since much of the randomness in these events is in their timing, use the most finely grained time-of-day clock you can find. A standard PC uses an Intel 8254 clock chip (or equivalent) driven at 1.1931818 megahertz, so reading the counter register directly gives you 838-nanosecond resolution. To avoid skewing the results, avoid taking your event samples on a timer interrupt.</p>

<p class="calibre9">Here is the process in C with MD5 (see <a href="Applied%20Cryptography_split_021.html#18.5" class="calibre5 pcalibre">Section 18.5</a>) as the hash function:</p>

<pre class="calibre20">char Randpool[16];

/* Call early and call often on a wide variety of random or semi-
 * random system events to churn the randomness pool.
 * The exact format and length of randevent doesn’t matter as long as
 * its contents are at least somewhat unpredictable.
 */
void churnrand(char *randevent,unsigned int randlen)
{
    MD5_CTX md5;
    MD5Init(&amp;md5);
    MD5Update(&amp;md5,Randpool,sizeof(Randpool));
    MD5Update(&amp;md5,randevent,randlen);
    MD5Final(Randpool,&amp;md5);
}
</pre>

<p class="calibre9">After calling churnrand() enough to build up sufficient randomness in Randpool, you can now generate random bits from it. MD5 again comes in handy, this time as a counter-mode pseudo-random byte-stream generator.</p>

<pre class="calibre20">long Randcnt;
void genrand(char *buf,unsigned int buflen)
{
    MD5_CTX md5;
    char tmp[16];
    unsigned int n;

    while(buflen != 0) {
        /* Hash the pool with a counter */
        MD5Init(&amp;md5);
        MD5Update(&amp;md5,Randpool,sizeof(Randpool));
        MD5Update(&amp;md5,(unsigned char *)&amp;Randcnt,sizeof(Randcnt));
        MD5Final(tmp,&amp;md5);
        Randcnt++; /* Increment counter */

        /* Copy 16 bytes or requested amount, whichever is less,
         * to the user’s buffer */
        n = (buflen &lt; 16) ? buflen : 16;
        memcpy(buf,tmp,n);
        buf += n;
        buflen -= n;
    }
}
</pre>

<p class="calibre9">The hash function is crucial here for several reasons. First, it provides an easy way to generate an arbitrary amount of pseudo-random data without having to call churnrand() each time. In effect, the system degrades gracefully from perfect to practical randomness when the demand exceeds the supply. In this case it becomes <i class="calibre12">theoretically</i> possible to use the result from one genrand() call to determine a previous or subsequent result.
But this requires inverting MD5, which is computationally infeasible.</p>

<p class="calibre9">This is important since the routine doesn’t know what each caller will do with the random data it returns. One call might generate a random number for a protocol that is sent in the clear, perhaps in response to a direct request by an attacker. The very next call might generate a secret key for an unrelated session that the attacker wishes to penetrate. Obviously, it is very important that an attacker not be able to deduce the secret key from the nonce.</p>

<p class="calibre9">One problem remains. There must be sufficient randomness in the Randpool[] array before the first call to genrand(). If the system has been running for a while with a local user typing on the keyboard, no problem.
But what about a standalone system that reboots automatically without seeing any keyboard or mouse input?</p>

<p class="calibre9">This is a tough one. A partial solution would require the operator to type for a while after the very first reboot, and to create a seed file on disk before shutting down to carry the randomness in Randseed[] across reboots.
But do not save the Randseed[] array directly. An attacker who steals this file could determine all of the results from genrand() after the last call to churnrand() prior to the file being created.</p>

<p class="calibre9">The fix to this problem is to hash the Randseed[] array before storing it, perhaps by just calling genrand().
When the system reboots, you read in the seed file, pass it to churnrand(), then promptly destroy it.
Unfortunately, this does not deal with the threat of someone stealing the seed file between reboots and using it to guess future values of the genrand() function. I see no solution to this problem other than to wait until enough external random events have taken place after a reboot before allowing genrand() to produce results.</p>

<div class="calibre6" id="calibre_pb_40"></div>
</div>






</body></html>
