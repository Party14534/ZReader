<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="6">Chapter 6 <br class="calibre3"/>
Esoteric Protocols</h1>

<h3 id="6.1" class="calibre7">6.1 Secure Elections</h3>

<p class="calibre9">Computerized voting will never be used for general elections unless there is a
protocol that both maintains individual privacy and prevents cheating. The
ideal protocol has, at the very least, these six requirements:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Only authorized voters can vote.
</li>
<li class="pcalibre1 calibre30">No one can vote more than once.
</li>
<li class="pcalibre1 calibre30">No one can determine for whom anyone else voted.
</li>
<li class="pcalibre1 calibre30">No one can duplicate anyone else’s vote. (This turns out to be the
hardest requirement.)
</li>
<li class="pcalibre1 calibre30">No one can change anyone else’s vote without being discovered.
</li>
<li class="pcalibre1 calibre30">Every voter can make sure that his vote has been taken into account
in the final tabulation.
</li>

</ol>

<p class="calibre9">Additionally, some voting schemes may have the following requirement:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Everyone knows who voted and who didn’t.
</li>

</ol>

<p class="calibre9">Before describing the complicated voting protocols with these characteristics,
let’s look at some simpler protocols.</p>

<h4 class="calibre8">Simplistic Voting Protocol #1</h4>

<ol class="calibre17">

<li class="calibre14">Each voter encrypts his vote with the public key of a Central
Tabulating Facility (CTF).
</li>
<li class="calibre14">Each voter sends his vote in to the CTF.
</li>
<li class="calibre14">The CTF decrypts the votes, tabulates them, and makes the results
public.
</li>

</ol>

<p class="calibre9">This protocol is rife with problems. The CTF has no idea where the votes are
from, so it doesn’t even know if the votes are coming from eligible voters. It
has no idea if eligible voters are voting more than once. On the plus side, no
one can change anyone else’s vote; but no one would bother trying to modify
someone else’s vote when it is far easier to vote repeatedly for the result of
your choice.</p>

<h4 class="calibre8">Simplistic Voting Protocol #2</h4>

<ol class="calibre17">

<li class="calibre14">Each voter signs his vote with his private key.
</li>
<li class="calibre14">Each voter encrypts his signed vote with the CTF’s public key.
</li>
<li class="calibre14">Each voter sends his vote to a CTF.
</li>
<li class="calibre14">The CTF decrypts the votes, checks the signatures, tabulates the
votes, and makes the results public.
</li>

</ol>

<p class="calibre9">This protocol satisfies properties one and two: Only authorized voters can vote
and no one can vote more than once — the CTF would record votes received in
step (3). Each vote is signed with the voter’s private key, so the CTF knows
who voted, who didn’t, and how often each voter voted. If a vote comes in that
isn’t signed by an eligible voter, or if a second vote comes in signed by a voter
who has already voted, the facility ignores it. No one can change anyone else’s
vote either, even if they intercept it in step (3), because of the digital signature.</p>

<p class="calibre9">The problem with this protocol is that the signature is attached to the vote; the
CTF knows who voted for whom. Encrypting the votes with the CTF’s public
key prevents anyone from eavesdropping on the protocol and figuring out who
voted for whom, but you have to trust the CTF completely. It’s analogous to
having an election judge staring over your shoulder in the voting booth.</p>

<p class="calibre9">These two examples show how difficult it is to achieve the first three
requirements of a secure voting protocol, let alone the others.</p>

<h4 class="calibre8">Voting with Blind Signatures</h4>

<p class="calibre9">We need to somehow dissociate the vote from the voter, while still
maintaining authentication. The blind signature protocol does just that.</p>

<ol class="calibre17">

<li class="calibre14">Each voter generates 10 sets of messages, each set containing a
valid vote for each possible outcome (e.g., if the vote is a yes or no
question, each set contains two votes, one for “yes” and the other for
“no”). Each message also contains a randomly generated identification
number, large enough to avoid duplicates with other voters.
</li>
<li class="calibre14">Each voter individually blinds all of the messages (see <a href="Applied%20Cryptography_split_006.html#5.3" class="calibre5 pcalibre">Section 5.3</a>)
and sends them, with their blinding factors, to the CTF.
</li>
<li class="calibre14">The CTF checks its database to make sure the voter has not
submitted his blinded votes for signature previously. It opens nine of the
sets to check that they are properly formed. Then it individually signs
each message in the set. It sends them back to the voter, storing the
name of the voter in its database.
</li>
<li class="calibre14">The voter unblinds the messages and is left with a set of votes
signed by the CTF. (These votes are signed but unencrypted, so the
voter can easily see which vote is “yes” and which is “no.”)
</li>
<li class="calibre14">The voter chooses one of the votes (ah, democracy) and encrypts it
with the CTF’s public key.
</li>
<li class="calibre14">The voter sends his vote in.
</li>
<li class="calibre14">The CTF decrypts the votes, checks the signatures, checks its
database for a duplicate identification number, saves the serial number,
and tabulates the votes. It publishes the results of the election, along
with every serial number and its associated vote.
</li>

</ol>

<p class="calibre9">A malicious voter, call him Mallory, cannot cheat this system. The blind
signature protocol ensures that his votes are unique. If he tries to send in the
same vote twice, the CTF will notice the duplicate serial number in step (7)
and throw out the second vote. If he tries to get multiple votes signed in step
(2), the CTF will discover this in step (3). Mallory cannot generate his own
votes because he doesn’t know the facility’s private key. He can’t intercept
and change other people’s votes for the same reason.</p>

<p class="calibre9">The cut-and-choose protocol in step (3) is to ensure that the votes are unique.
Without that step, Mallory could create a set of votes that are the same except
for the identification number, and have them all validated.</p>

<p class="calibre9">A malicious CTF cannot figure out how individuals voted. Because the blind
signature protocol prevents the facility from seeing the serial numbers on the
votes before they are cast, the CTF cannot link the blinded vote it signed with
the vote eventually cast. Publishing a list of serial numbers and their associated
votes allows voters to confirm that their vote was tabulated correctly.</p>

<p class="calibre9">There are still problems. If step (6) is not anonymous and the CTF can record
who sent in which vote, then it can figure out who voted for whom. However,
if it receives votes in a locked ballot box and then tabulates them later, it
cannot. Also, while the CTF may not be able to link votes to individuals, it can
generate a large number of signed, valid votes and cheat by submitting those
itself. And if Alice discovers that the CTF changed her vote, she has no way to
prove it. A similar protocol, which tries to correct these problems, is [<a href="Applied%20Cryptography_split_036.html#r1195" class="calibre5 pcalibre">1195</a>,<a href="Applied%20Cryptography_split_036.html#r1370" class="calibre5 pcalibre">1370</a>].</p>

<h4 class="calibre8">Voting with Two Central Facilities</h4>

<p class="calibre9">One solution is to divide the CTF in two. Neither party would have the power
to cheat on its own.</p>

<p class="calibre9">The following protocol uses a Central Legitimization Agency (CLA) to certify
voters and a separate CTF to count votes [<a href="Applied%20Cryptography_split_036.html#r1373" class="calibre5 pcalibre">1373</a>].</p>

<ol class="split">

<li class="pcalibre1 calibre30">Each voter sends a message to the CLA asking for a validation
number.
</li>
<li class="pcalibre1 calibre30">The CLA sends the voter back a random validation number. The
CLA maintains a list of validation numbers. The CLA also keeps a list
of the validation numbers’ recipients, in case someone tries to vote
twice.
</li>
<li class="pcalibre1 calibre30">The CLA sends the list of validation numbers to the CTF.
</li>
<li class="pcalibre1 calibre30">Each voter chooses a random identification number. He creates a
message with that number, the validation number he received from the
CLA, and his vote. He sends this message to the CTF.
</li>
<li class="pcalibre1 calibre30">The CTF checks the validation number against the list it received
from the CLA in step (3). If the validation number is there, the CTF
crosses it off (to prevent someone from voting twice). The CTF adds the
identification number to the list of people who voted for a particular
candidate and adds one to the tally.
</li>
<li class="pcalibre1 calibre30">After all votes have been received, the CTF publishes the outcome,
as well as the lists of identification numbers and for whom their owners
voted.
</li>

</ol>

<p class="calibre9">Like the previous protocol, each voter can look at the lists of identification
numbers and find his own. This gives him proof that his vote was counted. Of
course, all messages passing among the parties in the protocol should be
encrypted and signed to prevent someone from impersonating someone else or
intercepting transmissions.</p>

<p class="calibre9">The CTF cannot modify votes because each voter will look for his
identification string. If a voter doesn’t find his identification string, or finds his identification string in a tally other than the one he voted for, he will
immediately know there was foul play. The CTF cannot stuff the ballot box
because it is being watched by the CLA. The CLA knows how many voters
have been certified and their validation numbers, and will detect any
modifications.</p>

<p class="calibre9">Mallory, who is not an eligible voter, can try to cheat by guessing a valid
validation number. This threat can be minimized by making the number of
possible validation numbers much larger than the number of actual validation
numbers: 100-digit numbers for a million voters, for example. Of course, the
validation numbers must be generated randomly.</p>

<p class="calibre9">Despite this, the CLA is still a trusted authority in some respects. It can certify
ineligible voters. It can certify eligible voters multiple times. This risk could
be minimized by having the CLA publish a list of certified voters (but not their
validation numbers). If the number of voters on this list is less than the number
of votes tabulated, then something is awry. However, if more voters were
certified than votes tabulated, it probably means that some certified people
didn’t bother voting. Many people who are registered to vote don’t bother to
cast ballots.</p>

<p class="calibre9">This protocol is vulnerable to collusion between the CLA and the CTF. If the
two of them got together, they could correlate databases and figure out who
voted for whom.</p>

<h4 class="calibre8">Voting with a Single Central Facility</h4>

<p class="calibre9">A more complex protocol can be used to overcome the danger of collusion
between the CLA and the CTF [<a href="Applied%20Cryptography_split_036.html#r1373" class="calibre5 pcalibre">1373</a>]. This protocol is identical to the
previous one, with two modifications:</p>

<ul class="calibre13">

<li class="calibre14">The CLA and the CTF are one organization, and
</li>
<li class="calibre14">ANDOS (see <a href="Applied%20Cryptography_split_005.html#4.13" class="calibre5 pcalibre">Section 4.13</a>) is used to anonymously distribute
validation numbers in step (2).
</li>

</ul>

<p class="calibre9">Since the anonymous key distribution protocol prevents the CTF from
knowing which voter got which validation number, there is no way for the
CTF to correlate validation numbers with votes received. The CTF still has to
be trusted not to give validation numbers to ineligible voters, though. You can
also solve this problem with blind signatures.</p>

<h4 class="calibre8">Improved Voting with a Single Central Facility</h4>

<p class="calibre9">This protocol also uses ANDOS [<a href="Applied%20Cryptography_split_036.html#r1175" class="calibre5 pcalibre">1175</a>]. It satisfies all six requirements of a
good voting protocol. It doesn’t satisfy the seventh requirement, but has two
properties additional to the six listed at the beginning of the section:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">A voter can change his mind (i.e., retract his vote and vote again)
within a given period of time.
</li>
<li class="pcalibre1 calibre30"> If a voter finds out that his vote is miscounted, he can identify and
correct the problem without jeopardizing the secrecy of his ballot.
</li>

</ol>

<p class="calibre9">Here’s the protocol:</p>

<ol class="calibre17">

<li class="calibre14">The CTF publishes a list of all legitimate voters.
</li>
<li class="calibre14">Within a specified deadline, each voter tells the CTF whether he
intends to vote.
</li>
<li class="calibre14">The CTF publishes a list of voters participating in the election.
</li>
<li class="calibre14">Each voter receives an identification number, <i class="calibre12">I</i>, using an ANDOS
protocol.
</li>
<li class="calibre14">Each voter generates a public-key/private-key key pair: <i class="calibre12">k, d</i>. If <i class="calibre12">v</i> is the vote, he generates the following message and sends it to the CTF:
<p class="math"><i class="calibre12">I,E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v</i>)
</p>
This message must be sent anonymously.
</li>
<li class="calibre14">The CTF acknowledges receipt of the vote by publishing:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v</i>)
</p>
</li>
<li class="calibre14">Each voter sends the CTF:
<p class="math"><i class="calibre12">I,d</i>
</p>
</li>
<li class="calibre14">The CTF decrypts the votes. At the end of the election, it publishes
the results of the election and, for each different vote, the list of all
<i class="calibre12">E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v</i>) values that contained that vote.
</li>
<li class="calibre14">If a voter observes that his vote is not properly counted, he protests
by sending the CTF:
<p class="math"><i class="calibre12">I,E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v</i>) <i class="calibre12">,d</i>
</p>
</li>
<li class="calibre14">If a voter wants to change his vote (possible, in some elections)
from <i class="calibre12">v</i> to <i class="calibre12">v’, </i> he sends the CTF:
<p class="math"><i class="calibre12">I,E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v’</i>) <i class="calibre12">,d</i>
</p>
</li>

</ol>

<p class="calibre9">A different voting protocol uses blind signatures instead of ANDOS, but is
essentially the same [<a href="Applied%20Cryptography_split_035.html#r585" class="calibre5 pcalibre">585</a>]. Steps (1) through (3) are preliminary to the actual
voting. Their purpose is to find out and publicize the total number of actual
voters. Although some of them probably will not participate, it reduces the
ability of the CTF to add fraudulent votes.</p>

<p class="calibre9">In step (4), it is possible for two voters to get the same identification number.
This possibility can be minimized by having far more possible identification
numbers than actual voters. If two voters submit votes with the same
identification tag, the CTF generates a new identification number, <i class="calibre12">I’</i>, chooses one of the two votes, and publishes:</p>

<p class="math"><i class="calibre12">I’,E</i><sub class="calibre15">k</sub>(<i class="calibre12">I,v</i>)
</p>

<p class="calibre9">The owner of that vote recognizes it and sends in a second vote, by repeating
step (5), with the new identification number.</p>

<p class="calibre9">Step (6) gives each voter the capability to check that the CTF received his vote
accurately. If his vote is miscounted, he can prove his case in step (9).
Assuming a voter’s vote is correct in step (6), the message he sends in step (9)
constitutes a proof that his vote is miscounted.</p>

<p class="calibre9">One problem with the protocol is that a corrupt CTF could allocate the votes of
people who respond in step (2) but who do not actually vote. Another problem
is the complexity of the ANDOS protocol. The authors recommend dividing a
large population of voters into smaller populations, such as election districts.</p>

<p class="calibre9">Another, more serious problem is that the CTF can neglect to count a vote.
This problem cannot be resolved: Alice claims that the CTF intentionally
neglected to count her vote, but the CTF claims that the voter never voted.</p>

<h4 class="calibre8">Voting without a Central Tabulating Facility</h4>

<p class="calibre9">The following protocol does away with the CTF entirely; the voters watch
each other. Designed by Michael Merritt [<a href="Applied%20Cryptography_split_035.html#r452" class="calibre5 pcalibre">452</a>,<a href="Applied%20Cryptography_split_036.html#r1076" class="calibre5 pcalibre">1076</a>,<a href="Applied%20Cryptography_split_035.html#r453" class="calibre5 pcalibre">453</a>], it is so unwieldy
that it cannot be implemented practically for more than a handful of people,
but it is useful to learn from nevertheless.</p>

<p class="calibre9">Alice, Bob, Carol, and Dave are voting yes or no (0 or 1) on a particular issue.
Assume each voter has a public and private key. Also assume that everyone
knows everyone else’s public keys.</p>

<ol class="calibre17">

<li class="calibre14">Each voter chooses his vote and does the following:
<ol class="calibre43">

<li class="calibre14">He attaches a random string to his vote.
</li>
<li class="calibre14">He encrypts the result of step (a) with Dave’s public key.
</li>
<li class="calibre14">He encrypts the result of step (b) with Carol’s public key.
</li>
<li class="calibre14">He encrypts the result of step (c) with Bob’s public key.
</li>
<li class="calibre14">He encrypts the result of step (d) with Alice’s public key.
</li>
<li class="calibre14">He attaches a new random string to the result of step (e) and
encrypts it with Dave’s public key. He records the value of the
random string.
</li>
<li class="calibre14">He attaches a new random string to the result of step (f) and
encrypts it with Carol’s public key. He records the value of the
random string.
</li>
<li class="calibre14">He attaches a new random string to the result of step (g) and
encrypts it with Bob’s public key. He records the value of the
random string.
</li>
<li class="calibre14">He attaches a new random string to the result of step (h) and
encrypts it with Alice’s public key. He records the value of the
random string.
</li>

</ol>

If <i class="calibre12">E</i> is the encryption function, <i class="calibre12">R</i><sub class="calibre15">i</sub> is a random string, and <i class="calibre12">V</i> is the vote, his message looks like:
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">R</i><sub class="calibre15">5</sub>, <i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">R</i><sub class="calibre15">4</sub>, <i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">R</i><sub class="calibre15">3</sub>, <i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">R</i><sub class="calibre15">2</sub>, <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>))))))))
</p>
Each voter saves the intermediate results at each point in the
calculation. These results will be used later in the protocol to
confirm that his vote is among those being counted.
</li>
<li class="calibre14">Each voter sends his message to Alice.
</li>
<li class="calibre14">Alice decrypts all of the votes with her private key and then
removes all of the random strings at that level.
</li>
<li class="calibre14">Alice scrambles the order of all the votes and sends the result to
Bob.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">R</i><sub class="calibre15">4</sub>, <i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">R</i><sub class="calibre15">3</sub>, <i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">R</i><sub class="calibre15">2</sub>, <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>)))))))
</p>
</li>
<li class="calibre14">Bob decrypts all of the votes with his private key, checks to see that
his vote is among the set of votes, removes all the random strings at that
level, scrambles all the votes, and then sends the result to Carol.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">R</i><sub class="calibre15">3</sub>, <i class="calibre12">E</i><sub class="calibre15">D</sub> (<i class="calibre12">R</i><sub class="calibre15">2</sub>, <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>))))))
</p>
</li>
<li class="calibre14">Carol decrypts all of the votes with her private key, checks to see
that her vote is among the set of votes, removes all the random strings at
that level, scrambles all the votes, and then sends the result to Dave.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">R</i><sub class="calibre15">2</sub>, <i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>)))))
</p>
</li>
<li class="calibre14">Dave decrypts all of the votes with his private key, checks to see
that his vote is among the set of votes, removes all the random strings at
that level, scrambles all the votes, and sends them to Alice.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">E</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>))))
</p>
</li>
<li class="calibre14">Alice decrypts all the votes with her private key, checks to see that
her vote is among the set of votes, signs all the votes, and then sends the
result to Bob, Carol, and Dave.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">S</i><sub class="calibre15">A</sub>(<i class="calibre12">E</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>))))
</p>
</li>
<li class="calibre14">Bob verifies and deletes Alice’s signatures. He decrypts all the votes
with his private key, checks to see that his vote is among the set of
votes, signs all the votes, and then sends the result to Alice, Carol, and
Dave.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">S</i><sub class="calibre15">B</sub>(<i class="calibre12">E</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>)))
</p>
</li>
<li class="calibre14">Carol verifies and deletes Bob’s signatures. She decrypts all the
votes with her private key, checks to see that her vote is among the set
of votes, signs all the votes, and then sends the result to Alice, Bob, and
Dave.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">S</i><sub class="calibre15">C</sub>(<i class="calibre12">E</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>))
</p>
</li>
<li class="calibre14">Dave verifies and deletes Carol’s signatures. He decrypts all the
votes with his private key, checks to see that his vote is among the set of
votes, signs all the votes, and then sends the result to Alice, Bob, and
Carol.
<p class="calibre9">Each vote now looks like this:</p>
<p class="math"><i class="calibre12">S</i><sub class="calibre15">D</sub>(<i class="calibre12">V,R</i><sub class="calibre15">1</sub>)
</p>
</li>
<li class="calibre14">All verify and delete Dave’s signature. They check to make sure
that their vote is among the set of votes (by looking for their random
string among the votes).
</li>
<li class="calibre14">Everyone removes the random strings from each vote and tallies
the votes.
</li>

</ol>

<p class="calibre9">Not only does this protocol work, it is also self-adjudicating. Alice, Bob,
Carol, and Dave will immediately know if someone tries to cheat. No CTF or
CLA is required. To see how this works, let’s try to cheat.</p>

<p class="calibre9">If someone tries to stuff the ballot, Alice will detect the attempt in step (3)
when she receives more votes than people. If Alice tries to stuff the ballot, Bob
will notice in step (4).</p>

<p class="calibre9">More devious is to substitute one vote for another. Since the votes are
encrypted with various public keys, anyone can create as many valid votes as
needed. The decryption protocol has two rounds: round one consists of steps
(3) through (7), and round two consists of steps (8) through (11). Vote
substitution is detected differently in the different rounds.</p>

<p class="calibre9">If someone substitutes one vote for another in round two, his actions are
discovered immediately. At every step the votes are signed and sent to all the
voters. If one (or more) of the voters noticed that his vote is no longer in the
set of votes, he immediately stops the protocol. Because the votes are signed at
every step, and because everyone can backtrack through the second round of
the protocol, it is easy to detect who substituted the votes.</p>

<p class="calibre9">Substituting one vote for another during round one of the protocol is more
subtle. Alice can’t do it in step (3), because Bob, Carol, or Dave will detect it
in step (5), (6), or (7). Bob could try in step (5). If he replaces Carol’s or
Dave’s vote (remember, he doesn’t know which vote corresponds to which
voter), Carol or Dave will notice in step (6) or (7). They wouldn’t know who
tampered with their vote (although it would have had to be someone who had
already handled the votes), but they would know that their vote was tampered
with. If Bob is lucky and picks Alice’s vote to replace, she won’t notice until
the second round. Then, she will notice her vote missing in step (8). Still, she
would not know who tampered with her vote. In the first round, the votes are
shuffled from one step to the other and unsigned; it is impossible for anyone to
backtrack through the protocol to determine who tampered with the votes.</p>

<p class="calibre9">Another form of cheating is to try to figure out who voted for whom. Because
of the scrambling in the first round, it is impossible for someone to backtrack
through the protocol and link votes with voters. The removal of the random
strings during the first round is also crucial to preserving anonymity. If they
are not removed, the scrambling of the votes could be reversed by
re-encrypting the emerging votes with the scrambler’s public key. As the
protocol stands, the confidentiality of the votes is secure.</p>

<p class="calibre9">Even more strongly, because of the initial random string, <i class="calibre12">R</i><sub class="calibre15">1</sub>, even identical
votes are encrypted differently at every step of the protocol. No one knows the
outcome of the vote until step (11).</p>

<p class="calibre9">What are the problems with this protocol? First, the protocol has an enormous
amount of computation. The example described had only four voters and <i class="calibre12">it</i>
was complicated. This would never work in a real election, with tens of
thousands of voters. Second, Dave learns the results of the election before
anyone else does. While he still can’t affect the outcome, this gives him some
power that the others do not have. On the other hand, this is also true with
centralized voting schemes.</p>

<p class="calibre9">The third problem is that Alice can copy anyone else’s vote, even though she
does not know what it is beforehand. To see why this could be a problem,
consider a three-person election between Alice, Bob, and Eve. Eve doesn’t
care about the result of the election, but she wants to know how Alice voted.
So she copies Alice’s vote, and the result of the election is guaranteed to be
equal to Alice’s vote.</p>

<h4 class="calibre8">Other Voting Schemes</h4>

<p class="calibre9">Many complex secure election protocols have been proposed. They come in
two basic flavors. There are mixing protocols, like “Voting without a Central
Tabulating Facility, ” where everyone’s vote gets mixed up so that no one can
associate a vote with a voter.</p>

<p class="calibre9">There are also divided protocols, where individual votes are divided up among
different tabulating facilities such that no single one of them can cheat the
voters [<a href="Applied%20Cryptography_split_035.html#r360" class="calibre5 pcalibre">360</a>,<a href="Applied%20Cryptography_split_035.html#r359" class="calibre5 pcalibre">359</a>,<a href="Applied%20Cryptography_split_035.html#r118" class="calibre5 pcalibre">118</a>,<a href="Applied%20Cryptography_split_035.html#r115" class="calibre5 pcalibre">115</a>]. These protocols only protect the privacy of voters
to the extent that different “parts” of the government (or whoever is
administering the voting) do not conspire against the voter. (This idea of
breaking a central authority into different parts, who are only trusted when
together, comes from [<a href="Applied%20Cryptography_split_035.html#r316" class="calibre5 pcalibre">316</a>].)</p>

<p class="calibre9">One divided protocol is [<a href="Applied%20Cryptography_split_036.html#r1371" class="calibre5 pcalibre">1371</a>]. The basic idea is that each voter breaks his
vote into several shares. For example, if the vote were “yes” or “no, ” a 1
could indicate “yes” and a 0 could indicate “no”; the voter would then generate
several numbers whose sum was either 0 or 1. These shares are sent to
tabulating facilities, one to each, and are also encrypted and posted. Each
center tallies the shares it receives (there are protocols to verify that the tally is correct) and the final vote is the sum of all the tallies. There are also protocols
to ensure that each voter’s shares add up to 0 or 1.</p>

<p class="calibre9">Another protocol, by David Chaum [<a href="Applied%20Cryptography_split_035.html#r322" class="calibre5 pcalibre">322</a>], ensures that voters who attempt to
disrupt the election can be traced. However, the election must then be restarted
without the interfering voter; this approach is not practical for large-scale
elections.</p>

<p class="calibre9">Another, more complex, voting protocol that solves some of these problems
can be found in [<a href="Applied%20Cryptography_split_035.html#r770" class="calibre5 pcalibre">770</a>,<a href="Applied%20Cryptography_split_035.html#r771" class="calibre5 pcalibre">771</a>]. There is even a voting protocol that uses
multiple-key ciphers [<a href="Applied%20Cryptography_split_035.html#r219" class="calibre5 pcalibre">219</a>]. Yet another voting protocol, which claims to be
practical for large-scale elections, is in [<a href="Applied%20Cryptography_split_035.html#r585" class="calibre5 pcalibre">585</a>]. And [<a href="Applied%20Cryptography_split_035.html#r347" class="calibre5 pcalibre">347</a>] allows voters to
abstain.</p>

<p class="calibre9">Voting protocols work, but they make it easier to buy and sell votes. The
incentives become considerably stronger as the buyer can be sure that the
seller votes as promised. Some protocols are designed to be <b class="calibre10">receipt-free</b>, so
that it is impossible for a voter to prove to someone else that he voted in a
certain way [<a href="Applied%20Cryptography_split_035.html#r117" class="calibre5 pcalibre">117</a>,<a href="Applied%20Cryptography_split_036.html#r1170" class="calibre5 pcalibre">1170</a>,<a href="Applied%20Cryptography_split_036.html#r1372" class="calibre5 pcalibre">1372</a>].</p>

<h3 id="6.2" class="calibre7">6.2 Secure Multiparty Computation</h3>

<p class="calibre9"><b class="calibre10">Secure multiparty computation</b> is a protocol in which a group of people can
get together and compute any function of many variables in a special way.
Each participant in the group provides one or more variables. The result of the
function is known to everyone in the group, but no one learns anything about
the inputs of any other members other than what is obvious from the output of
the function. Here are some examples:</p>

<h4 class="calibre8">Protocol #1</h4>

<p class="calibre9">How can a group of people calculate their average salary without anyone
learning the salary of anyone else?</p>

<ol class="calibre17">

<li class="calibre14">Alice adds a secret random number to her salary, encrypts the result
with Bob’s public key, and sends it to Bob.
</li>
<li class="calibre14">Bob decrypts Alice’s result with his private key. He adds his salary
to what he received from Alice, encrypts the result with Carol’s public
key, and sends it to Carol.
</li>
<li class="calibre14">Carol decrypts Bob’s result with her private key. She adds her
salary to what she received from Bob, encrypts the result with Dave’s
public key, and sends it to Dave.
</li>
<li class="calibre14">Dave decrypts Carol’s result with his private key. He adds his salary
to what he received from Carol, encrypts the result with Alice’s public
key, and sends it to Alice.
</li>
<li class="calibre14">Alice decrypts Dave’s result with her private key. She subtracts the
random number from step (1) to recover the sum of everyone’s salaries.
</li>
<li class="calibre14">Alice divides the result by the number of people (four, in this case)
and announces the result.
</li>

</ol>

<p class="calibre9">This protocol assumes that everyone is honest; they may be curious, but they
follow the protocol. If any participant lies about his salary, the average will be
wrong. A more serious problem is that Alice can misrepresent the result to
everyone. She can subtract any number she likes in step (5), and no one would
be the wiser. Alice could be prevented from doing this by requiring her to
commit to her random number using any of the bit-commitment schemes from
<a href="Applied%20Cryptography_split_005.html#4.9" class="calibre5 pcalibre">Section 4.9</a>, but when she revealed her random number at the end of the
protocol Bob could learn her salary.</p>

<h4 class="calibre8">Protocol #2</h4>

<p class="calibre9">Alice and Bob are at a restaurant together, having an argument over who is
older. They don’t, however, want to tell the other their age. They could each
whisper their age into the ear of a trusted neutral party (the waiter, for
example), who could compare the numbers in his head and announce the result
to both Alice and Bob.</p>

<p class="calibre9">The above protocol has two problems. One, your average waiter doesn’t have
the computational ability to handle situations more complex than determining
which of two numbers is greater. And two, if Alice and Bob were really
concerned about the secrecy of their information, they would be forced to
drown the waiter in a bowl of vichyssoise, lest he tell the wine steward.</p>

<p class="calibre9">Public-key cryptography offers a far less violent solution. There is a protocol
by which Alice, who knows a value <i class="calibre12">a</i>, and Bob, who knows a value <i class="calibre12">b</i>, can together determine if <i class="calibre12">a</i> &lt; <i class="calibre12">b</i>, so that Alice gets no additional information about <i class="calibre12">b</i> and Bob gets no additional information about <i class="calibre12">a</i>. And, both Alice and Bob are convinced of the validity of the computation. Since the cryptographic
algorithm used is an essential part of the protocol, details can be found in
<a href="Applied%20Cryptography_split_026.html#23.14" class="calibre5 pcalibre">Section 23.14</a>.</p>

<p class="calibre9">Of course, this protocol doesn’t protect against active cheaters. There’s
nothing to stop Alice (or Bob, for that matter) from lying about her age. If Bob
were a computer program that blindly executed the protocol, Alice could learn
his age (is the age of a computer program the length of time since it was
written or the length of time since it started running?) by repeatedly executing
the protocol. Alice might give her age as 60. After learning that she is older,
she could execute the protocol again with her age as 30. After learning that
Bob is older, she could execute the protocol again with her age as 45, and so
on, until Alice discovers Bob’s age to any degree of accuracy she wishes.</p>

<p class="calibre9">Assuming that the participants don’t actively cheat, it is easy to extend this
protocol to multiple participants. Any number of people can find out the order
of their ages by a sequence of honest applications of the protocol; and no
participant can learn the age of another.</p>

<h4 class="calibre8">Protocol #3</h4>

<p class="calibre9">Alice likes to do kinky things with teddy bears. Bob has erotic fantasies about
marble tables. Both are pretty embarrassed by their particular fetish, but would
love to find a mate who shared in their...um...lifestyle.</p>

<p class="calibre9">Here at the Secure Multiparty Computation Dating Service, we’ve designed a
protocol for people like them. We’ve numbered an astonishing list of fetishes,
from “aardvarks” to “zoot suits.” Discreetly separated by a modem link, Alice
and Bob can participate in a secure multiparty protocol. Together, they can
determine whether they share the same fetish. If they do, they might look
forward to a lifetime of bliss together. If they don’t, they can part company
secure in the knowledge that their particular fetish remains confidential. No
one, not even the Secure Multiparty Computation Dating Service, will ever
know.</p>

<p class="calibre9">Here’s how it works:</p>

<ol class="calibre17">

<li class="calibre14">Using a one-way function, Alice hashes her fetish into a seven-digit
string.
</li>
<li class="calibre14">Alice uses the seven-digit string as a telephone number, calls the
number, and leaves a message for Bob. If no one answers or the number
is not in service, Alice applies a one-way function to the telephone
number until she finds someone who can play along with the protocol.
</li>
<li class="calibre14">Alice tells Bob how many times she had to apply the one-way hash
function to her fetish.
</li>
<li class="calibre14">Bob hashes his fetish the same number of times that Alice did. He
also uses the seven-digit string as a telephone number, and asks the
person at the other end whether there were any messages for him.
</li>

</ol>

<p class="calibre9">Note that Bob has a chosen-plaintext attack. He can hash common fetishes and
call the resulting telephone numbers, looking for messages for him. This
protocol only really works if there are enough possible plaintext messages for
this to be impractical.</p>

<p class="calibre9">There’s also a mathematical protocol, one similar to Protocol #2. Alice knows
 <i class="calibre12">a</i>, Bob knows <i class="calibre12">b</i>, and together they will determine whether <i class="calibre12">a</i> = <i class="calibre12">b</i>, such that Bob does not learn anything additional about <i class="calibre12">a</i> and Alice does not learn anything
additional about <i class="calibre12">b</i>. Details are in <a href="Applied%20Cryptography_split_026.html#23.14" class="calibre5 pcalibre">Section 23.14</a>.</p>

<h4 class="calibre8">Protocol #4</h4>

<p class="calibre9">This is another problem for secure multiparty computation [<a href="Applied%20Cryptography_split_036.html#r1373" class="calibre5 pcalibre">1373</a>]: A council
of seven meets regularly to cast secret ballots on certain issues. (All right, they
rule the world — don’t tell anyone I told you.) All council members can vote
yes or no. In addition, two parties have the option of casting “super votes”:
<i class="calibre12">S</i>-yes and <i class="calibre12">S</i>-no. They do not have to cast super votes; they can cast regular votes if they prefer. If no one casts any super votes, then the majority of votes
decides the issue. In the case of a single or two equivalent super votes, all
regular votes are ignored. In the case of two contradicting super votes, the
majority of regular votes decides. We want a protocol that securely performs
this style of voting.</p>

<p class="calibre9">Two examples should illustrate the voting process. Assume there are five
regular voters, N<sub class="calibre15">1</sub> through N<sub class="calibre15">5</sub>, and two super voters: S<sub class="calibre15">1</sub> and S<sub class="calibre15">2</sub>. Here’s the vote
on issue #1:</p>

<table class="vote">
<tbody class="calibre24"><tr class="calibre25"><td class="calibre44">S<sub class="calibre15">1</sub></td><td class="calibre45">S<sub class="calibre15">2</sub></td><td class="calibre45">N<sub class="calibre15">1</sub></td><td class="calibre45">N<sub class="calibre15">2</sub></td><td class="calibre45">N<sub class="calibre15">3</sub></td><td class="calibre45">N<sub class="calibre15">4</sub></td><td class="calibre45">N<sub class="calibre15">5</sub></td></tr>
<tr class="calibre25"><td class="calibre44">S-yes</td><td class="calibre45">no</td><td class="calibre45">no</td><td class="calibre45">no</td><td class="calibre45">no</td><td class="calibre45">yes</td><td class="calibre45">yes</td></tr>
</tbody></table>

<p class="calibre9">In this instance the only vote that matters is S<sub class="calibre15">1</sub>’s, and the result is “yes.”
Here is the vote on issue #2:</p>

<table class="vote">
<tbody class="calibre24"><tr class="calibre25"><td class="calibre44">S<sub class="calibre15">1</sub></td><td class="calibre45">S<sub class="calibre15">2</sub></td><td class="calibre45">N<sub class="calibre15">1</sub></td><td class="calibre45">N<sub class="calibre15">2</sub></td><td class="calibre45">N<sub class="calibre15">3</sub></td><td class="calibre45">N<sub class="calibre15">4</sub></td><td class="calibre45">N<sub class="calibre15">5</sub></td></tr>
<tr class="calibre25"><td class="calibre44">S-yes</td><td class="calibre45">S-no</td><td class="calibre45">no</td><td class="calibre45">no</td><td class="calibre45">no</td><td class="calibre45">yes</td><td class="calibre45">yes</td></tr>
</tbody></table>

<p class="calibre9">Here the two super votes cancel and the majority of regular “no” votes decide
the issue.</p>

<p class="calibre9">If it isn’t important to hide the knowledge of whether the super vote or the
regular vote was the deciding vote, this is an easy application of a secure
voting protocol. Hiding that knowledge requires a more complicated secure
multiparty computation protocol.</p>

<p class="calibre9">This kind of voting could occur in real life. It could be part of a corporation’s
organizational structure, where certain people have more power than others, or
it could be part of the United Nations’s procedures, where certain nations have
more power than others.</p>

<h4 class="calibre8">Multiparty Unconditionally Secure Protocols</h4>

<p class="calibre9">This is just a simple case of a general theorem: Any function of <i class="calibre12">n</i> inputs can be computed by a set of <i class="calibre12">n</i> players in a way that will let all learn the value of the function, but any set of less than <i class="calibre12">n</i>/2 players will not get any additional
information that does not follow from their own inputs and the value of the
output information. For details, see [<a href="Applied%20Cryptography_split_035.html#r136" class="calibre5 pcalibre">136</a>,<a href="Applied%20Cryptography_split_035.html#r334" class="calibre5 pcalibre">334</a>,<a href="Applied%20Cryptography_split_036.html#r1288" class="calibre5 pcalibre">1288</a>,<a href="Applied%20Cryptography_split_035.html#r621" class="calibre5 pcalibre">621</a>].</p>

<h4 class="calibre8">Secure Circuit Evaluation</h4>

<p class="calibre9">Alice has her input, <i class="calibre12">a</i>. Bob has his input, <i class="calibre12">b</i>. Together they wish to compute some general function, <i class="calibre12">f</i>(<i class="calibre12">a,b</i>), such that Alice learns nothing about Bob’s input and Bob learns nothing about Alice’s input. The general problem of secure
multiparty computation is also called <b class="calibre10">secure circuit evaluation</b>. Here, Alice
and Bob can create an arbitrary Boolean circuit. This circuit accepts inputs
from Alice and from Bob and produces an output. Secure circuit evaluation is
a protocol that accomplishes three things:</p>

<ol class="calibre17">

<li class="calibre14">Alice can enter her input without Bob’s being able to learn it.
</li>
<li class="calibre14">Bob can enter his input without Alice’s being able to learn it.
</li>
<li class="calibre14">Both Alice and Bob can calculate the output, with both parties being
sure the output is correct and that neither party has tampered with it.
</li>

</ol>

<p class="calibre9">Details on secure circuit evaluation can be found in [<a href="Applied%20Cryptography_split_036.html#r831" class="calibre5 pcalibre">831</a>].</p>

<h3 id="6.3" class="calibre7">6.3 Anonymous Message Broadcast</h3>

<p class="calibre9">You can’t go out to dinner with a bunch of cryptographers without raising a
ruckus. In [<a href="Applied%20Cryptography_split_035.html#r321" class="calibre5 pcalibre">321</a>], David Chaum introduced the Dining Cryptographers
Problem:</p>

<p class="quote">Three cryptographers are sitting down to dinner at their favorite
three-star restaurant. Their waiter informs them that arrangements
have been made with the maître d’hôtel for the bill to be paid
anonymously. One of the cryptographers might be paying for the
dinner, or it might have been the NSA. The three cryptographers
respect each other’s right to make an anonymous payment, but
they wonder if the NSA is paying.</p>

<p class="calibre9">How do the cryptographers, named Alice, Bob, and Carol, determine if one of
them is paying for dinner, while at the same time preserving the anonymity of
the payer?</p>

<p class="calibre9">Chaum goes on to solve the problem:</p>

<p class="quote">Each cryptographer flips an unbiased coin behind his menu,
between him and the cryptographer to his right, so that only the
two of them can see the outcome. Each cryptographer then states
aloud whether the two coins he can see — the one he flipped and
the one his left-hand neighbor flipped — fell on the same side or
on different sides. If one of the cryptographers is the payer, he
states the opposite of what he sees. An odd number of differences
uttered at the table indicates that a cryptographer is paying; an
even number of differences indicates that NSA is paying
(assuming that the dinner was paid for only once). Yet, if a
cryptographer is paying, neither of the other two learns anything
from the utterances about which cryptographer it is.</p>

<p class="calibre9">To see that this works, imagine Alice trying to figure out which other
cryptographer paid for dinner (assuming that neither she nor the NSA paid). If
she sees two different coins, then either both of the other cryptographers, Bob
and Carol, said, “same” or both said, “different.” (Remember, an odd number
of cryptographers saying “different” indicates that one of them paid.) If both
said, “different, ” then the payer is the cryptographer closest to the coin that is
the same as the hidden coin (the one that Bob and Carol flipped). If both said,
“same, ” then the payer is the cryptographer closest to the coin that is different
from the hidden coin. However, if Alice sees two coins that are the same, then
either Bob said, “same” and Carol said, “different, ” or Bob said, “different”
and Carol said, “same.” If the hidden coin is the same as the two coins she
sees, then the cryptographer who said, “different” is the payer. If the hidden
coin is different from the two coins she sees, then the cryptographer who said,
“same” is the payer. In all of these cases, Alice needs to know the result of the
coin flipped between Bob and Carol to determine which of them paid.</p>

<p class="calibre9">This protocol can be generalized to any number of cryptographers; they all sit
in a ring and flip coins among them. Even two cryptographers can perform the
protocol. Of course, they know who paid, but someone watching the protocol
could tell only if one of the two paid or if the NSA paid; they could not tell
which cryptographer paid.</p>

<p class="calibre9">The applications of this protocol go far beyond sitting around the dinner table.
This is an example of <b class="calibre10">unconditional sender and recipient untraceability</b>. A
group of users on a network can use this protocol to send anonymous
messages.</p>

<ol class="calibre17">

<li class="calibre14">The users arrange themselves into a circle.
</li>
<li class="calibre14">At regular intervals, adjacent pairs of users flip coins between them,
using some fair coin flip protocol secure from eavesdroppers.
</li>
<li class="calibre14">After every flip, each user announces either “same” or “different.”
</li>

</ol>

<p class="calibre9">If Alice wishes to broadcast a message, she simply starts inverting her
statement in those rounds corresponding to a 1 in the binary representation of
her message. For example, if her message were “1001, ” she would invert her
statement, tell the truth, tell the truth, and then invert her statement. Assuming
the result of her flips were “different, ” “same, ” “same, ” “same, ” she would
say “same, ” “same, ” “same, ” “different.”</p>

<p class="calibre9">If Alice notices that the overall outcome of the protocol doesn’t match the
message she is trying to send, she knows that someone else is trying to send a
message at the same time. She then stops sending the message and waits some
random number of rounds before trying again. The exact parameters have to be
worked out based on the amount of message traffic on this network, but the
idea should be clear.</p>

<p class="calibre9">To make things even more interesting, these messages can be encrypted in
another user’s public keys. Then, when everyone receives the message (a real
implementation of this should add some kind of standard message-beginning
and message-ending strings), only the intended recipient can decrypt and read
it. No one else knows who sent it. No one else knows who could read it.
Traffic analysis, which traces and compiles patterns of people’s
communications even though the messages themselves may be encrypted, is
useless.</p>

<p class="calibre9">An alternative to flipping coins between adjacent parties would be for them to
keep a common file of random bits. Maybe they could keep them on a
CD-ROM, or one member of the pair could generate a pile of them and send
them to the other party (encrypted, of course). Alternatively, they could agree
on a cryptographically secure pseudo-random-number generator between
them, and they could each generate the same string of pseudo-random bits for
the protocol.</p>

<p class="calibre9">One problem with this protocol is that while a malicious participant cannot
read any messages, he can disrupt the system unobserved by lying in step (3).
There is a modification to the previous protocol that detects disruption [<a href="Applied%20Cryptography_split_036.html#r1578" class="calibre5 pcalibre">1578</a>,<a href="Applied%20Cryptography_split_036.html#r1242" class="calibre5 pcalibre">1242</a>]; 
the problem is called “The Dining Cryptographers in the Disco.”</p>

<h3 id="6.4" class="calibre7">6.4 Digital Cash</h3>

<p class="calibre9">Cash is a problem. It’s annoying to carry, it spreads germs, and people can
steal it from you. Checks and credit cards have reduced the amount of physical
cash flowing through society, but the complete elimination of cash is virtually
impossible. It’ll never happen; drug dealers and politicians would never stand
for it. Checks and credit cards have an audit trail; you can’t hide to whom you
gave money.</p>

<p class="calibre9">On the other hand, checks and credit cards allow people to invade your privacy
to a degree never before imagined. You might never stand for the police
following you your entire life, but the police can watch your financial
transactions. They can see where you buy your gas, where you buy your food,
who you call on the telephone — all without leaving their computer terminals.
People need a way to protect their anonymity in order to protect their privacy.</p>

<p class="calibre9">Happily, there is a complicated protocol that allows for authenticated but
untraceable messages. Lobbyist Alice can transfer <b class="calibre10">digital cash</b> to
Congresscritter Bob so that newspaper reporter Eve does not know Alice’s
identity. Bob can then deposit that electronic money into his bank account,
even though the bank has no idea who Alice is. But if Alice tries to buy
cocaine with the same piece of digital cash she used to bribe Bob, she will be
detected by the bank. And if Bob tries to deposit the same piece of digital cash
into two different accounts, he will be detected — but Alice will remain
anonymous. Sometimes this is called <b class="calibre10">anonymous digital cash</b> to differentiate
it from digital money with an audit trail, such as credit cards.</p>

<p class="calibre9">A great social need exists for this kind of thing. With the growing use of the
Internet for commercial transactions, there is more call for network-based
privacy and anonymity in business. (There are good reasons people are
reluctant to send their credit card numbers over the Internet.) On the other
hand, banks and governments seem unwilling to give up the control that the
current banking system’s audit trail provides. They’ll have to, though. All it
will take for digital cash to catch on is for some trustworthy institution to be
willing to convert the digits to real money.</p>

<p class="calibre9">Digital cash protocols are very complex. We’ll build up to one, a step at a
time. For more formal details, read [<a href="Applied%20Cryptography_split_035.html#r318" class="calibre5 pcalibre">318</a>,<a href="Applied%20Cryptography_split_035.html#r339" class="calibre5 pcalibre">339</a>,<a href="Applied%20Cryptography_split_035.html#r325" class="calibre5 pcalibre">325</a>,<a href="Applied%20Cryptography_split_035.html#r335" class="calibre5 pcalibre">335</a>,<a href="Applied%20Cryptography_split_035.html#r340" class="calibre5 pcalibre">340</a>]. Realize that this
is just one digital cash protocol; there are others.</p>

<h4 class="calibre8">Protocol #1</h4>

<p class="calibre9">The first few protocols are physical analogies of cryptographic protocols. This
first protocol is a simplified physical protocol for anonymous money orders:</p>

<ol class="calibre17">

<li class="calibre14">Alice prepares 100 anonymous money orders for $1000 each.
</li>
<li class="calibre14">Alice puts one each, and a piece of carbon paper, into 100 different
envelopes. She gives them all to the bank.
</li>
<li class="calibre14">The bank opens 99 envelopes and confirms that each is a money
order for $1000.
</li>
<li class="calibre14">The bank signs the one remaining unopened envelope. The
signature goes through the carbon paper to the money order. The bank
hands the unopened envelope back to Alice, and deducts $1000 from her
account.
</li>
<li class="calibre14">Alice opens the envelope and spends the money order with a
merchant.
</li>
<li class="calibre14">The merchant checks for the bank’s signature to make sure the
money order is legitimate.
</li>
<li class="calibre14">The merchant takes the money order to the bank.
</li>
<li class="calibre14">The bank verifies its signature and credits $1000 to the merchant’s
account.
</li>

</ol>

<p class="calibre9">This protocol works. The bank never sees the money order it signed, so when
the merchant brings it to the bank, the bank has no idea that it was Alice’s. The
bank is convinced that it is valid, though, because of the signature. The bank is
confident that the unopened money order is for $1000 (and not for $100,000
or $100,000,000) because of the cut-and-choose protocol (see <a href="Applied%20Cryptography_split_006.html#5.1" class="calibre5 pcalibre">Section 5.1</a>). It
verifies the other 99 envelopes, so Alice has only a 1 percent chance of
cheating the bank. Of course, the bank will make the penalty for cheating great
enough so that it isn’t worth that chance. If the bank refuses to sign the last
check (if Alice is caught cheating) without penalizing Alice, she will continue
to try until she gets lucky. Prison terms are a better deterrent.</p>

<h4 class="calibre8">Protocol #2</h4>

<p class="calibre9">The previous protocol prevents Alice from writing a money order for more
than she claims to, but it doesn’t prevent Alice from photocopying the money
order and spending it twice. This is called the <b class="calibre10">double spending problem</b>; to
solve it, we need a complication:</p>

<ol class="calibre17">

<li class="calibre14">Alice prepares 100 anonymous money orders for $1000 each. On
each money order she includes a different random uniqueness string,
one long enough to make the chance of another person also using it
negligible.
</li>
<li class="calibre14">Alice puts one each, and a piece of carbon paper, into 100 different
envelopes. She gives them all to the bank.
</li>
<li class="calibre14">The bank opens 99 envelopes and confirms that each is a money
order for $1000.
</li>
<li class="calibre14">The bank signs the one remaining unopened envelope. The
signature goes through the carbon paper to the money order. The bank
hands the unopened envelope back to Alice and deducts $1000 from her
account.
</li>
<li class="calibre14">Alice opens the envelope and spends the money order with a
merchant.
</li>
<li class="calibre14">The merchant checks for the bank’s signature to make sure the
money order is legitimate.
</li>
<li class="calibre14">The merchant takes the money order to the bank.
</li>
<li class="calibre14">The bank verifies its signature and checks its database to make sure
a money order with the same uniqueness string has not been previously
deposited. If it hasn’t, the bank credits $1000 to the merchant’s account.
The bank records the uniqueness string in a database.
</li>
<li class="calibre14">If it has been previously deposited, the bank doesn’t accept the
money order.
</li>

</ol>

<p class="calibre9">Now, if Alice tries to spend a photocopy of the money order, or if the
merchant tries to deposit a photocopy of the money order, the bank will know
about it.</p>

<h4 class="calibre8">Protocol #3</h4>

<p class="calibre9">The previous protocol protects the bank from cheaters, but it doesn’t identify
them. The bank doesn’t know if the person who bought the money order (the
bank has no idea it’s Alice) tried to cheat the merchant or if the merchant tried
to cheat the bank. This protocol corrects that:</p>

<ol class="calibre17">

<li class="calibre14">Alice prepares 100 anonymous money orders for $1000 each. On
each of the money orders she includes a different random uniqueness
string, one long enough to make the chance of another person also using
it negligible.
</li>
<li class="calibre14">Alice puts one each, and a piece of carbon paper, into 100 different
envelopes. She gives them all to the bank.
</li>
<li class="calibre14">The bank opens 99 envelopes and confirms that each is a money
order for $1000 and that all the random strings are different.
</li>
<li class="calibre14">The bank signs the one remaining unopened envelope. The
signature goes through the carbon paper to the money order. The bank
hands the unopened envelope back to Alice and deducts $1000 from her
account.
</li>
<li class="calibre14">Alice opens the envelope and spends the money order with a
merchant.
</li>
<li class="calibre14">The merchant checks for the bank’s signature to make sure the
money order is legitimate.
</li>
<li class="calibre14">The merchant asks Alice to write a random identity string on the
money order.
</li>
<li class="calibre14">Alice complies.
</li>
<li class="calibre14">The merchant takes the money order to the bank.
</li>
<li class="calibre14">The bank verifies the signature and checks its database to make
sure a money order with the same uniqueness string has not been
previously deposited. If it hasn’t, the bank credits $1000 to the
merchant’s account. The bank records the uniqueness string and the
identity string in a database.
</li>
<li class="calibre14">If the uniqueness string is in the database, the bank refuses to
accept the money order. Then, it compares the identity string on the
money order with the one stored in the database. If it is the same, the
bank knows that the merchant photocopied the money order. If it is
different, the bank knows that the person who bought the money order
photocopied it.
</li>

</ol>

<p class="calibre9">This protocol assumes that the merchant cannot change the identity string once
Alice writes it on the money order. The money order might have a series of
little squares, which the merchant would require Alice to fill in with either Xs
or Os. The money order might be made out of paper that tears if erased.</p>

<p class="calibre9">Since the interaction between the merchant and the bank takes place after
Alice spends the money, the merchant could be stuck with a bad money order.
Practical implementations of this protocol might require Alice to wait near the
cash register during the merchant-bank interaction, much the same way as
credit-card purchases are handled today.</p>

<p class="calibre9">Alice could also frame the merchant. She could spend a copy of the money
order a second time, giving the same identity string in step (7). Unless the
merchant keeps a database of money orders it already received, he would be
fooled. The next protocol eliminates that problem.</p>

<h4 class="calibre8">Protocol #4</h4>

<p class="calibre9">If it turns out that the person who bought the money order tried to cheat the
merchant, the bank would want to know who that person was. To do that
requires moving away from a physical analogy and into the world of
cryptography.</p>

<p class="calibre9">The technique of secret splitting can be used to hide Alice’s name in the digital
money order.</p>

<ol class="calibre17">

<li class="calibre14">Alice prepares <i class="calibre12">n</i> anonymous money orders for a given amount.
Each of the money orders contains a different random uniqueness string,
 <i class="calibre12">X</i>, one long enough to make the chance of two being identical
negligible.
On each money order, there are also <i class="calibre12">n</i> pairs of identity bit strings, <i class="calibre12">I</i><sub class="calibre15">1</sub>, <i class="calibre12">I</i><sub class="calibre15">2</sub>, ..., <i class="calibre12">I</i><sub class="calibre15">n</sub>. (Yes, that’s <i class="calibre12">n</i> different pairs on <i class="calibre12">each</i> check.) Each of these pairs
is generated as follows: Alice creates a string that gives her name,
address, and any other piece of identifying information that the bank
wants to see. Then, she splits it into two pieces using the secret splitting
protocol (see <a href="Applied%20Cryptography_split_004.html#3.6" class="calibre5 pcalibre">Section 3.6</a>). Then, she commits to each piece using a
bit-commitment protocol.
For example, <i class="calibre12">I</i><sub class="calibre15">37</sub> consists of two parts: <i class="calibre12">I</i><sub class="calibre15">37<sub class="calibre16">L</sub></sub> and <i class="calibre12">I</i><sub class="calibre15">37<sub class="calibre16">R</sub></sub>. Each part is a bit-committed packet that Alice can be asked to open and whose proper
opening can be instantly verified. Any pair (e.g., <i class="calibre12">I</i><sub class="calibre15">37<sub class="calibre16">L</sub></sub> and <i class="calibre12">I</i><sub class="calibre15">37<sub class="calibre16">R</sub></sub>, but not <i class="calibre12">I</i><sub class="calibre15">37<sub class="calibre16">L</sub></sub> and <i class="calibre12">I</i><sub class="calibre15">38<sub class="calibre16">R</sub></sub>), reveals Alice’s identity.
Each of the money orders looks like this:
<pre class="calibre20">Amount
Uniqueness String: <i class="calibre22">X</i>
Identity Strings:  <i class="calibre22">I</i><sub class="calibre15">1</sub> = (<i class="calibre22">I</i><sub class="calibre15">1<sub class="calibre46">L</sub></sub>, <i class="calibre22">I</i><sub class="calibre15">1<sub class="calibre46">R</sub></sub>)
                   <i class="calibre22">I</i><sub class="calibre15">2</sub> = (<i class="calibre22">I</i><sub class="calibre15">2<sub class="calibre46">L</sub></sub>, <i class="calibre22">I</i><sub class="calibre15">2<sub class="calibre46">R</sub></sub>)
                     ....
                   <i class="calibre22">I</i><sub class="calibre15">n</sub> = (<i class="calibre22">I</i><sub class="calibre15">n<sub class="calibre46">L</sub></sub>, <i class="calibre22">I</i><sub class="calibre15">n<sub class="calibre46">R</sub></sub>)
</pre>
</li>
<li class="calibre14">Alice blinds all <i class="calibre12">n</i> money orders, using a blind signature protocol.
She gives them all to the bank.
</li>
<li class="calibre14">The bank asks Alice to unblind <i class="calibre12">n</i> - 1 of the money orders at random and confirms that they are all well formed. The bank checks the amount,
the uniqueness string, and asks Alice to reveal all of the identity strings.
</li>
<li class="calibre14">If the bank is satisfied that Alice did not make any attempts to cheat,
it signs the one remaining blinded money order. The bank hands the
blinded money order back to Alice and deducts the amount from her
account.
</li>
<li class="calibre14">Alice unblinds the money order and spends it with a merchant.
</li>
<li class="calibre14">The merchant verifies the bank’s signature to make sure the money
order is legitimate.
</li>
<li class="calibre14">The merchant asks Alice to randomly reveal either the left half or
the right half of each identity string on the money order. In effect, the
merchant gives Alice a random <i class="calibre12">n-</i>bit <b class="calibre10">selector string</b>, <i class="calibre12">b</i><sub class="calibre15">1</sub>, <i class="calibre12">b</i><sub class="calibre15">2</sub>,..., <i class="calibre12">b</i><sub class="calibre15">n</sub>. Alice opens either the left or right half of <i class="calibre12">I</i><sub class="calibre15">i</sub>, depending on whether <i class="calibre12">b</i><sub class="calibre15">i</sub> is a 0 or a 1.
</li>
<li class="calibre14">Alice complies.
</li>
<li class="calibre14">The merchant takes the money order to the bank.
</li>
<li class="calibre14">The bank verifies the signature and checks its database to make
sure a money order with the same uniqueness string has not been
previously deposited. If it hasn’t, the bank credits the amount to the
merchant’s account. The bank records the uniqueness string and all of
the identity information in a database.
</li>
<li class="calibre14">If the uniqueness string is in the database, the bank refuses to
accept the money order. Then, it compares the identity string on the
money order with the one stored in the database. If it is the same, the
bank knows that the merchant copied the money order. If it is different,
the bank knows that the person who bought the money order
photocopied it. Since the second merchant who accepted the money
order handed Alice a different selector string than did the first merchant,
the bank finds a bit position where one merchant had Alice open the left
half and the other merchant had Alice open the right half. The bank
XORs the two halves together to reveal Alice’s identity.
</li>

</ol>

<p class="calibre9">This is quite an amazing protocol, so let’s look at it from various angles.</p>

<p class="calibre9">Can Alice cheat? Her digital money order is nothing more than a string of bits,
so she can copy it. Spending it the first time won’t be a problem; she’ll just
complete the protocol and everything will go smoothly. The merchant will
give her a random <i class="calibre12">n</i>-bit selector string in step (7) and Alice will open either the left half or right half of each <i class="calibre12">I</i><sub class="calibre15">i</sub> in step (8). In step (10), the bank will record all of this data, as well as the money order’s uniqueness string.</p>

<p class="calibre9">When she tries to use the same digital money order a second time, the
merchant (either the same merchant or a different merchant) will give her a
different random selector string in step (7). Alice must comply in step (8); not
doing so will immediately alert the merchant that something is suspicious.
Now, when the merchant brings the money order to the bank in step (10), the
bank would immediately notice that a money order with the same uniqueness
string was already deposited. The bank then compares the opened halves of the
identity strings. The odds that the two random selector strings are the same is 1
in 2<sup class="calibre19"><i class="calibre22">n</i></sup>; it isn’t likely to happen before the next ice age. Now, the bank finds a pair with one half opened the first time and the other half opened the second
time. It XORs the two halves together, and out pops Alice’s name. The bank
knows who tried to spend the money order twice.</p>

<p class="calibre9">Note that this protocol doesn’t keep Alice from trying to cheat; it detects her
cheating with almost certainty. Alice can’t prevent her identity from being
revealed if she cheats. She can’t change either the uniqueness string or any of
the identity strings, because then the bank’s signature will no longer be valid.
The merchant will immediately notice that in step (6).</p>

<p class="calibre9">Alice could try to sneak a bad money order past the bank, one on which the
identity strings don’t reveal her name; or better yet, one whose identity strings
reveal someone else’s name. The odds of her getting this ruse past the bank in
step (3) are 1 in <i class="calibre12">n</i> . These aren’t impossible odds, but if you make the penalty severe enough, Alice won’t try it. Or, you could increase the number of
redundant money orders that Alice makes in step (1).</p>

<p class="calibre9">Can the merchant cheat? His chances are even worse. He can’t deposit the
money order twice; the bank will notice the repeated use of the selector string.
He can’t fake blaming Alice; only she can open any of the identity strings.</p>

<p class="calibre9">Even collusion between Alice and the merchant can’t cheat the bank. As long
as the bank signs the money order with the uniqueness string, the bank is
assured of only having to make good on the money order once.</p>

<p class="calibre9">What about the bank? Can it figure out that the money order it accepted from
the merchant was the one it signed for Alice? Alice is protected by the blind
signature protocol in steps (2) through (5). The bank cannot make the
connection, even if it keeps complete records of every transaction. Even more
strongly, there is no way for the bank and the merchant to get together to
figure out who Alice is. Alice can walk in the store and, completely
anonymously, make her purchase.</p>

<p class="calibre9">Eve can cheat. If she can eavesdrop on the communication between Alice and
the merchant, and if she can get to the bank before the merchant does, she can
deposit the digital cash first. The bank will accept it and, even worse, when the
merchant tries to deposit the cash he will be identified as a cheater. If Eve
steals and spends Alice’s cash before Alice can, then Alice will be identified as
a cheater. There’s no way to prevent this; it is a direct result of the
anonynimity of the cash. Both Alice and the merchant have to protect their bits
as they would paper money.</p>

<p class="calibre9">This protocol lies somewhere between an arbitrated protocol and a
self-enforcing protocol. Both Alice and the merchant trust the bank to make
good on the money orders, but Alice does not have to trust the bank with
knowledge of her purchases.</p>

<h4 class="calibre8">Digital Cash and the Perfect Crime</h4>

<p class="calibre9">Digital cash has its dark side, too. Sometimes people don’t want so much
privacy. Watch Alice commit the perfect crime [<a href="Applied%20Cryptography_split_036.html#r1575" class="calibre5 pcalibre">1575</a>]:</p>

<ol class="calibre17">

<li class="calibre14">Alice kidnaps a baby.
</li>
<li class="calibre14">Alice prepares 10,000 anonymous money orders for $1000 (or as
many as she wants for whatever denomination she wants).
</li>
<li class="calibre14">Alice blinds all 10,000 money orders, using a blind signature
protocol. She sends them to the authorities with the threat to kill the
baby unless the following instructions are met:
<ol class="calibre43">

<li class="calibre14">Have a bank sign all 10,000 money orders.
</li>
<li class="calibre14">Publish the results in a newspaper.
</li>

</ol>

</li>
<li class="calibre14">The authorities comply.
</li>
<li class="calibre14">Alice buys a newspaper, unblinds the money orders, and starts
spending them. There is no way for the authorities to trace the money
orders to her.
</li>
<li class="calibre14">Alice frees the baby.
</li>

</ol>

<p class="calibre9">Note that this situation is much worse than any involving physical
tokens — cash, for example. Without physical contact, the police have less
opportunity to apprehend the kidnapper.</p>

<p class="calibre9">In general, though, digital cash isn’t a good deal for criminals. The problem is
that the anonymity only works one way: The spender is anonymous, but the
merchant is not. Moreover, the merchant cannot hide the fact that he received
money. Digital cash will make it easy for the government to determine how
much money you made, but impossible to determine what you spent it on.</p>

<h4 class="calibre8">Practical Digital Cash</h4>

<p class="calibre9">A Dutch company, DigiCash, owns most of the digital cash patents and has
implemented digital cash protocols in working products. Anyone interested
should contact DigiCash BV, Kruislaan 419, 1098 VA Amsterdam,
Netherlands.</p>

<h4 class="calibre8">Other Digital Cash Protocols</h4>

<p class="calibre9">There are other digital cash protocols; see [<a href="Applied%20Cryptography_split_035.html#r707" class="calibre5 pcalibre">707</a>,<a href="Applied%20Cryptography_split_036.html#r1554" class="calibre5 pcalibre">1554</a>,<a href="Applied%20Cryptography_split_035.html#r734" class="calibre5 pcalibre">734</a>,<a href="Applied%20Cryptography_split_036.html#r1633" class="calibre5 pcalibre">1633</a>,<a href="Applied%20Cryptography_split_036.html#r973" class="calibre5 pcalibre">973</a>]. Some
of them involve some pretty complicated mathematics. Generally, the various
digital cash protocols can be divided into various categories. <b class="calibre10">On-line</b> systems
require the merchant to communicate with the bank at every sale, much like
today’s credit-card protocols. If there is a problem, the bank doesn’t accept the
cash and Alice cannot cheat.</p>

<p class="calibre9"><b class="calibre10">Off-line</b> systems, like Protocol #4, require no communication between the
merchant and the bank until after the transaction between the merchant and the
customer. These systems do not prevent Alice from cheating, but instead
detect her cheating. Protocol #4 detected her cheating by making Alice’s
identity known if she tried to cheat. Alice knows that this will happen, so she
doesn’t cheat.</p>

<p class="calibre9">Another way is to create a special smart card (see <a href="Applied%20Cryptography_split_028.html#24.13" class="calibre5 pcalibre">Section 24.13</a>) containing a
tamperproof chip called an <b class="calibre10">observer</b> [<a href="Applied%20Cryptography_split_035.html#r332" class="calibre5 pcalibre">332</a>,<a href="Applied%20Cryptography_split_035.html#r341" class="calibre5 pcalibre">341</a>,<a href="Applied%20Cryptography_split_035.html#r387" class="calibre5 pcalibre">387</a>]. The observer chip keeps
a mini database of all the pieces of digital cash spent by that smart card. If
Alice attempts to copy some digital cash and spend it twice, the imbedded
observer chip would detect the attempt and would not allow the transaction.
Since the observer chip is tamperproof, Alice cannot erase the mini-database
without permanently damaging the smart card. The cash can wend its way
through the economy; when it is finally deposited, the bank can examine the
cash and determine who, if anyone, cheated.</p>

<p class="calibre9">Digital cash protocols can also be divided along another line. <b class="calibre10">Electronic coins</b>
have a fixed value; people using this system will need several coins in
different denominations. <b class="calibre10">Electronic checks</b> can be used for any amount up to
a maximum value and then returned for a refund of the unspent portion.</p>

<p class="calibre9">Two excellent and completely different off-line electronic coin protocols are
[<a href="Applied%20Cryptography_split_035.html#r225" class="calibre5 pcalibre">225</a>,<a href="Applied%20Cryptography_split_035.html#r226" class="calibre5 pcalibre">226</a>,<a href="Applied%20Cryptography_split_035.html#r227" class="calibre5 pcalibre">227</a>] and [<a href="Applied%20Cryptography_split_035.html#r563" class="calibre5 pcalibre">563</a>,<a href="Applied%20Cryptography_split_035.html#r564" class="calibre5 pcalibre">564</a>,<a href="Applied%20Cryptography_split_035.html#r565" class="calibre5 pcalibre">565</a>]. A system called NetCash, with weaker
anonymity properties, has also been proposed [<a href="Applied%20Cryptography_split_036.html#r1048" class="calibre5 pcalibre">1048</a>,<a href="Applied%20Cryptography_split_036.html#r1049" class="calibre5 pcalibre">1049</a>]. Another new
system is [<a href="Applied%20Cryptography_split_035.html#r289" class="calibre5 pcalibre">289</a>].</p>

<p class="calibre9">In [<a href="Applied%20Cryptography_split_036.html#r1211" class="calibre5 pcalibre">1211</a>], Tatsuaki Okamoto and Kazuo Ohta list six properties of an ideal
digital cash system:</p>

<ol class="calibre17">

<li class="calibre14">Independence. The security of the digital cash is not dependent on
any physical location. The cash can be transferred through computer
networks.
</li>
<li class="calibre14">Security. The digital cash cannot be copied and reused.
</li>
<li class="calibre14">Privacy (Untraceability). The privacy of the user is protected; no one
can trace the relationship between the user and his purchases.
</li>
<li class="calibre14">Off-line Payment. When a user pays for a purchase with electronic
cash, the protocol between the user and the merchant is executed
off-line. That is, the shop does not need to be linked to a host to process
the user’s payment.
</li>
<li class="calibre14">Transferability. The digital cash can be transferred to other users.
</li>
<li class="calibre14">Divisibility. A piece of digital cash in a given amount can be
subdivided into smaller pieces of cash in smaller amounts. (Of course,
everything has to total up properly in the end.)
</li>

</ol>

<p class="calibre9">The protocols previously discussed satisfy properties 1, 2, 3, and 4, but not 5
and 6. Some on-line digital cash systems satisfy all properties except 4 [<a href="Applied%20Cryptography_split_035.html#r318" class="calibre5 pcalibre">318</a>,<a href="Applied%20Cryptography_split_035.html#r413" class="calibre5 pcalibre">413</a>,<a href="Applied%20Cryptography_split_036.html#r1243" class="calibre5 pcalibre">1243</a>]. 
The first off-line digital cash system that satisfies properties 1, 2,
3, and 4, similar to the one just discussed, was proposed in [<a href="Applied%20Cryptography_split_035.html#r339" class="calibre5 pcalibre">339</a>]. Okamoto
and Ohta proposed a system that satisfies properties 1 through 5 [<a href="Applied%20Cryptography_split_036.html#r1209" class="calibre5 pcalibre">1209</a>]; they
also proposed a system that satisfies properties 1 through 6 as well, but the
data requirement for a single purchase is approximately 200 megabytes.
Another off-line divisible coin system is described in [<a href="Applied%20Cryptography_split_035.html#r522" class="calibre5 pcalibre">522</a>].</p>

<p class="calibre9">The digital cash scheme proposed in [<a href="Applied%20Cryptography_split_036.html#r1211" class="calibre5 pcalibre">1211</a>], by the same authors, satisfies
properties 1 through 6, without the enormous data requirements. The total data
transfer for a payment is about 20 kilobytes, and the protocol can be completed
in several seconds. The authors consider this the first ideal untraceable
electronic cash system.</p>

<h4 class="calibre8">Anonymous Credit Cards</h4>

<p class="calibre9">This protocol [<a href="Applied%20Cryptography_split_036.html#r988" class="calibre5 pcalibre">988</a>] uses several different banks to protect the identity of the
customer. Each customer has an account at two different banks. The first bank
knows the person’s identity and is willing to extend him credit. The second
bank knows the customer only under a pseudonym (similar to a numbered
Swiss bank account).</p>

<p class="calibre9">The customer can withdraw funds from the second bank by proving that the
account is his. However, the bank does not know the person and is unwilling to
extend him credit. The first bank knows the customer and transfers funds to the
second bank — without knowing the pseudonym. The customer then spends
these funds anonymously. At the end of the month, the second bank gives the
first bank a bill, which it trusts the bank to pay. The first bank passes the bill
on to the customer, which it trusts the customer to pay. When the customer
pays, the first bank transfers additional funds to the second bank. All
transactions are handled through an intermediary, which acts sort of like an
electronic Federal Reserve: settling accounts among banks, logging messages,
and creating an audit trail.</p>

<p class="calibre9">Exchanges between the customer, merchant, and various banks are outlined in
[<a href="Applied%20Cryptography_split_036.html#r988" class="calibre5 pcalibre">988</a>]. Unless everyone colludes against the customer, his anonymity is
assured. However, this is not digital cash; it is easy for the bank to cheat. The
protocol allows customers to keep the advantages of credit cards without
giving up their privacy.</p>

<div class="calibre6" id="calibre_pb_14"></div>
</div>






</body></html>
