<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="1">Chapter 1 <br class="calibre3"/>
Foundations</h1>

<h3 id="1.1" class="calibre7">1.1 Terminology</h3>

<h4 class="calibre8">Sender and Receiver</h4>

<p class="calibre9">Suppose a sender wants to send a message to a receiver. Moreover, this sender
wants to send the message securely: She wants to make sure an eavesdropper
cannot read the message.</p>

<h4 class="calibre8">Messages and Encryption</h4>

<p class="calibre9">A message is <b class="calibre10">plaintext</b> (sometimes called cleartext). The process of disguising
a message in such a way as to hide its substance is <b class="calibre10">encryption</b>. An encrypted
message is <b class="calibre10">ciphertext</b>. The process of turning ciphertext back into plaintext is <b class="calibre10">decryption</b>. This is all shown in Figure 1.1.</p>

<div class="figure" id="figure-1-1">
<p class="image"><img src="ac-figure-1-1.png" class="calibre11"/></p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 1.1</b> Encryption and Decryption.</i></p>
</div>

<p class="calibre9">(If you want to follow the ISO 7498-2 standard, use the terms “encipher” and
“decipher.” It seems that some cultures find the terms “encrypt” and “decrypt”
offensive, as they refer to dead bodies.)</p>

<p class="calibre9">The art and science of keeping messages secure is <b class="calibre10">cryptography</b>, and it is
practiced by <b class="calibre10">cryptographers</b>. <b class="calibre10">Cryptanalysts</b> are practitioners of
<b class="calibre10">cryptanalysis</b>, the art and science of breaking ciphertext; that is, seeing
through the disguise. The branch of mathematics encompassing both
cryptography and cryptanalysis is <b class="calibre10">cryptology</b> and its practitioners are
<b class="calibre10">cryptologists</b>. Modern cryptologists are generally trained in theoretical
mathematics — they have to be.</p>


<p class="calibre9">Plaintext is denoted by <i class="calibre12">M</i>, for message, or <i class="calibre12">P</i>, for plaintext. It can be a stream of bits, a text file, a bitmap, a stream of digitized voice, a digital video
image...whatever. As far as a computer is concerned, <i class="calibre12">M</i> is simply binary data.
(After this chapter, this book concerns itself with binary data and computer
cryptography.) The plaintext can be intended for either transmission or storage.
In any case, <i class="calibre12">M</i> is the message to be encrypted.</p>

<p class="calibre9">Ciphertext is denoted by <i class="calibre12">C</i>. It is also binary data: sometimes the same size as <i class="calibre12">M</i>, sometimes larger. (By combining encryption with compression, <i class="calibre12">C</i> may be smaller than <i class="calibre12">M</i>. However, encryption does not accomplish this.) The
encryption function <i class="calibre12">E</i>, operates on <i class="calibre12">M</i> to produce <i class="calibre12">C</i>. Or, in mathematical notation:</p>

<p class="math"><i class="calibre12">E</i>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
</p>

<p class="calibre9">In the reverse process, the decryption function <i class="calibre12">D</i> operates on <i class="calibre12">C</i> to produce <i class="calibre12">M</i>:</p>

<p class="math"><i class="calibre12">D</i>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
</p>

<p class="calibre9">Since the whole point of encrypting and then decrypting a message is to
recover the original plaintext, the following identity must hold true:</p>

<p class="math"><i class="calibre12">D</i>(<i class="calibre12">E</i>(<i class="calibre12">M</i>)) = <i class="calibre12">M</i>
</p>

<h4 class="calibre8">Authentication, Integrity, and Nonrepudiation</h4>

<p class="calibre9">In addition to providing confidentiality, cryptography is often asked to do
other jobs:</p>

<ul class="calibre13">

<li class="calibre14"><b class="calibre10">Authentication</b>. It should be possible for the receiver of a message
to ascertain its origin; an intruder should not be able to masquerade as
someone else.
</li>
<li class="calibre14"><b class="calibre10">Integrity</b>. It should be possible for the receiver of a message to
verify that it has not been modified in transit; an intruder should not be
able to substitute a false message for a legitimate one.
</li>
<li class="calibre14"><b class="calibre10">Nonrepudiation</b>. A sender should not be able to falsely deny later
that he sent a message.
</li>

</ul>

<p class="calibre9">These are vital requirements for social interaction on computers, and are
analogous to face-to-face interactions. That someone is who he says he is...that
someone’s credentials — whether a driver’s license, a medical degree, or a
passport — are valid...that a document purporting to come from a person
actually came from that person.... These are the things that authentication,
integrity, and nonrepudiation provide.</p>

<h4 class="calibre8">Algorithms and Keys</h4>

<p class="calibre9">A <b class="calibre10">cryptographic algorithm</b>, also called a <b class="calibre10">cipher</b>, is the mathematical
function used for encryption and decryption. (Generally, there are two related
functions: one for encryption and the other for decryption.)</p>

<p class="calibre9">If the security of an algorithm is based on keeping the way that algorithm
works a secret, it is a <b class="calibre10">restricted</b> algorithm. Restricted algorithms have
historical interest, but are woefully inadequate by today’s standards. A large or
changing group of users cannot use them, because every time a user leaves the
group everyone else must switch to a different algorithm. If someone
accidentally reveals the secret, everyone must change their algorithm.</p>

<p class="calibre9">Even more damning, restricted algorithms allow no quality control or
standardization. Every group of users must have their own unique algorithm.
Such a group can’t use off-the-shelf hardware or software products; an
eavesdropper can buy the same product and learn the algorithm. They have to
write their own algorithms and implementations. If no one in the group is a
good cryptographer, then they won’t know if they have a secure algorithm.</p>

<p class="calibre9">Despite these major drawbacks, restricted algorithms are enormously popular
for low-security applications. Users either don’t realize or don’t care about the
security problems inherent in their system.</p>

<p class="calibre9">Modern cryptography solves this problem with a <b class="calibre10">key</b>, denoted by <i class="calibre12">K</i>. This key might be any one of a large number of values. The range of possible values of
the key is called the <b class="calibre10">keyspace</b>. Both the encryption and decryption operations
use this key (i.e., they are dependent on the key and this fact is denoted by the
k subscript), so the functions now become:</p>

<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
<i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
</p>

<p class="calibre9">Those functions have the property that (see Figure 1.2):</p>

<p class="math"><i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>)) = <i class="calibre12">M</i>
</p>

<div class="figure" id="figure-1-2">
<p class="image"><img src="ac-figure-1-2.png" class="calibre11"/></p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 1.2</b> Encryption and decryption with a key.</i></p>
</div>

<p class="calibre9">Some algorithms use a different encryption key and decryption key (see Figure
1.3). That is, the encryption key, <i class="calibre12">K</i><sub class="calibre15">1</sub>, is different from the corresponding
decryption key, <i class="calibre12">K</i><sub class="calibre15">2</sub>. In this case:</p>

<p class="math"><i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">1</sub></sub>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
<i class="calibre12">D</i><sub class="calibre15">K<sub class="calibre16">2</sub></sub>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
<i class="calibre12">D</i><sub class="calibre15">K<sub class="calibre16">2</sub></sub>(<i class="calibre12">E</i><sub class="calibre15">K<sub class="calibre16">1</sub></sub>(<i class="calibre12">M</i>)) = <i class="calibre12">M</i>
</p>

<div class="figure" id="figure-1-3">
<p class="image"><img src="ac-figure-1-3.png" class="calibre11"/></p>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 1.3</b> Encryption and decryption with two different keys.</i></p>
</div>

<p class="calibre9">All of the security in these algorithms is based in the key (or keys); none is
based in the details of the algorithm. This means that the algorithm can be
published and analyzed. Products using the algorithm can be mass-produced. It
doesn’t matter if an eavesdropper knows your algorithm; if she doesn’t know
your particular key, she can’t read your messages.</p>

<p class="calibre9">A <b class="calibre10">cryptosystem</b> is an algorithm, plus all possible plaintexts, ciphertexts, and
keys.</p>

<h4 class="calibre8">Symmetric Algorithms</h4>

<p class="calibre9">There are two general types of key-based algorithms: symmetric and
public-key. <b class="calibre10">Symmetric algorithms</b>, sometimes called conventional
algorithms, are algorithms where the encryption key can be calculated from the
decryption key and vice versa. In most symmetric algorithms, the encryption
key and the decryption key are the same. These algorithms, also called
secret-key algorithms, single-key algorithms, or one-key algorithms, require
that the sender and receiver agree on a key before they can communicate
securely. The security of a symmetric algorithm rests in the key; divulging the
key means that anyone could encrypt and decrypt messages. As long as the
communication needs to remain secret, the key must remain secret.</p>

<p class="calibre9">Encryption and decryption with a symmetric algorithm are denoted by:</p>

<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
<i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
</p>

<p class="calibre9">Symmetric algorithms can be divided into two categories. Some operate on the
plaintext a single bit (or sometimes byte) at a time; these are called <b class="calibre10">stream</b>
<b class="calibre10">algorithms</b> or <b class="calibre10">stream ciphers</b>. Others operate on the plaintext in groups of bits. The groups of bits are called <b class="calibre10">blocks</b>, and the algorithms are called <b class="calibre10">block</b> <b class="calibre10">algorithms</b> or <b class="calibre10">block ciphers</b>. For modern computer algorithms, a typical
block size is 64 bits — large enough to preclude analysis and small enough to
be workable. (Before computers, algorithms generally operated on plaintext
one character at a time. You can think of this as a stream algorithm operating
on a stream of characters.)</p>

<h4 class="calibre8">Public-Key Algorithms</h4>

<p class="calibre9"><b class="calibre10">Public-key algorithms</b> (also called asymmetric algorithms) are designed so
that the key used for encryption is different from the key used for decryption.
Furthermore, the decryption key cannot (at least in any reasonable amount of
time) be calculated from the encryption key. The algorithms are called
“public-key” because the encryption key can be made public: A complete
stranger can use the encryption key to encrypt a message, but only a specific
person with the corresponding decryption key can decrypt the message. In
these systems, the encryption key is often called the <b class="calibre10">public key</b>, and the
decryption key is often called the <b class="calibre10">private key</b>. The private key is sometimes
also called the secret key, but to avoid confusion with symmetric algorithms,
that tag won’t be used here.</p>

<p class="calibre9">Encryption using public key <i class="calibre12">K</i> is denoted by:</p>

<p class="math"><i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
</p>

<p class="calibre9">Even though the public key and private key are different, decryption with the
corresponding private key is denoted by:</p>

<p class="math"><i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
</p>

<p class="calibre9">Sometimes, messages will be encrypted with the private key and decrypted
with the public key; this is used in digital signatures (see <a href="Applied%20Cryptography_split_003.html#2.6" class="calibre5 pcalibre">Section 2.6</a>). Despite
the possible confusion, these operations are denoted by, respectively:</p>

<p class="math"> <i class="calibre12">E</i><sub class="calibre15">K</sub>(<i class="calibre12">M</i>) = <i class="calibre12">C</i>
<i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>) = <i class="calibre12">M</i>
</p>

<h4 class="calibre8">Cryptanalysis</h4>

<p class="calibre9">The whole point of cryptography is to keep the plaintext (or the key, or both)
secret from eavesdroppers (also called adversaries, attackers, interceptors,
interlopers, intruders, opponents, or simply the enemy). Eavesdroppers are
assumed to have complete access to the communications between the sender
and receiver.</p>

<p class="calibre9">Cryptanalysis is the science of recovering the plaintext of a message without
access to the key. Successful cryptanalysis may recover the plaintext or the
key. It also may find weaknesses in a cryptosystem that eventually lead to the
previous results. (The loss of a key through noncryptanalytic means is called a
<b class="calibre10">compromise</b>.)</p>

<p class="calibre9">An attempted cryptanalysis is called an <b class="calibre10">attack</b>. A fundamental assumption in
cryptanalysis, first enunciated by the Dutchman A. Kerckhoffs in the
nineteenth century, is that the secrecy must reside entirely in the key [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>].
Kerckhoffs assumes that the cryptanalyst has complete details of the
cryptographic algorithm and implementation. (Of course, one would assume
that the CIA does not make a habit of telling Mossad about its cryptographic
algorithms, but Mossad probably finds out anyway.) While real-world
cryptanalysts don’t always have such detailed information, it’s a good
assumption to make. If others can’t break an algorithm, even with knowledge
of how it works, then they certainly won’t be able to break it without that
knowledge.</p>

<p class="calibre9">There are four general types of cryptanalytic attacks. Of course, each of them
assumes that the cryptanalyst has complete knowledge of the encryption
algorithm used:</p>

<ol class="calibre17">

<li class="calibre14"><p class="calibre9"><b class="calibre10">Ciphertext-only attack</b>. The cryptanalyst has the ciphertext of
several messages, all of which have been encrypted using the same
encryption algorithm. The cryptanalyst’s job is to recover the plaintext
of as many messages as possible, or better yet to deduce the key (or
keys) used to encrypt the messages, in order to decrypt other messages
encrypted with the same keys.</p>

<p class="calibre9">Given: <i class="calibre12">C<sub class="calibre15">1</sub></i> = <i class="calibre12">E<sub class="calibre15">k</sub></i>(<i class="calibre12">P<sub class="calibre15">1</sub></i>), <i class="calibre12">C<sub class="calibre15">2</sub></i> = <i class="calibre12">E<sub class="calibre15">k</sub></i>(<i class="calibre12">P<sub class="calibre15">2</sub></i>), ... <i class="calibre12">C<sub class="calibre15">i</sub></i> = <i class="calibre12">E<sub class="calibre15">k</sub></i>(<i class="calibre12">P<sub class="calibre15">i</sub></i>)</p>

<p class="calibre9">Deduce: Either <i class="calibre12">P<sub class="calibre15">1</sub>, P<sub class="calibre15">2</sub>, ... P<sub class="calibre15">i</sub>; k;</i> or an algorithm to infer <i class="calibre12">P<sub class="calibre15">i+1</sub></i> from <i class="calibre12">C<sub class="calibre15">i+1</sub></i> = E<sub class="calibre15">k</sub>(<i class="calibre12">P<sub class="calibre15">i+1</sub></i>)</p>
</li>

<li class="calibre14"><b class="calibre10">Known-plaintext attack</b>. The cryptanalyst has access not only to the ciphertext of several messages, but also to the plaintext of those
messages. His job is to deduce the key (or keys) used to encrypt the
messages or an algorithm to decrypt any new messages encrypted with
the same key (or keys).

<p class="calibre9">Given: <i class="calibre12">P<sub class="calibre15">1</sub>, C<sub class="calibre15">1</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">1</sub>), P<sub class="calibre15">2</sub>, C<sub class="calibre15">2</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">2</sub>), ... P<sub class="calibre15">i</sub>, C<sub class="calibre15">i</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">i</sub>)</i></p>

<p class="calibre9">Deduce: Either <i class="calibre12">k</i>, or an algorithm to infer <i class="calibre12">P<sub class="calibre15">i+1</sub></i> from <i class="calibre12">C<sub class="calibre15">i+1</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">i+1</sub>)</i></p>
</li>

<li class="calibre14"><p class="calibre9"><b class="calibre10">Chosen-plaintext attack</b>. The cryptanalyst not only has access to the ciphertext and associated plaintext for several messages, but he also
chooses the plaintext that gets encrypted. This is more powerful than a
known-plaintext attack, because the cryptanalyst can choose specific
plaintext blocks to encrypt, ones that might yield more information
about the key. His job is to deduce the key (or keys) used to encrypt the
messages or an algorithm to decrypt any new messages encrypted with
the same key (or keys).</p>

<p class="calibre9">Given: <i class="calibre12">P<sub class="calibre15">1</sub>, C<sub class="calibre15">1</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">1</sub>), P<sub class="calibre15">2</sub>, C<sub class="calibre15">2</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">2</sub>), ... P<sub class="calibre15">i</sub>, C<sub class="calibre15">i</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">i</sub>)</i>, where the cryptanalyst gets to choose <i class="calibre12">P<sub class="calibre15">1</sub>, P<sub class="calibre15">2</sub>, ... P<sub class="calibre15">i</sub></i></p>

<p class="calibre9">Deduce: Either <i class="calibre12">k</i>, or an algorithm to infer <i class="calibre12">P<sub class="calibre15">i+1</sub></i> from <i class="calibre12">C<sub class="calibre15">i+1</sub> = E<sub class="calibre15">k</sub>(P<sub class="calibre15">i+1</sub>)</i></p>

</li>

<li class="calibre14"><b class="calibre10">Adaptive-chosen-plaintext attack</b>. This is a special case of a
chosen-plaintext attack. Not only can the cryptanalyst choose the plaintext that
is encrypted, but he can also modify his choice based on the results of previous
encryption. In a chosen-plaintext attack, a cryptanalyst might just be able to
choose one large block of plaintext to be encrypted; in an
adaptive-chosen-plaintext attack he can choose a smaller block of plaintext and
then choose another based on the results of the first, and so forth.
</li>

</ol>

<p class="calibre9">There are at least three other types of cryptanalytic attack.</p>

<ol class="calibre17">

<li class="calibre14">
<p class="calibre9"><b class="calibre10">Chosen-ciphertext attack</b>. The cryptanalyst can choose different
ciphertexts to be decrypted and has access to the decrypted plaintext.
For example, the cryptanalyst has access to a tamperproof box that does
automatic decryption. His job is to deduce the key.</p>

<p class="calibre9">Given: <i class="calibre12">C<sub class="calibre15">1</sub>, P<sub class="calibre15">1</sub> = D<sub class="calibre15">k</sub>(C<sub class="calibre15">1</sub>), C<sub class="calibre15">2</sub>, P<sub class="calibre15">2</sub> = D<sub class="calibre15">k</sub>(C<sub class="calibre15">2</sub>), ... C<sub class="calibre15">i</sub>, P<sub class="calibre15">i</sub> = D<sub class="calibre15">k</sub>(C<sub class="calibre15">i</sub>)</i></p>
<p class="calibre9">Deduce: <i class="calibre12">k</i></p>

<p class="calibre9">This attack is primarily applicable to public-key algorithms and will be
discussed in <a href="Applied%20Cryptography_split_022.html#19.3" class="calibre5 pcalibre">Section 19.3</a>. A chosen-ciphertext attack is sometimes
effective against a symmetric algorithm as well. (Sometimes a
chosen-plaintext attack and a chosen-ciphertext attack are together
known as a <b class="calibre10">chosen-text attack</b>.)</p>
</li>
<li class="calibre14"><b class="calibre10">Chosen-key attack</b>. This attack doesn’t mean that the cryptanalyst
can choose the key; it means that he has some knowledge about the
relationship between different keys. It’s strange and obscure, not very
practical, and discussed in <a href="Applied%20Cryptography_split_015.html#12.4" class="calibre5 pcalibre">Section 12.4</a>.
</li>
<li class="calibre14"><b class="calibre10">Rubber-hose cryptanalysis</b>. The cryptanalyst threatens, blackmails,
or tortures someone until they give him the key. Bribery is sometimes
referred to as a <b class="calibre10">purchase-key attack</b>. These are all very powerful
attacks and often the best way to break an algorithm.
</li>

</ol>

<p class="calibre9">Known-plaintext attacks and chosen-plaintext attacks are more common than
you might think. It is not unheard-of for a cryptanalyst to get a plaintext
message that has been encrypted or to bribe someone to encrypt a chosen
message. You may not even have to bribe someone; if you give a message to
an ambassador, you will probably find that it gets encrypted and sent back to
his country for consideration. Many messages have standard beginnings and
endings that might be known to the cryptanalyst. Encrypted source code is
especially vulnerable because of the regular appearance of keywords: <code class="calibre18">#define</code>,
<code class="calibre18">struct</code>, <code class="calibre18">else</code>, <code class="calibre18">return</code>. Encrypted executable code has the same kinds of problems:
functions, loop structures, and so on. Known-plaintext attacks (and even
chosen-plaintext attacks) were successfully used against both the Germans and
the Japanese during World War II. David Kahn’s books [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>,<a href="Applied%20Cryptography_split_035.html#r795" class="calibre5 pcalibre">795</a>,<a href="Applied%20Cryptography_split_035.html#r796" class="calibre5 pcalibre">796</a>] have
historical examples of these kinds of attacks.</p>

<p class="calibre9">And don’t forget Kerckhoffs’s assumption: If the strength of your new
cryptosystem relies on the fact that the attacker does not know the algorithm’s
inner workings, you’re sunk. If you believe that keeping the algorithm’s
insides secret improves the security of your cryptosystem more than letting the
academic community analyze it, you’re wrong. And if you think that someone
won’t disassemble your code and reverse-engineer your algorithm, you’re
naïve. (In 1994 this happened with the RC4 algorithm — see <a href="Applied%20Cryptography_split_020.html#17.1" class="calibre5 pcalibre">Section 17.1</a>.) The
best algorithms we have are the ones that have been made public, have been
attacked by the world’s best cryptographers for years, and are still
unbreakable. (The National Security Agency keeps their algorithms secret
from outsiders, but they have the best cryptographers in the world working
within their walls — you don’t. Additionally, they discuss their algorithms with
one another, relying on peer review to uncover any weaknesses in their work.)</p>

<p class="calibre9">Cryptanalysts don’t always have access to the algorithms, as when the United
States broke the Japanese diplomatic code PURPLE during World War II
[<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>] — but they often do. If the algorithm is being used in a commercial
security program, it is simply a matter of time and money to disassemble the
program and recover the algorithm. If the algorithm is being used in a military
communications system, it is simply a matter of time and money to buy (or
steal) the equipment and reverse-engineer the algorithm.</p>

<p class="calibre9">Those who claim to have an unbreakable cipher simply because they can’t
break it are either geniuses or fools. Unfortunately, there are more of the latter
in the world. Beware of people who extol the virtues of their algorithms, but
refuse to make them public; trusting their algorithms is like trusting snake oil.</p>

<p class="calibre9">Good cryptographers rely on peer review to separate the good algorithms from
the bad.</p>

<h4 class="calibre8">Security of Algorithms</h4>

<p class="calibre9">Different algorithms offer different degrees of security; it depends on how
hard they are to break. If the cost required to break an algorithm is greater than
the value of the encrypted data, then you’re probably safe. If the time required
to break an algorithm is longer than the time the encrypted data must remain
secret, then you’re probably safe. If the amount of data encrypted with a single
key is less than the amount of data necessary to break the algorithm, then
you’re probably safe.</p>

<p class="calibre9">I say “probably” because there is always a chance of new breakthroughs in
cryptanalysis. On the other hand, the value of most data decreases over time. It
is important that the value of the data always remain less than the cost to break
the security protecting it.</p>

<p class="calibre9">Lars Knudsen classified these different categories of breaking an algorithm. In
decreasing order of severity [<a href="Applied%20Cryptography_split_036.html#r858" class="calibre5 pcalibre">858</a>]:</p>

<ol class="calibre17">

<li class="calibre14"><b class="calibre10">Total break</b>. A cryptanalyst finds the key, <i class="calibre12">K</i>, such that <i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>) = <i class="calibre12">P</i>.
</li>
<li class="calibre14"><b class="calibre10">Global deduction</b>. A cryptanalyst finds an alternate algorithm, <i class="calibre12">A</i>, equivalent to <i class="calibre12">D</i><sub class="calibre15">K</sub>(<i class="calibre12">C</i>), without knowing <i class="calibre12">K</i>.
</li>
<li class="calibre14"><b class="calibre10">Instance (or local) deduction</b>. A cryptanalyst finds the plaintext of an intercepted ciphertext.
</li>
<li class="calibre14"><b class="calibre10">Information deduction</b>. A cryptanalyst gains some information
about the key or plaintext. This information could be a few bits of the
key, some information about the form of the plaintext, and so forth.
</li>

</ol>

<p class="calibre9">An algorithm is <b class="calibre10">unconditionally secure</b> if, no matter how much ciphertext a
cryptanalyst has, there is not enough information to recover the plaintext. In
point of fact, only a one-time pad (see <a href="#1.5" class="calibre5 pcalibre">Section 1.5</a>) is unbreakable given
infinite resources. All other cryptosystems are breakable in a ciphertext-only
attack, simply by trying every possible key one by one and checking whether
the resulting plaintext is meaningful. This is called a <b class="calibre10">brute-force</b> attack (see <a href="Applied%20Cryptography_split_009.html#7.1" class="calibre5 pcalibre">Section 7.1</a>).</p>

<p class="calibre9">Cryptography is more concerned with cryptosystems that are computationally
infeasible to break. An algorithm is considered <b class="calibre10">computationally secure</b>
(sometimes called strong) if it cannot be broken with available resources,
either current or future. Exactly what constitutes “available resources” is open
to interpretation.</p>

<p class="calibre9">You can measure the complexity (see <a href="Applied%20Cryptography_split_014.html#11.1" class="calibre5 pcalibre">Section 11.1</a>) of an attack in different
ways:</p>

<ol class="calibre17">

<li class="calibre14"><b class="calibre10">Data complexity</b>. The amount of data needed as input to the attack.
</li>
<li class="calibre14"><b class="calibre10">Processing complexity</b>. The time needed to perform the attack. This
is often called the <b class="calibre10">work factor</b>.
</li>
<li class="calibre14"><b class="calibre10">Storage requirements</b>. The amount of memory needed to do the
attack.
</li>

</ol>

<p class="calibre9">As a rule of thumb, the complexity of an attack is taken to be the minimum of
these three factors. Some attacks involve trading off the three complexities: A
faster attack might be possible at the expense of a greater storage requirement.</p>

<p class="calibre9">Complexities are expressed as orders of magnitude. If an algorithm has a
processing complexity of 2<sup class="calibre19">128</sup>, then 2<sup class="calibre19">128</sup> operations are required to break the
algorithm. (These operations may be complex and time-consuming.) Still, if
you assume that you have enough computing speed to perform a million
operations every second and you set a million parallel processors against the
task, it will still take over 10<sup class="calibre19">19</sup> years to recover the key. That’s a billion times
the age of the universe.</p>

<p class="calibre9">While the complexity of an attack is constant (until some cryptanalyst finds a
better attack, of course), computing power is anything but. There have been
phenomenal advances in computing power during the last half-century and
there is no reason to think this trend won’t continue. Many cryptanalytic
attacks are perfect for parallel machines: The task can be broken down into
billions of tiny pieces and none of the processors need to interact with each
other. Pronouncing an algorithm secure simply because it is infeasible to
break, given current technology, is dicey at best. Good cryptosystems are
designed to be infeasible to break with the computing power that is expected to
evolve many years in the future.</p>

<h4 class="calibre8">Historical Terms</h4>

<p class="calibre9">Historically, a <b class="calibre10">code</b> refers to a cryptosystem that deals with linguistic units: words, phrases, sentences, and so forth. For example, the word “OCELOT”
might be the ciphertext for the entire phrase “TURN LEFT 90 DEGREES,”
the word “LOLLIPOP” might be the ciphertext for “TURN RIGHT 90
DEGREES,” and the words “BENT EAR” might be the ciphertext for
“HOWITZER.” Codes of this type are not discussed in this book; see
[<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>,<a href="Applied%20Cryptography_split_035.html#r795" class="calibre5 pcalibre">795</a>]. Codes are only useful for specialized circumstances. Ciphers are
useful for any circumstance. If your code has no entry for “ANTEATERS,”
then you can’t say it. You can say anything with a cipher.</p>

<h3 id="1.2" class="calibre7">1.2 Steganography</h3>

<p class="calibre9"><b class="calibre10">Steganography</b> serves to hide secret messages in other messages, such that the
secret’s very existence is concealed. Generally the sender writes an innocuous
message and then conceals a secret message on the same piece of paper.
Historical tricks include invisible inks, tiny pin punctures on selected
characters, minute differences between handwritten characters, pencil marks
on typewritten characters, grilles which cover most of the message except for a
few characters, and so on.</p>

<p class="calibre9">More recently, people are hiding secret messages in graphic images. Replace
the least significant bit of each byte of the image with the bits of the message.
The graphical image won’t change appreciably — most graphics standards
specify more gradations of color than the human eye can notice — and the
message can be stripped out at the receiving end. You can store a 64-kilobyte
message in a 1024 × 1024 grey-scale picture this way. Several public-domain
programs do this sort of thing.</p>

<p class="calibre9">Peter Wayner’s <b class="calibre10">mimic functions</b> obfuscate messages. These functions modify
a message so that its statistical profile resembles that of something else: the
classifieds section of <i class="calibre12">The New York Times</i>, a play by Shakespeare, or a
newsgroup on the Internet [<a href="Applied%20Cryptography_split_036.html#r1584" class="calibre5 pcalibre">1584</a>,<a href="Applied%20Cryptography_split_036.html#r1585" class="calibre5 pcalibre">1585</a>]. This type of steganography won’t fool
a person, but it might fool some big computers scanning the Internet for
interesting messages.</p>

<h3 id="1.3" class="calibre7">1.3 Substitution Ciphers and Transposition Ciphers</h3>

<p class="calibre9">Before computers, cryptography consisted of character-based algorithms.
Different cryptographic algorithms either substituted characters for one
another or transposed characters with one another. The better algorithms did
both, many times each.</p>

<p class="calibre9">Things are more complex these days, but the philosophy remains the same.
The primary change is that algorithms work on bits instead of characters. This
is actually just a change in the alphabet size: from 26 elements to two
elements. Most good cryptographic algorithms still combine elements of
substitution and transposition.</p>

<h4 class="calibre8">Substitution Ciphers</h4>

<p class="calibre9"><b class="calibre10">A substitution cipher</b> is one in which each character in the plaintext is
substituted for another character in the ciphertext. The receiver inverts the
substitution on the ciphertext to recover the plaintext.</p>

<p class="calibre9">In classical cryptography, there are four types of substitution ciphers:</p>

<ul class="calibre13">

<li class="calibre14"><b class="calibre10">A simple substitution cipher</b>, or <b class="calibre10">monoalphabetic cipher</b>, is one in
which each character of the plaintext is replaced with a corresponding
character of ciphertext. The cryptograms in newspapers are simple
substitution ciphers.
</li>
<li class="calibre14"><b class="calibre10">A homophonic substitution cipher</b> is like a simple substitution
cryptosystem, except a single character of plaintext can map to one of
several characters of ciphertext. For example, “A” could correspond to
either 5, 13, 25, or 56, “B” could correspond to either 7, 19, 31, or 42,
and so on.
</li>
<li class="calibre14"><b class="calibre10">A polygram substitution cipher</b> is one in which blocks of
characters are encrypted in groups. For example, “ABA” could
correspond to “RTQ,” “ABB” could correspond to “SLL,” and so on.
</li>
<li class="calibre14"><b class="calibre10">A polyalphabetic substitution cipher</b> is made up of multiple simple
substitution ciphers. For example, there might be five different simple
substitution ciphers used; the particular one used changes with the
position of each character of the plaintext.
</li>

</ul>

<p class="calibre9">The famous <b class="calibre10">Caesar Cipher</b>, in which each plaintext character is replaced by
the character three to the right modulo 26 (“A” is replaced by “D,” “B” is
replaced by “E,”..., “W” is replaced by “Z,” “X” is replaced by “A,” “Y” is
replaced by “B,” and “Z” is replaced by “C”) is a simple substitution cipher.
It’s actually even simpler, because the ciphertext alphabet is a rotation of the
plaintext alphabet and not an arbitrary permutation.</p>

<p class="calibre9">ROT13 is a simple encryption program commonly found on UNIX systems; it
is also a simple substitution cipher. In this cipher, “A” is replaced by “N,” “B”
is replaced by “O,” and so on. Every letter is rotated 13 places.</p>

<p class="calibre9">Encrypting a file twice with ROT13 restores the original file.</p>

<p class="math"><i class="calibre12">P</i> = ROT13(ROT13(<i class="calibre12">P</i>))
</p>

<p class="calibre9">ROT13 is not intended for security; it is often used in Usenet posts to hide
potentially offensive text, to avoid giving away the solution to a puzzle, and so
forth.</p>

<p class="calibre9">Simple substitution ciphers can be easily broken because the cipher does not
hide the underlying frequencies of the different letters of the plaintext. All it
takes is about 25 English characters before a good cryptanalyst can reconstruct
the plaintext [<a href="Applied%20Cryptography_split_036.html#r1434" class="calibre5 pcalibre">1434</a>]. An algorithm for solving these sorts of ciphers can be
found in [<a href="Applied%20Cryptography_split_035.html#r578" class="calibre5 pcalibre">578</a>,<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_036.html#r1600" class="calibre5 pcalibre">1600</a>,<a href="Applied%20Cryptography_split_035.html#r78" class="calibre5 pcalibre">78</a>,<a href="Applied%20Cryptography_split_036.html#r1475" class="calibre5 pcalibre">1475</a>,<a href="Applied%20Cryptography_split_036.html#r1236" class="calibre5 pcalibre">1236</a>,<a href="Applied%20Cryptography_split_036.html#r880" class="calibre5 pcalibre">880</a>]. A good computer algorithm is
[<a href="Applied%20Cryptography_split_035.html#r703" class="calibre5 pcalibre">703</a>].</p>

<p class="calibre9">Homophonic substitution ciphers were used as early as 1401 by the Duchy of
Mantua [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>]. They are much more complicated to break than simple
substitution ciphers, but still do not obscure all of the statistical properties of
the plaintext language. With a known-plaintext attack, the ciphers are trivial to
break. A ciphertext-only attack is harder, but only takes a few seconds on a
computer. Details are in [<a href="Applied%20Cryptography_split_036.html#r1261" class="calibre5 pcalibre">1261</a>].</p>

<p class="calibre9">Polygram substitution ciphers are ciphers in which groups of letters are
encrypted together. The Playfair cipher, invented in 1854, was used by the
British during World War I [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>]. It encrypts pairs of letters together. Its
cryptanalysis is discussed in [<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_036.html#r1475" class="calibre5 pcalibre">1475</a>,<a href="Applied%20Cryptography_split_036.html#r880" class="calibre5 pcalibre">880</a>]. The Hill cipher is another
example of a polygram substitution cipher [<a href="Applied%20Cryptography_split_035.html#r732" class="calibre5 pcalibre">732</a>]. Sometimes you see Huffman
coding used as a cipher; this is an insecure polygram substitution cipher.</p>

<p class="calibre9">Polyalphabetic substitution ciphers were invented by Leon Battista in 1568
[<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>]. They were used by the Union army during the American Civil War.
Despite the fact that they can be broken easily [<a href="Applied%20Cryptography_split_035.html#r819" class="calibre5 pcalibre">819</a>,<a href="Applied%20Cryptography_split_035.html#r577" class="calibre5 pcalibre">577</a>,<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>] (especially
with the help of computers), many commercial computer security products use
ciphers of this form [<a href="Applied%20Cryptography_split_036.html#r1387" class="calibre5 pcalibre">1387</a>,<a href="Applied%20Cryptography_split_036.html#r1390" class="calibre5 pcalibre">1390</a>,<a href="Applied%20Cryptography_split_036.html#r1502" class="calibre5 pcalibre">1502</a>]. (Details on how to break this
encryption scheme, as used in WordPerfect, can be found in [<a href="Applied%20Cryptography_split_035.html#r135" class="calibre5 pcalibre">135</a>,<a href="Applied%20Cryptography_split_035.html#r139" class="calibre5 pcalibre">139</a>].) The
Vigenère cipher, first published in 1586, and the Beaufort cipher are also
examples of polyalphabetic substitution ciphers.</p>

<p class="calibre9">Polyalphabetic substitution ciphers have multiple one-letter keys, each of
which is used to encrypt one letter of the plaintext. The first key encrypts the
first letter of the plaintext, the second key encrypts the second letter of the
plaintext, and so on. After all the keys are used, the keys are recycled. If there
were 20 one-letter keys, then every twentieth letter would be encrypted with
the same key. This is called the <b class="calibre10">period</b> of the cipher. In classical cryptography, ciphers with longer periods were significantly harder to break than ciphers
with short periods. There are computer techniques that can easily break
substitution ciphers with very long periods.</p>

<p class="calibre9">A <b class="calibre10">running-key cipher</b> — sometimes called a book cipher — in which one text is
used to encrypt another text, is another example of this sort of cipher. Even
though this cipher has a period the length of the text, it can also be broken
easily [<a href="Applied%20Cryptography_split_035.html#r576" class="calibre5 pcalibre">576</a>,<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>].</p>

<h4 class="calibre8">Transposition Ciphers</h4>

<p class="calibre9">In a <b class="calibre10">transposition cipher</b> the plaintext remains the same, but the order of
characters is shuffled around. In a <b class="calibre10">simple columnar transposition cipher</b>, the
plaintext is written horizontally onto a piece of graph paper of fixed width and the
ciphertext is read off vertically (see Figure 1.4). Decryption is a matter of writing
the ciphertext vertically onto a piece of graph paper of identical width and then
reading the plaintext off horizontally.</p>

<pre class="calibre20">                         Plaintext:
L'ASSASSIN EST LE DOCTEUR MATRIX, REGARDEX DERRIÈRE L'HORLOGE

        LASSASSIN
        ESTLEDOCT
        EURMATRIX
        REGARDEXD
        ERRIERELH
        ORLOGE

                         Ciphertext:
LEERE OASUE RRSTR GRLSL MAIOA EAREG SDTDR ESORE EICIZ LNTXD H
</pre>
<p class="calibre21"><i class="calibre12"><b class="calibre10">Figure 1.4</b> Columnar transposition cipher.</i></p>

<p class="calibre9">Cryptanalysis of these ciphers is discussed in [<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_036.html#r1475" class="calibre5 pcalibre">1475</a>]. Since the letters of the
ciphertext are the same as those of the plaintext, a frequency analysis on the
ciphertext would reveal that each letter has approximately the same likelihood as in
English. This gives a very good clue to a cryptanalyst, who can then use a variety
of techniques to determine the right ordering of the letters to obtain the plaintext.
Putting the ciphertext through a second transposition cipher greatly enhances
security. There are even more complicated transposition ciphers, but computers can
break almost all of them.</p>

<p class="calibre9">The German ADFGVX cipher, used during World War I, is a transposition cipher
combined with a simple substitution. It was a very complex algorithm for its day
but was broken by Georges Painvin, a French cryptanalyst [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>].</p>

<p class="calibre9">Although many modern algorithms use transposition, it is troublesome because it
requires a lot of memory and sometimes requires messages to be only certain
lengths. Substitution is far more common.</p>

<h4 class="calibre8">Rotor Machines</h4>

<p class="calibre9">In the 1920s, various mechanical encryption devices were invented to automate the
process of encryption. Most were based on the concept of a <b class="calibre10">rotor</b>, a mechanical
wheel wired to perform a general substitution.</p>

<p class="calibre9">A <b class="calibre10">rotor machine</b> has a keyboard and a series of rotors, and implements a version of the Vigenère cipher. Each rotor is an arbitrary permutation of the alphabet, has
26 positions, and performs a simple substitution. For example, a rotor might be
wired to substitute “F” for “A,” “U” for “B,” “L” for “C,” and so on. And the
output pins of one rotor are connected to the input pins of the next.</p>

<p class="calibre9">For example, in a 4-rotor machine the first rotor might substitute “F” for “A,” the
second might substitute “Y” for “F,” the third might substitute “E” for “Y,” and the
fourth might substitute “C” for “E”; “C” would be the output ciphertext. Then some
of the rotors shift, so next time the substitutions will be different.</p>

<p class="calibre9">It is the combination of several rotors and the gears moving them that makes the
machine secure. Because the rotors all move at different rates, the period for an
n-rotor machine is 26<sup class="calibre19"><i class="calibre22">n</i></sup>. Some rotor machines can also have a different number of positions on each rotor, further frustrating cryptanalysis.</p>

<p class="calibre9">The best-known rotor device is the Enigma. The Enigma was used by the Germans
during World War II. The idea was invented by Arthur Scherbius and Arvid
Gerhard Damm in Europe. It was patented in the United States by Arthur Scherbius
[<a href="Applied%20Cryptography_split_036.html#r1383" class="calibre5 pcalibre">1383</a>]. The Germans beefed up the basic design considerably for wartime use.</p>

<p class="calibre9">The original German Enigma had three rotors, chosen from a set of five, a plugboard that
slightly permuted the plaintext, and a reflecting rotor that caused each rotor to
operate on each plaintext letter twice. As complicated as the Enigma was, it was
broken during World War II. First, a team of Polish cryptographers broke the
German Enigma and explained their attack to the British. The Germans modified
their Enigma as the war progressed, and the British continued to cryptanalyze the
new versions. For explanations of how rotor ciphers work and how they were
broken, see [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>,<a href="Applied%20Cryptography_split_035.html#r86" class="calibre5 pcalibre">86</a>,<a href="Applied%20Cryptography_split_035.html#r448" class="calibre5 pcalibre">448</a>,<a href="Applied%20Cryptography_split_035.html#r498" class="calibre5 pcalibre">498</a>,<a href="Applied%20Cryptography_split_035.html#r446" class="calibre5 pcalibre">446</a>,<a href="Applied%20Cryptography_split_036.html#r880" class="calibre5 pcalibre">880</a>,<a href="Applied%20Cryptography_split_036.html#r1315" class="calibre5 pcalibre">1315</a>,<a href="Applied%20Cryptography_split_036.html#r1587" class="calibre5 pcalibre">1587</a>,<a href="Applied%20Cryptography_split_035.html#r690" class="calibre5 pcalibre">690</a>]. Two fascinating accounts of
how the Enigma was broken are [<a href="Applied%20Cryptography_split_035.html#r735" class="calibre5 pcalibre">735</a>,<a href="Applied%20Cryptography_split_035.html#r796" class="calibre5 pcalibre">796</a>].</p>

<h4 class="calibre8">Further Reading</h4>

<p class="calibre9">This is not a book about classical cryptography, so I will not dwell further on these
subjects. Two excellent precomputer cryptology books are [<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_036.html#r1475" class="calibre5 pcalibre">1475</a>]; [<a href="Applied%20Cryptography_split_035.html#r448" class="calibre5 pcalibre">448</a>]
presents some modern cryptanalysis of cipher machines. Dorothy Denning
discusses many of these ciphers in [<a href="Applied%20Cryptography_split_035.html#r456" class="calibre5 pcalibre">456</a>] and [<a href="Applied%20Cryptography_split_036.html#r880" class="calibre5 pcalibre">880</a>] has some fairly complex
mathematical analysis of the same ciphers. Another older cryptography text, which
discusses analog cryptography, is [<a href="Applied%20Cryptography_split_035.html#r99" class="calibre5 pcalibre">99</a>]. An article that presents a good overview of
the subject is [<a href="Applied%20Cryptography_split_035.html#r579" class="calibre5 pcalibre">579</a>]. David Kahn’s historical cryptography books are also excellent
[<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>,<a href="Applied%20Cryptography_split_035.html#r795" class="calibre5 pcalibre">795</a>,<a href="Applied%20Cryptography_split_035.html#r796" class="calibre5 pcalibre">796</a>].</p>

<h3 id="1.4" class="calibre7">1.4 Simple XOR</h3>

<p class="calibre9"><b class="calibre10">XOR</b> is exclusive-or operation: ‘^’ in C or ⊕ in mathematical notation. It’s a
standard operation on bits:</p>

<pre class="calibre20">0 ⊕ 0 = 0
0 ⊕ 1 = 1
1 ⊕ 0 = 1
1 ⊕ 1 = 0
</pre>

<p class="calibre9">Also note that:</p>

<pre class="calibre20"><i class="calibre22">a</i> ⊕ <i class="calibre22">a</i> = 0
<i class="calibre22">a</i> ⊕ <i class="calibre22">b</i> ⊕ <i class="calibre22">b</i> = <i class="calibre22">a</i>
</pre>

<p class="calibre9">The simple-XOR algorithm is really an embarrassment; it’s nothing more than a
Vigenère polyalphabetic cipher. It’s here only because of its prevalence in
commercial software packages, at least those in the MS-DOS and Macintosh
worlds [<a href="Applied%20Cryptography_split_036.html#r1502" class="calibre5 pcalibre">1502</a>,<a href="Applied%20Cryptography_split_036.html#r1387" class="calibre5 pcalibre">1387</a>]. Unfortunately, if a software security program proclaims that it
has a “proprietary” encryption algorithm — significantly faster than DES — the odds
are that it is some variant of this.</p>

<pre class="calibre20">/* Usage:  crypto key input_file output_file */

void main (int argc, char *argv[])

{
     FILE *fi, *fo;
     char *cp;
     int c;

     if ((cp = argv[1]) &amp;&amp; *cp!='\0')  {
          if ((fi = fopen(argv[2], "rb")) != NULL)  {
               if ((fo = fopen(argv[3], "wb")) != NULL)  {
                    while ((c = getc(fi)) != EOF)  {
                         if (!*cp) cp = argv[1];
                         c ^= *(cp++);
                         putc(c,fo);
                    }
                    fclose(fo);
               }
               fclose(fi);
          }
     }
}
</pre>

<p class="calibre9">This is a symmetric algorithm. The plaintext is being XORed with a keyword to
generate the ciphertext. Since XORing the same value twice restores the original,
encryption and decryption use exactly the same program:</p>

<p class="math"><i class="calibre12">P</i> ⊕ <i class="calibre12">K</i> = <i class="calibre12">C</i>
<i class="calibre12">C</i> ⊕ <i class="calibre12">K</i> = <i class="calibre12">P</i>
</p>

<p class="calibre9">There’s no real security here. This kind of encryption is trivial to break, even
without computers [<a href="Applied%20Cryptography_split_035.html#r587" class="calibre5 pcalibre">587</a>,<a href="Applied%20Cryptography_split_036.html#r1475" class="calibre5 pcalibre">1475</a>]. It will only take a few seconds with a computer.</p>

<p class="calibre9">Assume the plaintext is English. Furthermore, assume the key length is any small
number of bytes. Here’s how to break it:</p>

<ol class="calibre17">

<li class="calibre14">Discover the length of the key by a procedure known as <b class="calibre10">counting</b>
<b class="calibre10">coincidences</b> [<a href="Applied%20Cryptography_split_035.html#r577" class="calibre5 pcalibre">577</a>]. XOR the ciphertext against itself shifted various
numbers of bytes, and count those bytes that are equal. If the displacement is
a multiple of the key length, then something over 6 percent of the bytes will
be equal. If it is not, then less than 0.4 percent will be equal (assuming a
random key encrypting normal ASCII text; other plaintext will have different
numbers). This is called the <b class="calibre10">index of coincidence</b>. The smallest
displacement that indicates a multiple of the key length is the length of the
key.
</li>
<li class="calibre14">Shift the ciphertext by that length and XOR it with itself. This removes
the key and leaves you with plaintext XORed with the plaintext shifted the
length of the key. Since English has 1.3 bits of real information per byte (see
<a href="Applied%20Cryptography_split_014.html#11.1" class="calibre5 pcalibre">Section 11.1</a>), there is plenty of redundancy for determining a unique
decryption.
</li>

</ol>

<p class="calibre9">Despite this, the list of software vendors that tout this toy algorithm as being
“almost as secure as DES” is staggering [<a href="Applied%20Cryptography_split_036.html#r1387" class="calibre5 pcalibre">1387</a>]. It is the algorithm (with a 160-bit
repeated “key”) that the NSA finally allowed the U.S. digital cellular phone
industry to use for voice privacy. An XOR might keep your kid sister from reading
your files, but it won’t stop a cryptanalyst for more than a few minutes.</p>

<h3 id="1.5" class="calibre7">1.5 One-Time Pads</h3>

<p class="calibre9">Believe it or not, there is a perfect encryption scheme. It’s called a <b class="calibre10">one-time pad</b>, and was invented in 1917 by Major Joseph Mauborgne and AT&amp;T’s Gilbert
Vernam [<a href="Applied%20Cryptography_split_035.html#r794" class="calibre5 pcalibre">794</a>]. (Actually, a one-time pad is a special case of a threshold scheme;
see <a href="Applied%20Cryptography_split_004.html#3.7" class="calibre5 pcalibre">Section 3.7</a>.) Classically, a one-time pad is nothing more than a large
nonrepeating set of truly random key letters, written on sheets of paper, and glued
together in a pad. In its original form, it was a one-time tape for teletypewriters.
The sender uses each key letter on the pad to encrypt exactly one plaintext
character. Encryption is the addition modulo 26 of the plaintext character and the
one-time pad key character.</p>

<p class="calibre9">Each key letter is used exactly once, for only one message. The sender encrypts the
message and then destroys the used pages of the pad or used section of the tape.
The receiver has an identical pad and uses each key on the pad, in turn, to decrypt
each letter of the ciphertext. The receiver destroys the same pad pages or tape
section after decrypting the message. New message — new key letters. For example,
if the message is:</p>

<pre class="calibre20">ONETIMEPAD
</pre>

<p class="calibre9">and the key sequence from the pad is</p>

<pre class="calibre20">TBFRGFARFM
</pre>

<p class="calibre9">then the ciphertext is</p>

<pre class="calibre20">IPKLPSFHGQ
</pre>

<p class="calibre9">because</p>

<pre class="calibre20">O + T mod 26 = I
N + B mod 26 = P
E + F mod 26 = K
etc.
</pre>

<p class="calibre9">Assuming an eavesdropper can’t get access to the one-time pad used to encrypt
the message, this scheme is perfectly secure. A given ciphertext message is
equally likely to correspond to any possible plaintext message of equal size.</p>

<p class="calibre9">Since every key sequence is equally likely (remember, the key letters are
generated randomly), an adversary has no information with which to
cryptanalyze the ciphertext. The key sequence could just as likely be:</p>

<pre class="calibre20">POYYAEAAZX
</pre>

<p class="calibre9">which would decrypt to:</p>

<pre class="calibre20">SALMONEGGS
</pre>

<p class="calibre9">or</p>

<pre class="calibre20">BXFGBMTMXM
</pre>

<p class="calibre9">which would decrypt to:</p>

<pre class="calibre20">GREENFLUID
</pre>

<p class="calibre9">This point bears repeating: Since every plaintext message is equally possible,
there is no way for the cryptanalyst to determine which plaintext message is
the correct one. A random key sequence added to a nonrandom plaintext
message produces a completely random ciphertext message and no amount of
computing power can change that.</p>

<p class="calibre9">The caveat, and this is a big one, is that the key letters have to be generated
randomly. Any attacks against this scheme will be against the method used to
generate the key letters. Using a pseudo-random number generator doesn’t
count; they always have nonrandom properties. If you use a real random
source — this is much harder than it might first appear, see <a href="Applied%20Cryptography_split_020.html#17.14" class="calibre5 pcalibre">Section 17.14</a> — it’s
secure.</p>

<p class="calibre9">The other important point is that you can never use the key sequence again,
ever. Even if you use a multiple-gigabyte pad, if a cryptanalyst has multiple
ciphertexts whose keys overlap, he can reconstruct the plaintext. He slides
each pair of ciphertexts against each other and counts the number of matches
at each position. If they are aligned right, the proportion of matches jumps
suddenly — the exact percentages depend on the plaintext language. From this
point cryptanalysis is easy. It’s like the index of coincidence, but with just two
“periods” to compare [<a href="Applied%20Cryptography_split_036.html#r904" class="calibre5 pcalibre">904</a>]. Don’t do it.</p>

<p class="calibre9">The idea of a one-time pad can be easily extended to binary data. Instead of a
one-time pad consisting of letters, use a one-time pad of bits. Instead of adding
the plaintext to the one-time pad, use an XOR. To decrypt, XOR the ciphertext
with the same one-time pad. Everything else remains the same and the security
is just as perfect.</p>

<p class="calibre9">This all sounds good, but there are a few problems. Since the key bits must be
random and can never be used again, the length of the key sequence must be
equal to the length of the message. A one-time pad might be suitable for a few
short messages, but it will never work for a 1.544 Mbps communications
channel. You can store 650 megabytes worth of random bits on a CD-ROM,
but there are problems. First, you want exactly two copies of the random bits,
but CD-ROMs are economical only for large quantities. And second, you want
to be able to destroy the bits already used. CD-ROM has no erase facilities
except for physically destroying the entire disk. Digital tape is a much better
medium for this sort of thing.</p>

<p class="calibre9">Even if you solve the key distribution and storage problem, you have to make
sure the sender and receiver are perfectly synchronized. If the receiver is off by
a bit (or if some bits are dropped during the transmission), the message won’t
make any sense. On the other hand, if some bits are altered during
transmission (without any bits being added or removed — something far more
likely to happen due to random noise), only those bits will be decrypted
incorrectly. But on the other hand, a one-time pad provides no authenticity.</p>

<p class="calibre9">One-time pads have applications in today’s world, primarily for ultra-secure
low-bandwidth channels. The hotline between the United States and the former
Soviet Union was (is it still active?) rumored to be encrypted with a one-time
pad. Many Soviet spy messages to agents were encrypted using one-time pads.
These messages are still secure today and will remain that way forever. It
doesn’t matter how long the supercomputers work on the problem. Even after
the aliens from Andromeda land with their massive spaceships and
undreamed-of computing power, they will not be able to read the Soviet spy
messages encrypted with one-time pads (unless they can also go back in time
and get the one-time pads).</p>

<h3 id="1.6" class="calibre7">1.6 Computer Algorithms</h3>

<p class="calibre9">There are many cryptographic algorithms. These are three of the most
common:</p>

<ul class="calibre13">

<li class="calibre14">DES (Data Encryption Standard) is the most popular computer
encryption algorithm. DES is a U.S. and international standard. It is a
symmetric algorithm; the same key is used for encryption and
decryption.
</li>
<li class="calibre14">RSA (named for its creators — Rivest, Shamir, and Adleman) is the
most popular public-key algorithm. It can be used for both encryption
and digital signatures.
</li>
<li class="calibre14">DSA (Digital Signature Algorithm, used as part of the Digital
Signature Standard) is another public-key algorithm. It cannot be used
for encryption, but only for digital signatures.
</li>

</ul>

<p class="calibre9">These are the kinds of stuff this book is about.</p>

<h3 id="1.7" class="calibre7">1.7 Large Numbers</h3>

<p class="calibre9">Throughout this book, I use various large numbers to describe different things
in cryptography. Because it is so easy to lose sight of these numbers and what
they signify, Table 1.1 gives physical analogues for some of them.</p>

<p class="calibre9">These numbers are order-of-magnitude estimates, and have been culled from a
variety of sources. Many of the astrophysics numbers are explained in
Freeman Dyson’s paper, “Time Without End: Physics and Biology in an Open
Universe,” in <i class="calibre12">Reviews of Modern Physics</i>, v. 52, n. 3, July 1979, pp. 447–460.
Automobile accident deaths are calculated from the Department of
Transportation’s statistic of 163 deaths per million people in 1993 and an
average lifespan of 69.7 years.</p>

<table class="data-table" id="table-1-1">
<caption class="calibre23">TABLE 1.1 - Large Numbers</caption>
<tbody class="calibre24"><tr class="calibre25">
<th class="calibre26">Physical Analogue</th>
<th class="calibre26">Number</th>
</tr>
<tr class="calibre25"><td class="calibre27">Odds of being killed by lightning (per day)</td><td class="calibre27">1 in 9 billion (2<sup class="calibre19">33</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Odds of winning the top prize in a U.S. state lottery</td><td class="calibre27">1 in 4,000,000 (2<sup class="calibre19">22</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Odds of winning the top prize in a U.S. state lottery and being killed by lightning in the same day</td><td class="calibre27">1 in 2<sup class="calibre19">55</sup></td></tr>
<tr class="calibre25"><td class="calibre27">Odds of drowning (in the U.S. per year)</td><td class="calibre27">1 in 59,000 (2<sup class="calibre19">16</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Odds of being killed in an automobile accident(in the U.S. in 1993)</td><td class="calibre27">1 in 6100 (2<sup class="calibre19">13</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Odds of being killed in an automobile accident(in the U.S. per lifetime)</td><td class="calibre27">1 in 88 (2<sup class="calibre19">7</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Time until the next ice age</td><td class="calibre27">14,000 (2<sup class="calibre19">14</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until the sun goes nova</td><td class="calibre27">10<sup class="calibre19">9</sup> (2<sup class="calibre19">30</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Age of the planet</td><td class="calibre27">10<sup class="calibre19">9</sup> (2<sup class="calibre19">30</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Age of the Universe</td><td class="calibre27">10<sup class="calibre19">10</sup> (2<sup class="calibre19">34</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Number of atoms in the planet</td><td class="calibre27">10<sup class="calibre19">51</sup> (2<sup class="calibre19">170</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Number of atoms in the sun</td><td class="calibre27">10<sup class="calibre19">57</sup> (2<sup class="calibre19">190</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Number of atoms in the galaxy</td><td class="calibre27">10<sup class="calibre19">67</sup> (2<sup class="calibre19">223</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Number of atoms in the Universe (dark matter excluded)</td><td class="calibre27">10<sup class="calibre19">77</sup> (2<sup class="calibre19">265</sup>)</td></tr>
<tr class="calibre25"><td class="calibre27">Volume of the Universe</td><td class="calibre27">10<sup class="calibre19">84</sup> (2<sup class="calibre19">280</sup>) cm<sup class="calibre19">3</sup></td></tr>
<tr class="calibre25"><td colspan="2" class="row-title">If the Universe is Closed:</td></tr>
<tr class="calibre25"><td class="calibre27">Total lifetime of the Universe</td><td class="calibre27">10<sup class="calibre19">11</sup> (2<sup class="calibre19">37</sup>) years <br class="calibre3"/>10<sup class="calibre19">18</sup> (2<sup class="calibre19">61</sup>) seconds</td></tr>
<tr class="calibre25"><td colspan="2" class="row-title">If the Universe is Open:</td></tr>
<tr class="calibre25"><td class="calibre27">Time until low-mass stars cool off</td><td class="calibre27">10<sup class="calibre19">14</sup> (2<sup class="calibre19">47</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until planets detach from stars</td><td class="calibre27">10<sup class="calibre19">15</sup> (2<sup class="calibre19">50</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until stars detach from galaxies</td><td class="calibre27">10<sup class="calibre19">19</sup> (2<sup class="calibre19">64</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until orbits decay by gravitational radiation</td><td class="calibre27">10<sup class="calibre19">20</sup> (2<sup class="calibre19">67</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until black holes decay by the Hawking process</td><td class="calibre27">10<sup class="calibre19">64</sup> (2<sup class="calibre19">213</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until all matter is liquid at zero temperature</td><td class="calibre27">10<sup class="calibre19">65</sup> (2<sup class="calibre19">216</sup>) years</td></tr>
<tr class="calibre25"><td class="calibre27">Time until all matter decays to iron</td><td class="calibre27">10<sup class="calibre19">1026</sup> years</td></tr>
<tr class="calibre25"><td class="calibre28">Time until all matter collapses to black holes</td><td class="calibre28">10<sup class="calibre19">1076</sup> years</td></tr>
</tbody></table>

<div class="calibre6" id="calibre_pb_2"></div>
</div>






</body></html>
