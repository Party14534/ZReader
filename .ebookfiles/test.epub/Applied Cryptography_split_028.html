<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Applied Cryptography, Second Edition: Protocols, Algorithms, and Source Code in C</title>
    <meta content="Bruce Schneier" name="author"/>
    <meta content="An introduction to cryptography." name="description"/>
    <meta content="programming,cryptography" name="keywords"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="book" class="calibre1">
<h1 class="chapter" id="24">Chapter 24 <br class="calibre3"/>
Example Implementations</h1>

<p class="calibre9">It’s one thing to design protocols and algorithms, but another thing to field
them in operational systems. In theory, theory and practice are the same; in
practice they are different. Often ideas that look good on paper don’t work in
real life. Maybe the bandwidth requirements are too large; maybe the protocol
is too slow. <a href="Applied%20Cryptography_split_012.html#10" class="calibre5 pcalibre">Chapter 10</a> discusses some of the issues related to using
cryptography; this chapter gives examples of how it has been done in practice.</p>

<h3 id="24.1" class="calibre7">24.1 IBM Secret-Key Management Protocol</h3>

<p class="calibre9">In the late 1970s IBM developed a complete key management system for
communications and file security on a computer network, using only
symmetric cryptography [<a href="Applied%20Cryptography_split_035.html#r515" class="calibre5 pcalibre">515</a>,<a href="Applied%20Cryptography_split_036.html#r1027" class="calibre5 pcalibre">1027</a>]. This protocol is less important in the
actual mechanisms and more in its overall philosophy: By automating the
generation, distribution, installation, storage, changing, and destruction of
keys, the protocol went a long way to ensure the security of the underlying
cryptographic algorithms.</p>

<p class="calibre9">This protocol provides three things: secure communications between a server
and several terminals, secure file storage at the server, and secure
communication among servers. The protocol doesn’t really provide for direct
terminal-to-terminal communication, although it can be modified to do that.</p>

<p class="calibre9">Each server on the network is attached to a cryptographic facility, which does
all of the encrypting and decrypting. Each server has a <b class="calibre10">Master Key</b>, <i class="calibre12">KM</i><sub class="calibre15">0</sub>, and two variants, <i class="calibre12">KM</i><sub class="calibre15">1</sub> and <i class="calibre12">KM</i><sub class="calibre15">2</sub>, both of which are simple variants of <i class="calibre12">KM</i><sub class="calibre15">0</sub>. These keys are used to encrypt other keys and to generate new keys. Each terminal
has a <b class="calibre10">Master Terminal Key</b>, <i class="calibre12">KMT</i>, which is used to exchange keys with other terminals.</p>

<p class="calibre9">The servers store <i class="calibre12">KMT</i>, encrypted with <i class="calibre12">KM</i><sub class="calibre15">1</sub>. All other keys, such as those used to encrypt files of keys (called <i class="calibre12">KNF</i>), are stored in encrypted form under <i class="calibre12">KM</i><sub class="calibre15">2</sub>. The master key, <i class="calibre12">KM</i><sub class="calibre15">0</sub>, is stored in some nonvolatile security module.
Today that could be either a ROM key or a magnetic card, or it could be typed
in by the user (probably as a text string and then key crunched). <i class="calibre12">KM</i><sub class="calibre15">1</sub> and <i class="calibre12">KM</i><sub class="calibre15">2</sub>
are not stored anywhere in the system, but are computed from <i class="calibre12">KM</i><sub class="calibre15">0</sub> whenever
they are needed. Session keys, for communication among servers, are
generated with a pseudo-random process in the server. Keys to encrypt files
for storage (<i class="calibre12">KNF</i>) are generated in the same manner.</p>

<p class="calibre9">The heart of the protocol is a tamper-resistant module, called a <b class="calibre10">cryptographic</b>
<b class="calibre10">facility</b>. At both the server and the terminal, all encryption and decryption
takes place within this facility. The most important keys, those used to
generate the actual encryption keys, are stored in this module. These keys can
never be read once they are stored. And they are tagged by use: A key
dedicated for one purpose cannot accidentally be used for another. This
concept of <b class="calibre10">key control vectors</b> is probably the most significant contribution of this system. Donald Davies and William Price discuss this key management
protocol in detail [<a href="Applied%20Cryptography_split_035.html#r435" class="calibre5 pcalibre">435</a>].</p>

<h4 class="calibre8">A Variation</h4>

<p class="calibre9">A variation on this scheme of master and session keys can be found in [<a href="Applied%20Cryptography_split_036.html#r1478" class="calibre5 pcalibre">1478</a>].
It’s built around network nodes with key notarization facilities that serve local
terminals. It is designed to:</p>

<ul class="calibre13">

<li class="calibre14">Secure two-way communication between any two terminal users.
</li>
<li class="calibre14">Secure communications using encrypted mail.
</li>
<li class="calibre14">Provide personal file protection.
</li>
<li class="calibre14">Provide a digital signature capability.
</li>

</ul>

<p class="calibre9">For communication and file transfer among users, the scheme uses keys
generated in the key notarization facility and sent to the users encrypted under
a master key. The identities of the users are incorporated with the key, to
provide evidence that the session key has been used between a particular pair
of users. This <b class="calibre10">key notarization</b> feature is central to the system. Although the
system does not use public-key cryptography, it has a digital-signature-like
capability: A key could have only come from a particular source and could
only be read at a particular destination.</p>

<h3 id="24.2" class="calibre7">24.2 MITRENET</h3>

<p class="calibre9">One of the earliest implementations of public-key cryptography was the
experimental system MEMO (MITRE Encrypted Mail Office). MITRE is a
DoD contractor, a government think tank, and an all-around bunch of smart
guys. MEMO was a secure electronic mail system for users in the MITRENET
network, using public-key cryptography for key exchange and DES for file
encryption.</p>

<p class="calibre9">In the MEMO system, all public keys are stored in a Public Key Distribution
Center, which is a separate node on the network. They are stored in an
EPROM to prevent anyone from changing them. Private keys are generated by
users or by the system.</p>

<p class="calibre9">For a user to send secure messages, the system first establishes a secure
communications path with the Public Key Distribution Center. The user
requests a file of all public keys from the Center. If the user passes an
identification test using his private key, the Center sends this list to the user’s
workstation. The list is encrypted using DES to ensure file integrity.</p>

<p class="calibre9">The implementation uses DES to encrypt messages. The system generates a
random DES key for file encryption; the user encrypts the file with the DES
key and encrypts the DES key with the recipient’s public key. Both the
DES-encrypted file and the public-key-encrypted key are sent to the recipient.</p>

<p class="calibre9">MEMO makes no provision for lost keys. There is some provision for integrity
checking of the messages, using checksums. No authentication is built into the
system.</p>

<p class="calibre9">The particular public-key implementation used for this
system — Diffie-Hellman key exchange over GF(2<sup class="calibre19">127</sup>) — was proven insecure
before the system was implemented (see <a href="Applied%20Cryptography_split_014.html#11.6" class="calibre5 pcalibre">Section 11.6</a>), although it is easy to
modify the system to use larger numbers. MEMO was intended mainly for
experimental purposes and was never made operational on the real
MITRENET system.</p>

<h3 id="24.3" class="calibre7">24.3 ISDN</h3>

<p class="calibre9">Bell-Northern Research developed a prototype secure Integrated Services
Digital Network (ISDN) telephone terminal [<a href="Applied%20Cryptography_split_035.html#r499" class="calibre5 pcalibre">499</a>,<a href="Applied%20Cryptography_split_036.html#r1192" class="calibre5 pcalibre">1192</a>,<a href="Applied%20Cryptography_split_035.html#r493" class="calibre5 pcalibre">493</a>,<a href="Applied%20Cryptography_split_035.html#r500" class="calibre5 pcalibre">500</a>]. As a
telephone, it was never developed beyond prototype. The resulting product
was the Packet Data Security Overlay. The terminal uses Diffie-Hellman key
exchange, RSA digital signatures, and DES data encryption; it can transmit
and receive voice and data at 64 kilobits per second.</p>

<h4 class="calibre8">Keys</h4>

<p class="calibre9">A long-term public-key/private-key key pair is embedded in the phone. The
private key is stored in a tamper-resistant area of the phone. The public key
serves as the identification of the phone. These keys are part of the phone itself
and cannot be altered in any way.</p>

<p class="calibre9">Additionally, two other public keys are stored in the phone. One of these keys
is the owner’s public key. This key is used to authenticate commands from the
owner and can be changed via a command signed by the owner. In this way an
owner can transfer ownership of the phone to someone else.</p>

<p class="calibre9">The public key of the network is also stored in the phone. This key is used to
authenticate commands from the network’s key management facility and to
authenticate calls from other users on the network. This key can also be
changed via a signed command from the owner. This permits the owner to
move his phone from one network to another.</p>

<p class="calibre9">These keys are considered long-term keys: rarely, if ever, changed. A
short-term public-key/private-key key pair is also stored on the phone. These
are encapsulated in a certificate signed by the key management facility. When
two phones set up a call, they exchange certificates. The public key of the
network authenticates these certificates.</p>

<p class="calibre9">This exchange and verification of certificates only sets up a secure call from
phone to phone. To set up a secure call from person to person, the protocol has
an additional piece. The owner’s private key is stored on a hardware <b class="calibre10">ignition</b>
<b class="calibre10">key</b>, which is inserted into the telephone by the owner. This ignition key
contains the owner’s private key, encrypted under a secret password known
only by the owner (not by the phone, not by the network’s key management
facility, not by anybody). It also contains a certificate signed by the network’s
key management facility that contains the owner’s public key and some
identifying information (name, company, job title, security clearance, favorite
pizza toppings, sexual preference, or whatever). This is also encrypted. To
decrypt this information and enter it into the phone, the owner types his secret
password on the phone’s keypad. After the phone uses this information to set
up calls, it is erased after the owner removes his ignition key.</p>

<p class="calibre9">The phone also stores a set of certificates from the network’s key management
facility. These certificates authorize particular users to use particular phones.</p>

<h4 class="calibre8">Calling</h4>

<p class="calibre9">A call from Alice to Bob works as follows.</p>

<ol class="calibre17">

<li class="calibre14">Alice inserts her ignition key into the phone and enters her
password.
</li>
<li class="calibre14">The phone interrogates the ignition key to determine Alice’s identity
and gives Alice a dial tone.
</li>
<li class="calibre14">The phone checks its set of certificates to ensure that Alice is
authorized to use the particular phone.
</li>
<li class="calibre14">Alice dials the number; the phone places the call.
</li>
<li class="calibre14">The two telephones use a public-key cryptography key-exchange
protocol to generate a unique and random session key. All subsequent
protocol steps are encrypted using this key.
</li>
<li class="calibre14">Alice’s phone transmits its certificate and user authentication.
</li>
<li class="calibre14">Bob’s phone authenticates the signatures on both the certificate and
the user authentication using the network’s public key.
</li>
<li class="calibre14">Bob’s phone initiates a challenge-and-reply sequence. It demands
real-time signed responses to time-dependent challenges. (This prevents
an adversary from using certificates copied from a previous exchange.)
One response must be signed by Alice’s phone’s private key; another
must be signed by Alice’s private key.
</li>
<li class="calibre14">Bob’s phone rings, unless he is already on the phone.
</li>
<li class="calibre14">If Bob is home, he inserts his ignition key into the phone. His
phone interrogates the ignition key and checks Bob’s certificate as in
steps (2) and (3).
</li>
<li class="calibre14">Bob transmits his certificate and user authentication.
</li>
<li class="calibre14">Alice’s phone authenticates Bob’s signatures as in step (7), and
initiates a challenge-and-reply sequence as in step (8).
</li>
<li class="calibre14">Both phones display the identity of the other user and phone on
their displays.
</li>
<li class="calibre14">The secure conversation begins.
</li>
<li class="calibre14">When one party hangs up, the session key is deleted, as are the
certificates Bob’s phone received from Alice’s phone and the
certificates Alice’s phone received from Bob’s phone.
</li>

</ol>

<p class="calibre9">Each DES key is unique to each call. It exists only inside the two phones for
the duration of the call and is destroyed immediately afterward. If an adversary
captures one or both of the phones involved in the call, he will not be able to
decrypt any previous call between the two phones.</p>

<h3 id="24.4" class="calibre7">24.4 STU-III</h3>

<p class="calibre9">STU stands for “Secure Telephone Unit, ” an NSA-designed secure phone.
The unit is about the size and shape of a conventional telephone, and can be
used as such. The phones are also tamper-resistant, enough so that they are
unclassified if unkeyed. They also have a data port and can be used to secure
modem traffic as well as voice [<a href="Applied%20Cryptography_split_036.html#r1133" class="calibre5 pcalibre">1133</a>].</p>

<p class="calibre9">Whitfield Diffie described the STU-III in [<a href="Applied%20Cryptography_split_035.html#r494" class="calibre5 pcalibre">494</a>]:</p>

<p class="quote">To make a call with a STU-III, the caller first places an ordinary
call to another STU-III, then inserts a key-shaped device
containing a cryptographic variable and pushes a “go secure”
button. After an approximately 15-second wait for cryptographic
setup, each phone shows information about the identity and
clearance of the other party on its display and the call can
proceed.
<br class="calibre3"/><br class="calibre3"/>
In an unprecedented move, Walter Deeley, NSA’s deputy director
for communications security, announced the STU-III or Future
Secure Voice System in an exclusive interview given to <i class="calibre12">The New York Times</i> [<a href="Applied%20Cryptography_split_035.html#r282" class="calibre5 pcalibre">282</a>]. 
The objective of the new system was primarily
to provide secure voice and low-speed data communications for
the U.S. Defense Department and its contractors. The interview
didn’t say much about how it was going to work, but gradually
the word began to leak out. The new system was using public key.
<br class="calibre3"/><br class="calibre3"/>
The new approach to key management was reported early on [<a href="Applied%20Cryptography_split_035.html#r68" class="calibre5 pcalibre">68</a>]
and one article spoke of phones being “reprogrammed once a year
by secure telephone link, ” a turn of phrase strongly suggestive of
a certificate passing protocol, similar to that described [in <a href="#24.3" class="calibre5 pcalibre">Section 24.3</a>], 
that minimizes the need for phones to talk to the key
management center. Recent reports have been more forthcoming,
speaking of a key management system called FIREFLY that
[<a href="Applied%20Cryptography_split_036.html#r1341" class="calibre5 pcalibre">1341</a>] “evolved from public key technology and is used to
establish pair-wise traffic encryption keys.” Both this description
and testimony submitted to the U.S. Congress by Lee Neuwirth of
Cylink [<a href="Applied%20Cryptography_split_036.html#r1164" class="calibre5 pcalibre">1164</a>] suggest a combination of key exchange and
certificates similar to that used in the ISDN secure phone and it is
plausible that FIREFLY too is based on exponentiation.</p>

<p class="calibre9">STU-IIIs are manufactured by AT&amp;T and GE. Somewhere between 300,000 and 
400,000 have been fielded through 1994. A new version, the Secure
Terminal Equipment (STE), will work on ISDN lines.</p>

<h3 id="24.5" class="calibre7">24.5 Kerberos</h3>

<p class="calibre9">Kerberos is a trusted third-party authentication protocol designed for TCP/IP
networks. A Kerberos service, sitting on the network, acts as a trusted
arbitrator. Kerberos provides secure network authentication, allowing a person
to access different machines on the network. Kerberos is based on symmetric
cryptography (DES as implemented, but other algorithms could be used
instead). Kerberos shares a different secret key with every entity on the
network and knowledge of that secret key equals proof of identity.</p>

<p class="calibre9">Kerberos was originally developed at MIT for Project Athena. The Kerberos
model is based on Needham-Schroeder’s trusted third-party protocol (see
<a href="Applied%20Cryptography_split_004.html#3.3" class="calibre5 pcalibre">Section 3.3</a>) [<a href="Applied%20Cryptography_split_036.html#r1159" class="calibre5 pcalibre">1159</a>]. The original version of Kerberos, Version 4, is specified
in [<a href="Applied%20Cryptography_split_036.html#r1094" class="calibre5 pcalibre">1094</a>,<a href="Applied%20Cryptography_split_036.html#r1499" class="calibre5 pcalibre">1499</a>]. (Versions 1 through 3 were internal development versions.)
Version 5, modified from Version 4, is specified in [<a href="Applied%20Cryptography_split_036.html#r876" class="calibre5 pcalibre">876</a>,<a href="Applied%20Cryptography_split_036.html#r877" class="calibre5 pcalibre">877</a>,<a href="Applied%20Cryptography_split_036.html#r878" class="calibre5 pcalibre">878</a>]. The best
overview of Kerberos is [<a href="Applied%20Cryptography_split_036.html#r1163" class="calibre5 pcalibre">1163</a>]. Other survey articles are [<a href="Applied%20Cryptography_split_036.html#r1384" class="calibre5 pcalibre">1384</a>,<a href="Applied%20Cryptography_split_036.html#r1493" class="calibre5 pcalibre">1493</a>], and
two good articles on using Kerberos in the real world are [<a href="Applied%20Cryptography_split_035.html#r781" class="calibre5 pcalibre">781</a>,<a href="Applied%20Cryptography_split_035.html#r782" class="calibre5 pcalibre">782</a>].</p>

<h4 class="calibre8">The Kerberos Model</h4>

<p class="calibre9">The basic Kerberos protocol was outlined in <a href="Applied%20Cryptography_split_004.html#3.3" class="calibre5 pcalibre">Section 3.3</a>. In the Kerberos
model, there are entities — clients and servers — sitting on the network. Clients
can be users, but can also be independent software programs that need to do
things: download files, send messages, access databases, access printers,
obtain administrative privileges, whatever.</p>

<p class="calibre9">Kerberos keeps a database of clients and their secret keys. For a human user,
the secret key is an encrypted password. Network services requiring
authentication, as well as clients who wish to use these services, register their
secret key with Kerberos.</p>

<p class="calibre9">Because Kerberos knows everyone’s secret key, it can create messages that
convince one entity of another entity’s identity. Kerberos also creates session
keys which are given to a client and a server (or to two clients) and no one
else. A session key is used to encrypt messages between the two parties, after
which it is destroyed.</p>

<p class="calibre9">Kerberos uses DES for encryption. Kerberos Version 4 provided a nonstandard
mode for authentication. This mode is weak: It fails to detect certain changes
to the ciphertext (see <a href="Applied%20Cryptography_split_011.html#9.10" class="calibre5 pcalibre">Section 9.10</a>). Kerberos Version 5 uses CBC mode.</p>

<h4 class="calibre8">How Kerberos Works</h4>

<p class="calibre9">This section discusses Kerberos Version 5. I will outline the differences
between Version 4 and Version 5 further on. The Kerberos protocol is
straightforward (see Figure 24.1). A client requests a ticket for a
<b class="calibre10">Ticket-Granting Service</b> (<b class="calibre10">TGS</b>) from Kerberos. This ticket is sent to the
client, encrypted in the client’s secret key. To use a particular server, the client
requests a ticket for that server from the TGS. Assuming everything is in
order, the TGS sends the ticket back to the client. The client then presents this
ticket to the server along with an authenticator. Again, if there’s nothing wrong
with the client’s credentials, the server lets the client have access to the
service.</p>

<div class="figure" id="figure-24-1">
<div class="image1">
<p class="calibre9"><img src="ac-figure-24-1.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 24.1</b> Kerberos authentication steps.</i></p>
</div>

<h4 class="calibre8">Credentials</h4>

<p class="calibre9">Kerberos uses two types of credentials: <b class="calibre10">tickets</b> and <b class="calibre10">authenticators</b>. (The rest of this section uses the notation used in Kerberos documents — see Table 24.1.)
A ticket is used to pass securely to the server the identity of the client for
whom the ticket was issued. It also contains information that the server can use
to ensure that the client using the ticket is the same client to whom the ticket
was issued. An authenticator is an additional credential, presented with the
ticket.</p>

<table class="data-table1" id="table-24-1">
<caption class="calibre67">Table 24.1 - Kerberos Table of Abbreviations</caption>
<tbody class="calibre24"><tr class="calibre68"><td class="calibre89"><i class="calibre12">c</i></td><td class="calibre89">= client</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">s</i></td><td class="calibre61">= server</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">a</i></td><td class="calibre61">= client’s network address</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">v</i></td><td class="calibre61">= beginning and ending validity time for a ticket</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">t</i></td><td class="calibre61">= timestamp</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">K<sub class="calibre15">x</sub></i></td><td class="calibre61">= <i class="calibre12">x</i>‘s secret key</td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">K<sub class="calibre15">x, y</sub></i></td><td class="calibre61">= session key for <i class="calibre12">x</i> and <i class="calibre12">y</i></td></tr>
<tr class="calibre25"><td class="calibre61">{<i class="calibre12">m</i>}<i class="calibre12">K<sub class="calibre15">x</sub></i></td><td class="calibre61">= <i class="calibre12">m</i> encrypted in <i class="calibre12">x</i>‘s secret key</td></tr>
<tr class="calibre71"><td class="calibre78"><i class="calibre12">T<sub class="calibre15">x, y</sub></i></td><td class="calibre78">= <i class="calibre12">x</i>‘s ticket to use <i class="calibre12">y</i></td></tr>
<tr class="calibre25"><td class="calibre61"><i class="calibre12">A<sub class="calibre15">x, y</sub></i></td><td class="calibre61">= authenticator from <i class="calibre12">x</i> to <i class="calibre12">y</i></td></tr>
</tbody></table>

<p class="calibre39">A Kerberos ticket takes this form:</p>

<p class="math"><i class="calibre12">T<sub class="calibre15">c, s</sub></i> = <i class="calibre12">s</i>,{<i class="calibre12">c, a, v, K<sub class="calibre15">c, s</sub></i>}<i class="calibre12">K<sub class="calibre15">s</sub></i>
</p>

<p class="calibre9">A ticket is good for a single server and a single client. It contains the client’s
name and network address, the server’s name, a timestamp, and a session key.
This information is encrypted with the server’s secret key. Once the client gets
this ticket, she can use it multiple times to access the server — until the ticket
expires. The client cannot decrypt the ticket (she does not know the server’s
secret key), but she can present it to the server in its encrypted form. No one
listening on the network can read or modify the ticket as it passes through the
network.</p>

<p class="calibre9">A Kerberos authenticator takes this form:</p>

<p class="math"><i class="calibre12">A<sub class="calibre15">c, s</sub></i> = {<i class="calibre12">c, t, key</i>}<i class="calibre12">K<sub class="calibre15">c, s</sub></i>
</p>

<p class="calibre9">The client generates it every time she wishes to use a service on the server.
The authenticator contains the client’s name, a timestamp, and an optional
additional session key, all encrypted with the session key shared between the
client and the server. Unlike a ticket, it can only be used once. However, since
the client can generate authenticators as needed (it knows the shared secret
key), this is not a problem.</p>

<p class="calibre9">The authenticator serves two purposes. First, it contains some plaintext
encrypted in the session key. This proves that it also knows the key. Just as
important, the sealed plaintext includes the timestamp. An eavesdropper who
records both the ticket and the authenticator can’t replay them two days later.</p>

<h4 class="calibre8">Kerberos Version 5 Messages</h4>

<p class="calibre9">Kerberos Version 5 has five messages (see Figure 24.1):</p>

<ol class="calibre17">

<li class="calibre14">Client to Kerberos: <i class="calibre12">c, tgs</i>
</li>
<li class="calibre14">Kerberos to client: { <i class="calibre12">K<sub class="calibre15">c, tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">c</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">tgs</sub></i>
</li>
<li class="calibre14">Client to TGS:
{ <i class="calibre12">A<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, tgs</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">tgs</sub></i>
</li>
<li class="calibre14">TGS to client:
{ <i class="calibre12">K<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, tgs</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">s</sub></i>
</li>
<li class="calibre14">Client to server:
{ <i class="calibre12">A<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, s</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">s</sub></i>
</li>

</ol>

<p class="calibre9">These will now be discussed in detail.</p>

<h4 class="calibre8">Getting an Initial Ticket</h4>

<p class="calibre9">The client has one piece of information that proves her identity: her password.
Obviously we don’t want her to send this password over the network. The
Kerberos protocol minimizes the chance that this password will be
compromised, while at the same time not allowing a user to properly
authenticate herself unless she knows the password.</p>

<p class="calibre9">The client sends a message containing her name and the name of her TGS
server to the Kerberos authentication server. (There can be many TGS
servers.) In reality, the user probably just enters her name into the system and
the login program sends the request.</p>

<p class="calibre9">The Kerberos authentication server looks up the client in his database. If the
client is in the database, Kerberos generates a session key to be used between
her and the TGS. This is called a <b class="calibre10">Ticket Granting Ticket</b> (<b class="calibre10">TGT</b>). Kerberos encrypts that session key with the client’s secret key. Then it creates a TGT for
the client to authenticate herself to the TGS, and encrypts that in the TGS’s
secret key. The authentication server sends both of these encrypted messages
back to the client.</p>

<p class="calibre9">The client now decrypts the first message and retrieves the session key. The
secret key is a one-way hash of her password, so a legitimate user will have no
trouble doing this. If the user were an imposter, he would not know the correct
password and therefore could not decrypt the response from the Kerberos
authentication server. Access would be denied and he wouldn’t be able to get
the ticket or the session key.</p>

<p class="calibre9">The client saves the TGT and session key and erases the password and the
one-way hash. This information is erased to reduce the chance of compromise.
If an adversary manages to copy the client’s memory, he will only get the TGT
and the session key. These are valuable pieces of information, but only during
the lifetime of the TGT. After the TGT expires, they will be worthless.</p>

<p class="calibre9">The client can now prove her identity to the TGS for the lifetime of the TGT.</p>

<h4 class="calibre8">Getting Server Tickets</h4>

<p class="calibre9">A client has to obtain a separate ticket for each service she wants to use. The
TGS grants tickets for individual servers.</p>

<p class="calibre9">When a client needs a ticket that she does not already have, she sends a request
to the TGS. (In reality, the program would do this automatically, and it would
be invisible to the user.)</p>

<p class="calibre9">The TGS, upon receiving the request, decrypts the TGT with his secret key.
Then he uses the session key included in the TGT to decrypt the authenticator.
Finally, he compares the information in the authenticator with the information
in the ticket, the client’s network address with the address the request was sent
from, and the timestamp with the current time. If everything matches, he
allows the request to proceed.</p>

<p class="calibre9">Checking timestamps assumes that all machines have synchronized clocks, at
least to within several minutes. If the time in the request is too far in the future
or the past, the TGS treats the request as an attempt to replay a previous
request. The TGS should also keep track of all live authenticators, because past
requests can have timestamps that are still valid. Another request with the
same ticket and timestamp as one already received can be ignored.</p>

<p class="calibre9">The TGS responds to a valid request by returning a valid ticket for the client to
present to the server. The TGS also creates a new session key for the client and
the server, encrypted with the session key shared by the client and the TGS.
Both of these messages are then sent back to the client. The client decrypts the
message and extracts the session key.</p>

<h4 class="calibre8">Requesting a Service</h4>

<p class="calibre9">Now the client is ready to authenticate herself to the server. She creates a
message very similar to the one sent to the TGS (which makes sense, since the
TGS is a service).</p>

<p class="calibre9">The client creates an authenticator, consisting of her name and network
address, and a timestamp, encrypted with the session key for her and the server
that the TGS generated. The request consists of the ticket received from
Kerberos (already encrypted with the server’s secret key) and the encrypted
authenticator.</p>

<p class="calibre9">The server decrypts and checks the ticket and the authenticator, as discussed
previously, and also checks the client’s address and the timestamp. If
everything checks out, the server knows that, according to Kerberos, the client
is who she says she is.</p>

<p class="calibre9">For applications that require mutual authentication, the server sends the client
back a message consisting of the timestamp, encrypted with the session key.
This proves that the server knew his secret key and could decrypt the ticket
and therefore the authenticator.</p>

<p class="calibre9">The client and the server can encrypt future messages with the shared key, if
desired. Since only they share this key, they both can assume that a recent
message encrypted in that key originated with the other party.</p>

<h4 class="calibre8">Kerberos Version 4</h4>

<p class="calibre9">The previous sections discussed Kerberos Version 5. In the messages and the
construction of the tickets and authenticators, Version 4 is slightly different.</p>

<p class="calibre9">In Kerberos Version 4, the five messages looked like:</p>

<ol class="calibre17">

<li class="calibre14">Client to Kerberos:
<i class="calibre12">c, tgs</i>
</li>
<li class="calibre14">Kerberos to client:
{ <i class="calibre12">K<sub class="calibre15">c, tgs</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">c</sub></i>
</li>
<li class="calibre14">Client to TGS:
{ <i class="calibre12">A<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, tgs</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, tgs</sub></i>} <i class="calibre12">K<sub class="calibre15">tgs</sub>, s</i>
</li>
<li class="calibre14">TGS to client:
{ <i class="calibre12">K<sub class="calibre15">c, s</sub></i>, { <i class="calibre12">T<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, tgs</sub></i>
</li>
<li class="calibre14">Client to server: { <i class="calibre12">A<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">c, s</sub>, </i> { <i class="calibre12">T<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">s</sub></i> <br class="calibre3"/>
<i class="calibre12">T<sub class="calibre15">c, s</sub></i> = { <i class="calibre12">s, c, a, v, l, K<sub class="calibre15">c, s</sub></i>} <i class="calibre12">K<sub class="calibre15">s</sub></i> <br class="calibre3"/>
<i class="calibre12">A<sub class="calibre15">c, s</sub></i> = { <i class="calibre12">c, a, t</i>} <i class="calibre12">K<sub class="calibre15">c, s</sub></i>
</li>

</ol>

<p class="calibre9">Messages 1, 3, and 5 are identical. The double encryption of the ticket in steps
2 and 4 has been removed in Version 5. The Version 5 ticket adds the
possibility of multiple addresses, and it replaces a “lifetime” field, <i class="calibre12">l</i>, with a beginning and ending time. The Version 5 authenticator adds the option of
including an additional key.</p>

<h4 class="calibre8">Security of Kerberos</h4>

<p class="calibre9">Steve Bellovin and Michael Merritt discussed several potential security
vulnerabilities of Kerberos [<a href="Applied%20Cryptography_split_035.html#r108" class="calibre5 pcalibre">108</a>]. Although this paper was written about the
Version 4 protocols, many of their comments also apply to Version 5.</p>

<p class="calibre9">It may be possible to cache and replay old authenticators. Although
timestamps are supposed to prevent this, replays can be done during the
lifetime of the ticket. Servers are supposed to store all valid tickets to prevent
replays, but this is not always possible. And ticket lifetimes can be long; eight
hours is typical.</p>

<p class="calibre9">Authenticators rely on the fact that all the clocks in the network are more or
less synchronized. If a host can be fooled about the correct time, then an old
authenticator can be replayed without any problem. Most network time
protocols are insecure, so this can be a serious problem.</p>

<p class="calibre9">Kerberos is also vulnerable to password-guessing attacks. An intruder can
collect tickets and then try to decrypt them. Remember that the average user
doesn’t usually choose good passwords. If Mallory collects enough tickets, his
chances of recovering a password are good.</p>

<p class="calibre9">Perhaps the most serious attack involves malicious software. The Kerberos
protocols rely on the fact that the Kerberos software is trustworthy. There’s
nothing to stop Mallory from surreptitiously replacing all client Kerberos
software with a version that, in addition to completing the Kerberos protocols,
records passwords. This is a problem with any cryptographic software package
on an insecure computer, but the widespread use of Kerberos in these
environments makes it a particularly tempting target.</p>

<p class="calibre9">Enhancements to Kerberos are in the works, including an implementation of
public-key cryptography and a smart-card interface for key management.</p>

<h4 class="calibre8">Licenses</h4>

<p class="calibre9">Kerberos is not in the public domain, but MIT’s code is freely available.
Actually implementing it into a working UNIX environment is another story.
Several companies sell versions of Kerberos, but you can get a good version
free from <code class="calibre18">Cygnus Support, 814 University Ave., Palo Alto, CA, 94301; (415)
322-3811; fax: (415) 322-3270</code>.</p>

<h3 id="24.6" class="calibre7">24.6 KryptoKnight</h3>

<p class="calibre9">KryptoKnight (Kryptonite — get it?) is an authentication and key distribution
system designed by IBM. It is a secret-key protocol and uses either DES in
CBC mode (see <a href="Applied%20Cryptography_split_011.html#9.3" class="calibre5 pcalibre">Section 9.3</a>) or a modified version of MD5 (see <a href="Applied%20Cryptography_split_021.html#18.5" class="calibre5 pcalibre">Section 18.5</a>).</p>

<p class="calibre9">KryptoKnight supports four security services:</p>

<ul class="calibre13">

<li class="calibre14">User authentication (called single sign-on)
</li>
<li class="calibre14">Two-party authentication
</li>
<li class="calibre14">Key distribution
</li>
<li class="calibre14">Authentication of data origin and content
</li>

</ul>

<p class="calibre9">From a user’s perspective, KryptoKnight is similar to Kerberos. Some
differences are:</p>

<ul class="calibre13">

<li class="calibre14">KryptoKnight uses a hash function for authentication and encrypting
tickets.
</li>
<li class="calibre14">KryptoKnight does not rely on synchronized clocks; it uses nonces
for challenges (see <a href="Applied%20Cryptography_split_004.html#3.3" class="calibre5 pcalibre">Section 3.3</a>).
</li>
<li class="calibre14">If Alice wishes to communicate with Bob, KryptoKnight has the
option of allowing Alice to send a message to Bob and then for Bob to
initiate the key exchange protocol.
</li>

</ul>

<p class="calibre9">KryptoKnight has tickets and authenticators, just like Kerberos. It has TGSs,
but KryptoKnight calls them authentication servers. KryptoKnight’s designers
spent considerable effort minimizing the number of messages, lengths of
messages, and amount of encryption. For further information on
KryptoKnight, read [<a href="Applied%20Cryptography_split_036.html#r1110" class="calibre5 pcalibre">1110</a>,<a href="Applied%20Cryptography_split_035.html#r173" class="calibre5 pcalibre">173</a>,<a href="Applied%20Cryptography_split_035.html#r174" class="calibre5 pcalibre">174</a>,<a href="Applied%20Cryptography_split_035.html#r175" class="calibre5 pcalibre">175</a>].</p>

<h3 id="24.7" class="calibre7">24.7 SESAME</h3>

<p class="calibre9">SESAME stands for Secure European System for Applications in a
Multivendor Environment. It’s a European Community security project, 50
percent funded by RACE (see <a href="Applied%20Cryptography_split_029.html#25.7" class="calibre5 pcalibre">Section 25.7</a>), whose primary objective is
producing technology for user authentication with distributed access control.
Think of it as kind of a European version of Kerberos. It’s a two-part project:
Stage one is a basic prototype of the architecture, and stage two is a set of
commercial projects. The three companies with the greatest hand in
development are ICL in the United Kingdom, Siemens in Germany, and Bull
in France.</p>

<p class="calibre9">SESAME is an authentication and key-exchange system [<a href="Applied%20Cryptography_split_035.html#r361" class="calibre5 pcalibre">361</a>,<a href="Applied%20Cryptography_split_036.html#r1248" class="calibre5 pcalibre">1248</a>,<a href="Applied%20Cryptography_split_035.html#r797" class="calibre5 pcalibre">797</a>,<a href="Applied%20Cryptography_split_036.html#r1043" class="calibre5 pcalibre">1043</a>]. 
It uses the Needham-Schroeder protocol, with public-key cryptography
to communicate between different security domains. The system is seriously
flawed in several respects. Instead of using a real encryption algorithm, they
use XOR with a 64-bit key size. Even worse, they use XOR in CBC mode,
which leaves half the plaintext unencrypted. In their defense, they planned on
using DES until the French government complained; they validated the code
with DES but then removed it, and expect people to add it back. I am
unimpressed nonetheless.</p>

<p class="calibre9">Authentication in SESAME is a function on the first block of a message, not
on the entire message. This has the effect of authenticating “Dear Sir” and not
the body of a letter. Key generation consists of two calls to the UNIX rand
function, which isn’t very random. SESAME uses crc32 and MD5 as one-way
hash functions. And of course, SESAME is vulnerable to Kerberos-like
password-guessing.</p>

<h3 id="24.8" class="calibre7">24.8 IBM Common Cryptographic Architecture</h3>

<p class="calibre9">The Common Cryptographic Architecture (CCA) was designed and developed
by IBM to provide cryptographic primitives for confidentiality, integrity, key
management, and personal identification number (PIN) processing [<a href="Applied%20Cryptography_split_035.html#r751" class="calibre5 pcalibre">751</a>,<a href="Applied%20Cryptography_split_035.html#r784" class="calibre5 pcalibre">784</a>,<a href="Applied%20Cryptography_split_036.html#r1025" class="calibre5 pcalibre">1025</a>,<a href="Applied%20Cryptography_split_036.html#r1026" class="calibre5 pcalibre">1026</a>,<a href="Applied%20Cryptography_split_036.html#r940" class="calibre5 pcalibre">940</a>,<a href="Applied%20Cryptography_split_035.html#r752" class="calibre5 pcalibre">752</a>]. 
Keys are managed by control vectors (CVs) (see
<a href="Applied%20Cryptography_split_010.html#8.5" class="calibre5 pcalibre">Section 8.5</a>). Every key has a CV XORed with it and is never separated from
the vector unless inside secure hardware. The CV is a data structure providing
an intuitive understanding of the privileges associated with a particular key.</p>

<p class="calibre9">The individual bits of the CV are defined to have specific meanings for using
and handling each key managed by CCA. The CV is carried with the encrypted
key in data structures called key tokens. Internal key tokens are used locally
and contain keys encrypted under the local master key (MK). External key
tokens are used to export and import encrypted keys between systems. Keys in
external key tokens are encrypted under key-encrypting keys (KEK). The
KEKs are managed in internal key tokens. Keys are separated according to
their permitted uses.</p>

<p class="calibre9">Key length is also specified and enforced using bits in the CV. Single length
keys are 56 bits and are used for such functions as privacy and message
authentication. Double length keys are 112 bits and are used for key
management, PIN functions, and other special uses. Keys can be required to be
DOUBLE-ONLY in which both the left and right halves of the key must be
different, DOUBLE in which the halves are permitted to be equal by chance,
SINGLE-REPLICATED in which the left and right halves are equal, or
SINGLE which contains only 56 bits. The CCA functions specify hardware
enforcement of certain key types to be used for some operations.</p>

<p class="calibre9">The CV is checked in a secure hardware processor: It must conform to the
permitted CCA rules for each CCA function. If the CV successfully passes the
test requirements, a variant of the KEK or MK is obtained by the XOR of the
KEK or MK with the CV, and the plaintext target key is recovered for use
internally with the CCA function. When new keys are generated, the CV
specifies the uses of the generated key. Those combinations of key types that
could be used in attacking the system are not generated or imported into a
CCA-compliant system.</p>

<p class="calibre9">CCA uses a combination of public-key cryptography and secret-key
cryptography for key distribution. The KDC shares a secret master key with
each user and encrypts session keys using that master key. Master keys are
distributed using public-key cryptography.</p>

<p class="calibre9">The system’s designers chose this hybrid approach for two reasons. The first is
performance. Public-key cryptography is computationally intensive; if session
keys are distributed using public-key cryptography, the system might bog
down. The second is backwards compatibility; this system can be overlaid on
existing secret-key schemes with minimal disruption.</p>

<p class="calibre9">CCA systems are designed to be interoperable. For systems that are non-CCA
compliant, a Control Vector Translate (CVXLT) function permits keys to be
passed between the two implementations. Initialization of the CVXLT function
requires dual control. Two individuals must set up the required translation
tables independently. Such dual control provides a high degree of assurance
concerning the integrity and pedigree of any keys introduced into the system.</p>

<p class="calibre9">A key of type DATA is provided for compatibility with other systems. A
DATA key is stored with a CV that identifies the key as a DATA key. DATA
keys can have broad uses and as such must be regarded with suspicion and
used with care. DATA keys may not be used for any key management
functions.</p>

<p class="calibre9">The Commercial Data Masking Facility (CDMF) provides an exportable
version of CCA. It has a special feature that reduces DES keys to an effective
40 bits for export (see <a href="Applied%20Cryptography_split_018.html#15.5" class="calibre5 pcalibre">Section 15.5</a>) [<a href="Applied%20Cryptography_split_035.html#r785" class="calibre5 pcalibre">785</a>].</p>

<h3 id="24.9" class="calibre7">24.9 ISO Authentication Framework</h3>

<p class="calibre9">Public-key cryptography has been recommended for use with the ISO
authentication framework, also known as the X.509 protocols [<a href="Applied%20Cryptography_split_035.html#r304" class="calibre5 pcalibre">304</a>]. This
framework provides for authentication across networks. Although no particular
algorithms are specified for either security or authentication, the specification
recommends RSA. There are provisions, however, for multiple algorithms and
hash functions. X.509 was initially issued in 1988. After public review and
comment, it was revised in 1993 to correct some security problems [<a href="Applied%20Cryptography_split_036.html#r1100" class="calibre5 pcalibre">1100</a>,<a href="Applied%20Cryptography_split_035.html#r750" class="calibre5 pcalibre">750</a>].</p>

<h4 class="calibre8">Certificates</h4>

<p class="calibre9">The most important part of X.509 is its structure for public-key certificates.
Each user has a distinct name. A trusted Certification Authority (CA) assigns a
unique name to each user and issues a signed certificate containing the name
and the user’s public key. Figure 24.2 shows an X.509 certificate [<a href="Applied%20Cryptography_split_035.html#r304" class="calibre5 pcalibre">304</a>].</p>

<div class="figure" id="figure-24-2">
<div class="image1">
<p class="calibre9"><img src="ac-figure-24-2.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 24.2</b> An X.509 certificate.</i></p>
</div>

<p class="calibre9">The version field identifies the certificate format. The serial number is unique
within the CA. The next field identifies the algorithm used to sign the
certificate, together with any necessary parameters. Issuer is the name of the
CA. The period of validity is a pair of dates; the certificate is valid during the
time period between the two. Subject is the name of the user. The subject’s
public key information includes the algorithm name, any necessary
parameters, and the public key. The last field is the CA’s signature.</p>

<p class="calibre9">If Alice wants to communicate with Bob, she first gets his certificate from a
database. Then she verifies its authenticity. If both share the same CA, this is
easy. Alice simply verifies the CA’s signature on Bob’s certificate.</p>

<p class="calibre9">If they use different CAs, it’s more complicated. Think of a tree structure, with
different CAs certifying other CAs and users. On the top is one master CA.
Each CA has a certificate signed by the CA above it, and by the CAs below it.
Alice uses these certificates to verify Bob’s certificate.</p>

<p class="calibre9">Figure 24.3 illustrates this. Alice’s certificate is certified by CA<sub class="calibre15"><i class="calibre22">A</i></sub> ; Bob’s is certified by CA<sub class="calibre15"><i class="calibre22">B</i></sub>. Alice knows CA<sub class="calibre15"><i class="calibre22">A</i></sub>’s public key. CA<sub class="calibre15"><i class="calibre22">C</i></sub> has a certificate signed by CA<sub class="calibre15"><i class="calibre22">A</i></sub>, so Alice can verify that. CA<sub class="calibre15"><i class="calibre22">D</i></sub> has a certificate signed by CA<sub class="calibre15"><i class="calibre22">C</i></sub>. CA<sub class="calibre15"><i class="calibre22">B</i></sub>
has a certificate signed by CA<sub class="calibre15"><i class="calibre22">D</i></sub>. And Bob’s certificate is signed by CA<sub class="calibre15"><i class="calibre22">B</i></sub>. By moving up the certification tree to a common point, in this case CA<sub class="calibre15"><i class="calibre22">D</i></sub>, and then down to Bob, Alice can verify Bob’s certificate.</p>

<div class="figure" id="figure-24-3">
<div class="image1">
<p class="calibre9"><img src="ac-figure-24-3.jpg" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 24.3</b> Sample certification hierarchy.</i></p>
</div>

<p class="calibre9">Certificates can be stored on databases around the network. Users can send
them to each other. When a certificate expires, it should be removed from any
public directories. The issuing CA, however, should maintain a copy of the
certificate. Should a dispute arise later, it will be required.</p>

<p class="calibre9">Certificates can also be revoked, either because the user’s key has been
compromised, the CA’s key has been compromised, or because the CA no
longer wants to certify the user. Each CA must maintain a list of all revoked
but not expired certificates. When Alice receives a new certificate, she should
check to see if it has been revoked. She can check a database of revoked keys
on the network, but more likely she will check a locally cached list of revoked
certificates. There are certainly possible abuses to this system; key revocation
is probably its weakest part.</p>

<h4 class="calibre8">Authentication Protocols</h4>

<p class="calibre9">Alice wants to communicate with Bob. First she goes to a database and obtains
what is called a <b class="calibre10">certification path</b> from Alice to Bob, and Bob’s public key.
At this point Alice can initiate either a one-way, two-way, or three-way
authentication protocol.</p>

<p class="calibre9">The one-way protocol is a single communication from Alice to Bob. It
establishes the identities of both Alice and Bob and the integrity of any
information communicated by Alice to Bob. It also prevents any replay attacks
on the communication.</p>

<p class="calibre9">The two-way protocol adds a reply from Bob. It establishes that Bob, and not
an imposter, sent the reply. It also establishes the secrecy of both
communications and prevents replay attacks.</p>

<p class="calibre9">Both the one-way and two-way protocols use timestamps. A three-way
protocol adds another message from Alice to Bob and obviates the need for
timestamps (and therefore authenticated time).</p>

<p class="calibre9">The one-way protocol is:</p>

<ol class="split">

<li class="pcalibre1 calibre30">Alice generates a random number, <i class="calibre32">R<sub class="calibre33">A</sub></i>.
</li>
<li class="pcalibre1 calibre30">Alice constructs a message, <i class="calibre32">M</i> = (<i class="calibre32">T<sub class="calibre33">A</sub></i>, <i class="calibre32">R<sub class="calibre33">A</sub></i>, <i class="calibre32">I<sub class="calibre33">B</sub></i>, <i class="calibre32">d</i>), where <i class="calibre32">T<sub class="calibre33">A</sub></i> is Alice’s timestamp, <i class="calibre32">I<sub class="calibre33">B</sub></i> is Bob’s identity, and <i class="calibre32">d</i> is an arbitrary piece of data. The data may be encrypted with Bob’s public key, <i class="calibre32">E<sub class="calibre33">B</sub></i>, for security.
</li>
<li class="pcalibre1 calibre30">Alice sends (<i class="calibre32">C<sub class="calibre33">A</sub></i>, <i class="calibre32">D<sub class="calibre33">A</sub></i>(<i class="calibre32">M</i>)) to Bob. (<i class="calibre32">C<sub class="calibre33">A</sub></i> is Alice’s certificate; <i class="calibre32">D<sub class="calibre33">A</sub></i> is Alice’s private key.)
</li>
<li class="pcalibre1 calibre30">Bob verifies <i class="calibre32">C<sub class="calibre33">A</sub></i> and obtains <i class="calibre32">E<sub class="calibre33">A</sub></i>. He makes sure these keys have not expired. (<i class="calibre32">E<sub class="calibre33">A</sub></i> is Alice’s public key.)
</li>
<li class="pcalibre1 calibre30">Bob uses <i class="calibre32">E<sub class="calibre33">A</sub></i> to decrypt <i class="calibre32">D<sub class="calibre33">A</sub></i>(<i class="calibre32">M</i>). This verifies both Alice’s signature and the integrity of the signed information.
</li>
<li class="pcalibre1 calibre30">Bob checks the <i class="calibre32">I<sub class="calibre33">B</sub></i> in <i class="calibre32">M</i> for accuracy.
</li>
<li class="pcalibre1 calibre30">Bob checks the <i class="calibre32">T<sub class="calibre33">A</sub></i> in <i class="calibre32">M</i> and confirms that the message is current.
</li>
<li class="pcalibre1 calibre30">As an option, Bob can check <i class="calibre32">R<sub class="calibre33">A</sub></i> in <i class="calibre32">M</i> against a database of old random numbers to ensure the message is not an old one being replayed.
</li>

</ol>

<p class="calibre9">The two-way protocol consists of the one-way protocol and then a similar
one-way protocol from Bob to Alice. After executing steps (1) through (8) of
the one-way protocol, the two-way protocol continues with:</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Bob generates another random number, <i class="calibre32">R<sub class="calibre33">B</sub></i>.
</li>
<li class="pcalibre1 calibre30">Bob constructs a message <i class="calibre32">M’</i> = (<i class="calibre32">T<sub class="calibre33">B</sub></i>, <i class="calibre32">R<sub class="calibre33">B</sub></i>, <i class="calibre32">I<sub class="calibre33">A</sub></i>, <i class="calibre32">R<sub class="calibre33">A</sub></i>, <i class="calibre32">d</i>), where <i class="calibre32">T<sub class="calibre33">B</sub></i> is Bob’s timestamp, <i class="calibre32">I<sub class="calibre33">A</sub></i> is the identity of Alice and <i class="calibre32">d</i> is arbitrary data. The data may be encrypted with Alice’s public key, <i class="calibre32">E<sub class="calibre33">A</sub></i>, for security. <i class="calibre32">R<sub class="calibre33">A</sub></i> is the random number Alice generated in step (1).
</li>
<li class="pcalibre1 calibre30">Bob sends <i class="calibre32">D<sub class="calibre33">B</sub></i>(<i class="calibre32">M’</i>) to Alice.
</li>
<li class="pcalibre1 calibre30">Alice uses <i class="calibre32">E<sub class="calibre33">B</sub></i> to decrypt <i class="calibre32">D<sub class="calibre33">B</sub></i>(<i class="calibre32">M’</i>). This verifies both Bob’s signature and the integrity of the signed information.
</li>
<li class="pcalibre1 calibre30">Alice checks the <i class="calibre32">I<sub class="calibre33">A</sub></i> in <i class="calibre32">M’</i> for accuracy.
</li>
<li class="pcalibre1 calibre30">Alice checks the <i class="calibre32">T<sub class="calibre33">B</sub></i> in <i class="calibre32">M’</i> and confirms that the message is current.
</li>
<li class="pcalibre1 calibre30">As an option, Alice can check the <i class="calibre32">R<sub class="calibre33">B</sub></i> in <i class="calibre32">M’</i> to ensure the message is not an old one being replayed.
</li>

</ol>

<p class="calibre9">The three-way protocol accomplishes the same thing as the two-way protocol,
but without timestamps. Steps (1) through (15) are identical to the two-way
protocol, with <i class="calibre12">T<sub class="calibre15">A</sub></i> = <i class="calibre12">T<sub class="calibre15">B</sub></i> = 0.</p>

<ol class="split1">

<li class="pcalibre1 calibre30">Alice checks the received version of <i class="calibre32">R<sub class="calibre33">A</sub></i> against the <i class="calibre32">R<sub class="calibre33">A</sub></i> she sent to Bob in step (3).
</li>
<li class="pcalibre1 calibre30">Alice sends <i class="calibre32">D<sub class="calibre33">A</sub></i>(<i class="calibre32">R<sub class="calibre33">B</sub></i>) to Bob.
</li>
<li class="pcalibre1 calibre30">Bob uses <i class="calibre32">E<sub class="calibre33">A</sub></i> to decrypt <i class="calibre32">D<sub class="calibre33">A</sub></i>(<i class="calibre32">R<sub class="calibre33">B</sub></i>). This verifies both Alice’s signature and the integrity of the signed information.
</li>
<li class="pcalibre1 calibre30">Bob checks the received version of <i class="calibre32">R<sub class="calibre33">B</sub></i> against the <i class="calibre32">R<sub class="calibre33">B</sub></i> he sent to Alice in step (10).
</li>

</ol>

<h3 id="24.10" class="calibre7">24.10 Privacy-Enhanced Mail (PEM)</h3>

<p class="calibre9">PEM is the Internet Privacy-Enhanced Mail standard, adopted by the Internet
Architecture Board (IAB) to provide secure electronic mail over the Internet. It
was initially designed by the Internet Research Task Force (IRTF) Privacy and
Security Research Group (PSRG), and then handed over to the Internet
Engineering Task Force (IETF) PEM Working Group. The PEM protocols
provide for encryption, authentication, message integrity, and key
management.</p>

<p class="calibre9">The complete PEM protocols were initially detailed in a series of RFCs
(Requests for Comment) in [<a href="Applied%20Cryptography_split_036.html#r977" class="calibre5 pcalibre">977</a>] and then revised in [<a href="Applied%20Cryptography_split_036.html#r978" class="calibre5 pcalibre">978</a>]. The third iteration
of the protocols [<a href="Applied%20Cryptography_split_036.html#r979" class="calibre5 pcalibre">979</a>,<a href="Applied%20Cryptography_split_036.html#r827" class="calibre5 pcalibre">827</a>,<a href="Applied%20Cryptography_split_036.html#r980" class="calibre5 pcalibre">980</a>] is summarized in [<a href="Applied%20Cryptography_split_035.html#r177" class="calibre5 pcalibre">177</a>,<a href="Applied%20Cryptography_split_035.html#r178" class="calibre5 pcalibre">178</a>]. The protocols
were modified and improved, and the final protocols are detailed in another
series of RFCs [<a href="Applied%20Cryptography_split_036.html#r981" class="calibre5 pcalibre">981</a>,<a href="Applied%20Cryptography_split_035.html#r825" class="calibre5 pcalibre">825</a>,<a href="Applied%20Cryptography_split_035.html#r76" class="calibre5 pcalibre">76</a>,<a href="Applied%20Cryptography_split_035.html#r802" class="calibre5 pcalibre">802</a>]. Another paper by Matthew Bishop [<a href="Applied%20Cryptography_split_035.html#r179" class="calibre5 pcalibre">179</a>]
details the changes. Reports of attempts to implement PEM include 
[<a href="Applied%20Cryptography_split_035.html#r602" class="calibre5 pcalibre">602</a>,<a href="Applied%20Cryptography_split_036.html#r1505" class="calibre5 pcalibre">1505</a>,<a href="Applied%20Cryptography_split_036.html#r1522" class="calibre5 pcalibre">1522</a>,<a href="Applied%20Cryptography_split_035.html#r74" class="calibre5 pcalibre">74</a>,<a href="Applied%20Cryptography_split_035.html#r351" class="calibre5 pcalibre">351</a>,<a href="Applied%20Cryptography_split_036.html#r1366" class="calibre5 pcalibre">1366</a>,<a href="Applied%20Cryptography_split_036.html#r1367" class="calibre5 pcalibre">1367</a>]. See also [<a href="Applied%20Cryptography_split_036.html#r1394" class="calibre5 pcalibre">1394</a>].</p>

<p class="calibre9">PEM is an inclusive standard. The PEM procedures and protocols are intended
to be compatible with a wide range of key-management approaches, including
both symmetric and public-key schemes to encrypt data-encrypting keys.
Symmetric cryptography is used for message-text encryption. Cryptographic
hash algorithms are used for message integrity. Other documents support
key-management mechanisms using public-key certificates; algorithms,
modes, and associated identifiers; and paper and electronic format details and
procedures for the key-management infrastructure to support these services.</p>

<p class="calibre9">PEM supports only certain algorithms, but allows for different suites of
algorithms to be specified later. Messages are encrypted with DES in CBC
mode. Authentication, provided by something called a <b class="calibre10">Message Integrity</b>
<b class="calibre10">Check</b> (<b class="calibre10">MIC</b>), uses either MD2 or MD5. Symmetric key management can use
either DES in ECB mode or triple-DES using two keys (called EDE mode).
PEM also supports public-key certificates for key management, using the RSA
algorithm (key length up to 1024 bits) and the X.509 standard for certificate
structure.</p>

<p class="calibre9">PEM provides three privacy-enhancement services: confidentiality,
authentication, and message integrity. No special processing requirements are
imposed on the electronic mail system. PEM can be incorporated selectively,
by site or by user, without affecting the rest of the network.</p>

<h4 class="calibre8">PEM Documents</h4>

<p class="calibre9">The specifications for PEM come from four documents:</p>

<ul class="calibre13">

<li class="calibre14">RFC 1421: Part I, Message Encryption and Authentication Procedures. This document
defines message encryption and authentication procedures in order to provide
privacy-enhanced mail services for electronic mail transfer on the Internet.
</li>
<li class="calibre14">RFC 1422: Part II, Certificate-Based Key Management. This document defines a
supporting key management architecture and infrastructure, based on public-key certificate techniques to provide keying information to message originators and recipients.
</li>
<li class="calibre14">RFC 1423: Part III, Algorithms, Modes, and Identifiers. This document provides
definitions, formats, references, and citations for cryptographic algorithms, usage modes, and associated identifiers and parameters.
</li>
<li class="calibre14">RFC 1424: Part IV, Key Certification and Related Services. This document describes
three types of service in support of PEM: key certification, certificate revocation list (CRL) storage, and CRL retrieval.
</li>

</ul>

<h4 class="calibre8">Certificates</h4>

<p class="calibre9">PEM is compatible with the authentication framework described in [<a href="Applied%20Cryptography_split_035.html#r304" class="calibre5 pcalibre">304</a>]; see also [<a href="Applied%20Cryptography_split_035.html#r826" class="calibre5 pcalibre">826</a>]. PEM is a superset of X.509; it establishes procedures and conventions for a key-management infrastructure for use with PEM and with other protocols (from both the TCP/IP and OSI suites) in the future.</p>

<p class="calibre9">The key-management infrastructure establishes a single root for all Internet certification. The Internet Policy Registration Authority (IPRA) establishes global policies that apply to all certification under this hierarchy. Beneath the IPRA root are Policy Certification Authorities (PCAs), each of which establishes and publishes its policies for registering users or organizations.
Each PCA is certified by the IPRA. Below PCAs, CAs certify users and subordinate organizational entities (such as departments, offices, subsidiaries). Initially, the majority of users are expected to be registered with some organization.</p>

<p class="calibre9">Some PCAs are expected to provide certification for users who wish to register independent of any organization. For users who wish anonymity while taking advantage of PEM privacy facilities, one or more PCAs are expected to be established with policies that allow for registration of users who do not wish to disclose their identities.</p>

<h4 class="calibre8">PEM Messages</h4>

<p class="calibre9">PEM’s heart is its message format. Figure 24.4 shows an encrypted message using symmetric key management, Figure 24.5 shows an authenticated and encrypted message using public-key key management, and Figure 24.6 shows an authenticated (but unencrypted) message using public-key key management.</p>

<pre id="figure-24-4" class="calibre20">-----BEGIN PRIVACY-ENHANCED MESSAGE-----
Proc-Type: 4,ENCRYPTED
Content-Domain: RFC822
DEK-Info: DES-CBC,F8143EDE5960C597
Originator-ID-Symmetric: schneier@counterpane.com,,
Recipient-ID-Symmetric: schneier@chinet.com,ptf-kmc,3
Key-Info:
DES-ECB,RSA-MD2,9FD3AAD2F2691B9A,B70665BB9BF7CBCDA60195DB94F727D3
Recipient-ID-Symmetric: pem-dev@tis.com,ptf-kmc,4
Key-Info:
DES-ECB,RSA-MD2,161A3F75DC82EF26,E2EF532C65CBCFF79F83A2658132DB47
LLrHB0eJzyhP+/fSStdW8okeEnv47jxe7SJ/iN72ohNcUk2jHEUSoH1nvNSIWL9M
8tEjmF/zxB+bATMtPjCUWbz8Lr9wloXIkjHUlBLpvXR0UrUzYbkNpk0agV2IzUpk
J6UiRRGcDSvzrsoK+oNvqu6z7Xs5Xfz5rDqUcMlK1Z6720dcBWGGsDLpTpSCnpot
dXd/H5LMDWnonNvPCwQUHt==
-----END PRIVACY-ENHANCED MESSAGE-----
</pre>
<p class="calibre9"><i class="calibre12">Figure 24.4 Example of an encapsulated message (symmetric case).</i></p>

<pre id="figure-24-5" class="calibre20">-----BEGIN PRIVACY-ENHANCED MESSAGE-----
Proc-Type: 4,ENCRYPTED
Content-Domain: RFC822
DEK-Info: DES-CBC,BFF968AA74691AC1
Originator-Certificate:
MIIBlTCCAScCAWUwDQYJKoZIhvcNAQECBQAwUTELMAkGA1UEBhMCVVMxIDAeBgNV
BAoTF1JTQSBEYXRhIFNlY3VyaXR5LCBJbmMuMQ8wDQYDVQQLEwZCZXRhIDExDzAN
BgNVBAsTBk5PVEFSWTAeFw05MTA5MDQxODM4MTdaFw05MzA5MDMxODM4MTZaMEUx
CzAJBgNVBAYTAlVTMSAwHgYDVQQKExdSU0EgRGF0YSBTZWN1cml0eSwgSW5jLjEU
MBIGA1UEAxMLVGVzdCBVc2VyIDEwWTAKBgRVCAEBAgICAANLADBIAkEAwHZHl7i+
yJcqDtjJCowzTdBJrdAiLAnSC+CnnjOJELyuQiBgkGrgIh3j8/x0fM+YrsyF1u3F
LZPVtzlndhYFJQIDAQABMA0GCSqGSIb3DQEBAgUAA1kACKr0PqphJYw1j+YPtcIq
iWlFPuN5jJ79Khfg7ASFxskYkEMjRNZV/HZDZQEhtVaU7Jxfzs2wfX5byMp2X3U/
5XUXGx7qusDgHQGs7Jk9W8CW1fuSWUgN4w==
Key-Info: RSA,
I3rRIGXUGWAF8js5wCzRTkdhO34PTHdRZY9Tuvm03M+NM7fx6qc5udixps2Lng0+
wGrtiUm/ovtKdinz6ZQ/aQ==
Issuer-Certificate:
MIIB3DCCAUgCAQowDQYJKoZIhvcNAQECBQAwTzELMAkGA1UEBhMCVVMxIDAeBgNV
BAoTF1JTQSBEYXRhIFNlY3VyaXR5LCBJbmMuMQ8wDQYDVQQLEwZCZXRhIDExDTAL
BgNVBAsTBFRMQ0EwHhcNOTEwOTAxMDgwMDAwWhcNOTIwOTAxMDc1OTU5WjBRMQsw
CQYDVQQGEwJVUzEgMB4GA1UEChMXUlNBIERhdGEgU2VjdXJpdHksIEluYy4xDzAN
BgNVBAsTBkJldGEgMTEPMA0GA1UECxMGTk9UQVJZMHAwCgYEVQgBAQICArwDYgAw
XwJYCsnp6lQCxYykNlODwutF/jMJ3kL+3PjYyHOwk+/9rLg6X65B/LD4bJHtO5XW
cqAz/7R7XhjYCm0PcqbdzoACZtIlETrKrcJiDYoP+DkZ8k1gCk7hQHpbIwIDAQAB
MA0GCSqGSIb3DQEBAgUAA38AAICPv4f9Gx/tY4+p+4DB7MV+tKZnvBoy8zgoMGOx
dD2jMZ/3HsyWKWgSF0eH/AJB3qr9zosG47pyMnTf3aSy2nBO7CMxpUWRBcXUpE+x
EREZd9++32ofGBIXaialnOgVUn0OzSYgugiQ077nJLDUj0hQehCizEs5wUJ35a5h
MIC-Info: RSA-MD5,RSA,
UdFJR8u/TIGhfH65ieewe21OW4tooa3vZCvVNGBZirf/7nrgzWDABz8w9NsXSexv
AjRFbHoNPzBuxwmOAFeA0HJszL4yBvhG
Recipient-ID-Asymmetric:
MFExCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdSU0EgRGF0YSBTZWN1cml0eSwgSW5j
LjEPMA0GA1UECxMGQmV0YSAxMQ8wDQYDVQQLEwZOT1RBUlk=,
66
Key-Info: RSA,
O6BS1ww9CTyHPtS3bMLD+L0hejdvX6Qv1HK2ds2sQPEaXhX8EhvVphHYTjwekdWv
7x0Z3Jx2vTAhOYHMcqqCjA==
qeWlj/YJ2Uf5ng9yznPbtD0mYloSwIuV9FRYx+gzY+8iXd/NQrXHfi6/MhPfPF3d
jIqCJAxvld2xgqQimUzoS1a4r7kQQ5c/Iua4LqKeq3ciFzEv/MbZhA==
-----END PRIVACY-ENHANCED MESSAGE-----
</pre>
<p class="calibre9"><i class="calibre12">Figure 24.5 Example of an encapsulated encrypted message (asymmetric case).</i></p>

<pre id="figure-24-6" class="calibre20">-----BEGIN PRIVACY-ENHANCED MESSAGE-----
Proc-Type: 4,MIC-ONLY
Content-Domain: RFC822
Originator-Certificate:
MIIBlTCCAScCAWUwDQYJKoZIhvcNAQECBQAwUTELMAkGA1UEBhMCVVMxIDAeBgNV
BAoTF1JTQSBEYXRhIFNlY3VyaXR5LCBJbmMuMQ8wDQYDVQQLEwZCZXRhIDExDzAN
BgNVBAsTBk5PVEFSWTAeFw05MTA5MDQxODM4MTdaFw05MzA5MDMxODM4MTZaMEUx
CzAJBgNVBAYTAlVTMSAwHgYDVQQKExdSU0EgRGF0YSBTZWN1cml0eSwgSW5jLjEU
MBIGA1UEAxMLVGVzdCBVc2VyIDEwWTAKBgRVCAEBAgICAANLADBIAkEAwHZHl7i+
yJcqDtjJCowzTdBJrdAiLAnSC+CnnjOJELyuQiBgkGrgIh3j8/x0fM+YrsyF1u3F
LZPVtzlndhYFJQIDAQABMA0GCSqGSIb3DQEBAgUAA1kACKr0PqphJYw1j+YPtcIq
iWlFPuN5jJ79Khfg7ASFxskYkEMjRNZV/HZDZQEhtVaU7Jxfzs2wfX5byMp2X3U/
5XUXGx7qusDgHQGs7Jk9W8CW1fuSWUgN4w==
Issuer-Certificate:
MIIB3DCCAUgCAQowDQYJKoZIhvcNAQECBQAwTzELMAkGA1UEBhMCVVMxIDAeBgNV
BAoTF1JTQSBEYXRhIFNlY3VyaXR5LCBJbmMuMQ8wDQYDVQQLEwZCZXRhIDExDTAL
BgNVBAsTBFRMQ0EwHhcNOTEwOTAxMDgwMDAwWhcNOTIwOTAxMDc1OTU5WjBRMQsw
CQYDVQQGEwJVUzEgMB4GA1UEChMXUlNBIERhdGEgU2VjdXJpdHksIEluYy4xDzAN
BgNVBAsTBkJldGEgMTEPMA0GA1UECxMGTk9UQVJZMHAwCgYEVQgBAQICArwDYgAw
XwJYCsnp6lQCxYykNlODwutF/jMJ3kL+3PjYyHOwk+/9rLg6X65B/LD4bJHtO5XW
cqAz/7R7XhjYCm0PcqbdzoACZtIlETrKrcJiDYoP+DkZ8k1gCk7hQHpbIwIDAQAB
MA0GCSqGSIb3DQEBAgUAA38AAICPv4f9Gx/tY4+p+4DB7MV+tKZnvBoy8zgoMGOx
dD2jMZ/3HsyWKWgSF0eH/AJB3qr9zosG47pyMnTf3aSy2nBO7CMxpUWRBcXUpE+x
EREZd9++32ofGBIXaialnOgVUn0OzSYgugiQ077nJLDUj0hQehCizEs5wUJ35a5h
MIC-Info: RSA-MD5,RSA,
jV2OfH+nnXHU8bnL8kPAad/mSQlTDZlbVuxvZAOVRZ5q5+Ejl5bQvqNeqOUNQjr6
EtE7K2QDeVMCyXsdJlA8fA==
LSBBIG1lc3NhZ2UgZm9yIHVzZSBpbiB0ZXN0aW5nLg0KLSBGb2xsb3dpbmcgaXMg
YSBibGFuayBsaW5lOg0KDQpUaGlzIGlzIHRoZSBlbmQuDQo=
-----END PRIVACY-ENHANCED MESSAGE-----
</pre>
<p class="calibre9"><i class="calibre12">Figure 24.6 Example of an encapsulated MIC-ONLY message (asymmetric case).</i></p>

<p class="calibre9">The first field is “<code class="calibre18">Proc-Type</code>, ” and identifies the type of processing performed on the message.
There are three possible types of messages. The “<code class="calibre18">ENCRYPTED</code>” specifier says that the message is encrypted and signed. The “<code class="calibre18">MIC-ONLY</code>” and “<code class="calibre18">MIC-CLEAR</code>” specifiers would indicate that the message is signed, but not encrypted. <code class="calibre18">MIC-CLEAR</code> messages are not encoded and can be read using non-PEM software. <code class="calibre18">MIC-ONLY</code> messages need PEM software to transform them to a
human-readable form. A PEM message is always signed; it is optionally encrypted.</p>

<p class="calibre9">The next field, “<code class="calibre18">Content-Domain</code>, ” specifies the type of mail message. It has nothing to do with security. The “<code class="calibre18">DEK-Info</code>” field gives information on the <b class="calibre10">Data Exchange Key</b> (<b class="calibre10">DEK</b>), the encryption algorithm used to encrypt the text, and any parameters associated with the encryption algorithm. Only DES in CBC mode is currently specified, or “<code class="calibre18">DES-CBC</code>.” The second subfield specifies the IV. Other algorithms may be specified by PEM in the future; their use will be noted in DEK-Info and in other fields that identify algorithms.</p>

<p class="calibre9">For messages with symmetric key management (see Figure 24.4), the next field is
“<code class="calibre18">Originator-ID-Symmetric</code>” with three subfields. The first subfield identifies the sender by a unique electronic mail address. The second subfield is optional and identifies the authority that issued the interchange key. The third is an optional Version/Expiration subfield.</p>

<p class="calibre9">Continuing with the symmetric key-management case, each recipient has two fields:
“<code class="calibre18">Recipient-ID-Symmetric</code>” and “<code class="calibre18">Key-Info</code>.” The “<code class="calibre18">Recipient-ID-Symmetric</code>” field has three
subfields; these identify the receiver in the same way that “<code class="calibre18">Originator-ID-Symmetric</code>” identified the sender.</p>

<p class="calibre9">The “<code class="calibre18">Key-Info</code>” field specifies the key-management parameters. This field has four subfields. The first subfield gives the algorithm used to encrypt the DEK. Since the key management in this message is symmetric, the sender and receiver have to share a common key. This is called the <b class="calibre10">Interchange Key</b> (<b class="calibre10">IK</b>), which is used to encrypt the DEK. The DEK can be either encrypted using DES in ECB (denoted by “<code class="calibre18">DES-ECB</code>”) or triple-DES (which would be denoted “<code class="calibre18">DES-EDE</code>”). The second subfield specifies the MIC algorithm. It can be either MD2 (denoted by “<code class="calibre18">RSA-MD2</code>”) or MD5 (which would be denoted “<code class="calibre18">RSA-MD5</code>”). The third subfield, the DEK, and the fourth field, the MIC, are both encrypted with the IK.</p>

<p class="calibre9">Figures 24.5 and 24.6 show messages with public-key key management (called “asymmetric” in PEM nomenclature). The headers are different. In ENCRYPTED messages, after the “DEK-Info”
field comes the “<code class="calibre18">Originator-Certificate</code>” field. The certificate follows the X.509 standard (see <a href="#24.9" class="calibre5 pcalibre">Section 24.9</a>). The next field is “<code class="calibre18">Key-Info</code>” with two subfields. The first subfield specifies the public-key algorithm used to encrypt the DEK; currently only RSA is supported. The next subfield is the DEK, encrypted in the originator’s public key. This is an optional field, intended to permit the originator to decrypt his own message in the event that it is returned by the mail system. The next field “Issuer-Certificate, ” is the certificate of whomever signed the Originator-Certificate.</p>

<p class="calibre9">Continuing with the asymmetric key-management case, the next field is “<code class="calibre18">MIC-Info</code>.” The first subfield gives the algorithm under which the MIC was computed. The second subfield shows the algorithm under which the MIC was signed. The third subfield consists of the MIC, signed by the sender’s private key.</p>


<p class="calibre9">Still continuing with asymmetric key management, the next fields deal with the recipients. There are two fields for each recipient: “<code class="calibre18">Recipient-ID-Asymmetric</code>” and “<code class="calibre18">Key-Info</code>.” The
“<code class="calibre18">Recipient-ID-Asymmetric</code>” field has two subfields. The first identifies the authority that issued the receiver’s public key; the second is an optional Version/Expiration subfield. The “<code class="calibre18">Key-Info</code>”
field specifies the key management parameters: The first subfield identifies the algorithm used to encrypt the message and the second subfield is the DEK encrypted with the receiver’s public key.</p>

<h4 class="calibre8">Security of PEM</h4>

<p class="calibre9">RSA keys in PEM can range from 508 bits to 1024 bits. This should be long enough for anyone’s security needs. A more likely attack would be against the key-management protocols. Mallory could steal your private key — don’t write it down anywhere — or attempt to fool you into
accepting a bogus public key. The key certification provisions of PEM make this unlikely if everyone follows proper procedures, but people have been known to be sloppy.</p>

<p class="calibre9">A more insidious attack would be for Mallory to modify the PEM implementation running on your system. This modified implementation could surreptitiously send Mallory all of your mail, encrypted with his public key. It could even send him a copy of your private key. If the modified implementation works well, you will never know what is happening.</p>

<p class="calibre9">There’s no real way to prevent this kind of attack. You could use a one-way hash function and fingerprint the PEM code. Then, each time you run it, you could check the fingerprint for modification. But Mallory could modify the fingerprint code at the same time he modifies the PEM code. You could fingerprint the fingerprint code, but Mallory could modify that as well. If Mallory can get access to your machine, he can subvert the security of PEM.</p>

<p class="calibre9">The moral is that you can never really trust a piece of software if you cannot trust the hardware it is running on. For most people, this kind of paranoia is unwarranted. For some, it is very real.</p>

<h4 class="calibre8">TIS/PEM</h4>

<p class="calibre9">Trusted Information Systems, partially supported by the U.S. government Advanced Research Projects Agency, has designed and implemented a reference implementation of PEM (TIS/PEM).
Developed for UNIX-based platforms, it has also been ported to VMS, DOS, and Windows.</p>

<p class="calibre9">Although the PEM specifications indicate a single certification hierarchy for use by the Internet, TIS/PEM supports the existence of multiple certification hierarchies. Sites may specify a set of certificates that are to be considered valid, including all certificates issued by them. A site need not join the Internet hierarchy in order to use TIS/PEM.</p>

<p class="calibre9">TIS/PEM is currently available to all U.S. and Canadian organizations and citizens upon request.
It will be distributed in source code form. Interested parties should contact: <code class="calibre18">Privacy-Enhanced Mail, Trusted Information Systems, Inc., 3060 Washington Road (Rte. 97), Glenwood, MD
21738; (301) 854-6889; fax: (301) 854-5363; Internet: pem-info@tis.com</code>.</p>

<h4 class="calibre8">RIPEM</h4>

<p class="calibre9">RIPEM is a program, written by Mark Riordan, that implements the PEM protocols. Although technically not public domain, the program is publicly available and can be used royalty-free for personal, noncommercial applications. A license for its use is included with the documentation.</p>

<p class="calibre9">The code cannot be exported. Of course, U.S. government laws don’t apply outside the United States, and some people have ignored the export rules. RIPEM code is available on bulletin boards worldwide. Something called RIPEM/SIG, which only does digital signatures, is
exportable.</p>

<p class="calibre9">At this writing, RIPEM is not a complete implementation of the PEM protocols; it does not implement certificates for authenticating keys.</p>

<p class="calibre9">Before writing RIPEM, Riordan wrote a similar program called RPEM. This was intended to be a public-domain electronic-mail encryption program. To try to avoid patent issues, Riordan used Rabin’s algorithm (see <a href="Applied%20Cryptography_split_022.html#19.5" class="calibre5 pcalibre">Section 19.5</a>). Public Key Partners claimed that their patents were broad enough to cover all of public-key cryptography and threatened to sue; Riordan stopped
distributing the program.</p>

<p class="calibre9">RPEM isn’t really used anymore. It is not compatible with RIPEM. Since RIPEM can be used with the full blessing of Public Key Partners, there is no reason to use RPEM instead.</p>

<h3 id="24.11" class="calibre7">24.11 Message Security Protocol (MSP)</h3>

<p class="calibre9">The Message Security Protocol (MSP) is the military equivalent of PEM. It
was developed by the NSA in the late 1980s under the Secure Data Network
System (SDNS) program. It is an X.400-compatible application-level protocol
for securing electronic mail. MSP will be used for signing and encrypting
messages in the Department of Defense’s planned Defense Message System
(DMS) network.</p>

<p class="calibre9">The Preliminary Message Security Protocol (PMSP), to be used for
“unclassified but sensitive” messages, is a version of MSP adapted for use
with both X.400 and TCP/IP. This protocol is also called Mosaic.</p>

<p class="calibre9">Like PEM, MSP and PMSP software applications are flexible and designed to
accommodate a variety of algorithms for security functions including signing,
hashing, and encryption. PSMP will work with the Capstone chip (see <a href="#24.17" class="calibre5 pcalibre">Section 24.17</a>).</p>

<h3 id="24.12" class="calibre7">24.12 Pretty Good Privacy (PGP)</h3>

<p class="calibre9">Pretty Good Privacy (PGP) is a freeware electronic-mail security program,
originally designed by Philip Zimmermann [<a href="Applied%20Cryptography_split_036.html#r1652" class="calibre5 pcalibre">1652</a>]. It uses IDEA for data
encryption, RSA (with keys up to 2047 bits) for key management and digital
signatures, and MD5 as a one-way hash function.</p>

<p class="calibre9">PGP’s random public keys use a probabilistic primality tester, and get their
initial seeds from measuring the user’s keyboard latency while typing. PGP
generates random IDEA keys using the method delineated in ANSI X9.17,
Appendix C (see <a href="Applied%20Cryptography_split_010.html#8.1" class="calibre5 pcalibre">Section 8.1</a>) [<a href="Applied%20Cryptography_split_035.html#r55" class="calibre5 pcalibre">55</a>], with IDEA as the symmetric algorithm
instead of DES. PGP also encrypts the user’s private key using a hashed pass
phrase instead of a password.</p>

<p class="calibre9">PGP-encrypted messages have layered security. The only thing a cryptanalyst
can learn about an encrypted message is who the recipient is, assuming he
knows the recipient’s key ID. Only after the recipient decrypts the message
does he learn who signed the message, if it is signed. Contrast this approach
with PEM, which leaves quite a bit of information about the sender, recipient,
and message in the unencrypted header.</p>

<p class="calibre9">The most interesting aspect of PGP is its distributed approach to key
management (see <a href="Applied%20Cryptography_split_010.html#8.12" class="calibre5 pcalibre">Section 8.12</a>). There are no key certification authorities; PGP
instead supports a “web of trust.” Every user generates and distributes his own
public key. Users sign each other’s public keys, creating an interconnected
community of PGP users.</p>

<p class="calibre9">For example, Alice might physically give her public key to Bob. Bob knows
Alice, so he signs her public key. He then gives the signed key back to her and
keeps a copy for himself. When Alice wants to communicate with Carol, Alice
sends Carol a copy of the key Bob signed. Carol, who already has Bob’s public
key (she got it at some other time) and trusts Bob to certify other people’s
keys, verifies his signature on Alice’s key and accepts it as valid. Bob has
introduced Alice to Carol.</p>

<p class="calibre9">PGP does not specify a policy for establishing trust; users are free to decide
who they trust and who they do not. PGP provides mechanisms for associating
trust with public keys and for using trust. Each user keeps a collection of
signed public keys in a file called a <b class="calibre10">public-key ring</b>. Each key in the ring has a key legitimacy field that indicates the degree to which the particular user trusts
the validity of the key. The higher the trust level, the more the user believes
the key is legitimate. A signature trust field measures how far the user trusts
the signer to certify the public keys of other users. And finally, an owner trust
field indicates the degree to which the particular user trusts the key’s owner to
sign other public keys; this field is set manually by the user. PGP continuously
updates these fields as users supply new information.</p>

<p class="calibre9">Figure 24.7 shows how this model might look for a particular user, Alice.
Alice’s key is at the top, and the owner trust value is ultimate trust. Alice has
signed Bob’s, Carol’s, Dave’s, Ellen’s, and Frank’s keys. She trusts Bob and
Carol to sign other people’s public keys, and she partially trusts Dave and
Ellen to sign other people’s public keys. And she trusts Gail to sign other
people’s public keys, even though she has not signed Gail’s key herself.</p>

<div class="figure" id="figure-24-7">
<div class="image1">
<p class="calibre9"><img src="ac-figure-24-7.png" class="calibre11"/></p>
</div>
<p class="calibre9"><i class="calibre12"><b class="calibre10">Figure 24.7</b> PGP trust model.</i></p>
</div>

<p class="calibre9">Two partially trusted signatures may be sufficient to certify a key. Alice
believes that Kurt’s key is legitimate because both Dave and Ellen have signed
it. This is not automatic in PGP; Alice can set her own paranoia level.</p>

<p class="calibre9">Just because Alice believes a key to be valid, she does not have to trust it to
sign other people’s keys. She does not trust Frank to sign other people’s public
keys, even though she signed his key herself. And she does not trust Ivan’s
signature on Martin’s key, or Kurt’s signature on Nancy’s key.</p>

<p class="calibre9">Owen’s key doesn’t fit into the web anywhere; perhaps Alice got it from a key
server. PGP does not assume that the key is valid; Alice must either declare the
key valid or decide to trust one of the key’s signers.</p>

<p class="calibre9">Of course, nothing prevents Alice from using keys she does not trust. PGP’s
job is to alert Alice that the key is not trusted, not to prevent communications.</p>

<p class="calibre9">The weakest link of this whole system is key revocation: It is impossible to
guarantee that no one will use a compromised key. If Alice’s private key is
stolen she can send out something called a <b class="calibre10">key revocation certificate</b>, but
since key distribution is <i class="calibre12">ad hoc</i> and largely word of mouth there is no
guarantee that it will reach everyone who has her public key on his key ring.
And as Alice has to sign the key revocation certificate with her private key; if
she loses the key altogether she cannot revoke it.</p>

<p class="calibre9">The current version of PGP is 2.6.2. A new version of PGP, PGP 3.0, is
scheduled for release by the end of 1995. Changes in 3.0 include options for
triple-DES, SHA, and other public-key algorithms, a split of the encryption
and signature public-key/private-key key pairs, enhanced procedures for key
revocation, improved key-ring management functions, an API for integrating
PGP in other programs, and a completely rewritten code base.</p>

<p class="calibre9">PGP is available for MS-DOS, UNIX, Macintosh, Amiga, and Atari. It is free
for personal, noncommercial use, and is available from many ftp sites on the
Internet. To ftp PGP from MIT, telnet to net-dist.mit.edu, log in as getpgp,
answer the questions, then ftp to net-dist.mit.edu and change to the directory
named in the telnet session. It is also available from ftp.ox.ac.uk,
ftp.dsi.unimi.it, ftp.funet.fi, ftp.demon.co.uk, Compuserve, AOL, and
elsewhere. For U.S. commercial users, PGP can be bought — complete with
licenses — for about $100 from a company called <code class="calibre18">ViaCrypt, 9033 N 24th Ave.,
Phoenix, AZ, 85021; (602) 944-0773; viacrypt@acm.org</code>. Several shareware
front-ends are available to help integrate PGP into MS-DOS, Microsoft
Windows, Macintosh, and UNIX.</p>

<p class="calibre9">There are several books about PGP [<a href="Applied%20Cryptography_split_035.html#r601" class="calibre5 pcalibre">601</a>,<a href="Applied%20Cryptography_split_036.html#r1394" class="calibre5 pcalibre">1394</a>,<a href="Applied%20Cryptography_split_036.html#r1495" class="calibre5 pcalibre">1495</a>]. The source code has
even been published in book form [<a href="Applied%20Cryptography_split_036.html#r1653" class="calibre5 pcalibre">1653</a>] in an attempt to frustrate the U.S.
Department of State, which continues to maintain that source code is
exportable on paper but not electronically. Assuming you trust IDEA, PGP is
the closest you’re likely to get to military-grade encryption.</p>

<h3 id="24.13" class="calibre7">24.13 Smart Cards</h3>

<p class="calibre9">A smart card is a plastic card, the size and shape of a credit card, with an
embedded computer chip. It’s an old idea — the first patents were filed 20 years
ago — but practical limitations made them feasible only five or so years ago.
Since then they have taken off, mostly in Europe. Many countries use smart
cards for pay telephones. There are also smart credit cards, smart cash cards,
smart everything cards. The U.S. credit-card companies are looking at the
technology, and within a few years even backwards Americans will have smart
cards in their wallets.</p>

<p class="calibre9">A smart card contains a small computer (usually an 8-bit microprocessor),
RAM (about a quarter kilobyte), ROM (about 6 or 8 kilobytes), and either
EPROM or EEPROM (a few kilobytes). Future-generation smart cards will
undoubtedly have more capacity, but some physical limitations on smart cards
make expansion difficult. The card has its own operating system, programs,
and data. (What it doesn’t have is power; that comes when the card is plugged
in to a reader.) And it is secure. In a world where you might not trust someone
else’s computer or telephone or whatever, you can still trust a card that you
keep with you in your wallet.</p>

<p class="calibre9">Smart cards can have different cryptographic protocols and algorithms
programmed into them. They might be configured as an electronic purse, and
be able to spend and receive digital cash. They may be able to perform
zero-knowledge authentication protocols; they may have their own encryption
keys. They might be able to sign documents, or unlock applications on a
computer.</p>

<p class="calibre9">Some smart cards are assumed to be tamperproof; this often protects the
institution that issues the cards. A bank wouldn’t want you to be able to hack
their smart card to give yourself more money.</p>

<p class="calibre9">There is a lot of interest in smart cards, and a lot of information about them is
available. A good survey article on the cryptography in smart cards is [<a href="Applied%20Cryptography_split_035.html#r672" class="calibre5 pcalibre">672</a>].
CARTES is a conference held in Paris every October; and CardTech is held in
Washington, D.C. every April. The proceedings of two other smart-card
conferences are [<a href="Applied%20Cryptography_split_035.html#r342" class="calibre5 pcalibre">342</a>,<a href="Applied%20Cryptography_split_035.html#r382" class="calibre5 pcalibre">382</a>]. There are hundreds of smart-card patents, mostly
owned by European companies. An interesting paper on possible future
applications — integrity checking, audit trails, copy protection, digital cash,
secure postage meters — is [<a href="Applied%20Cryptography_split_036.html#r1628" class="calibre5 pcalibre">1628</a>].</p>

<h3 id="24.14" class="calibre7">24.14 Public-Key Cryptography Standards (PKCS)</h3>

<p class="calibre9">The Public-Key Cryptography Standards (PKCS) are RSA Data Security,
Inc.’s attempt to provide an industry standard interface for public-key
cryptography. Traditionally, this sort of thing would be handled by ANSI, but,
considering the current situation in cryptography politics, RSADSI figured that
they had better do it on their own. Working with a variety of companies, they
developed a series of standards. Some are compatible with other standards and
some are not.</p>

<p class="calibre9">These are not standards in the traditional sense of the word; no standards body
convened and voted on PKCS. According to its own materials, RSADSI will
“retain sole decision-making authority on what each standard is” and will
“publish revised standards when appropriate” [<a href="Applied%20Cryptography_split_035.html#r803" class="calibre5 pcalibre">803</a>].</p>

<p class="calibre9">Even so, there is a lot of good stuff here. If you’re not sure what kind of syntax
and data structures to use when programming public-key cryptography, these
standards are probably as good as anything else you can come up with. And,
since they’re not really standards, you can tailor them to suit your needs.</p>

<p class="calibre9">Following is a short description of each PKCS (PKCS #2 and PKCS #4 have
been incorporated into PKCS #1).</p>

<p class="calibre9">PKCS #1 [<a href="Applied%20Cryptography_split_036.html#r1345" class="calibre5 pcalibre">1345</a>] describes a method for RSA encryption and decryption,
primarily for constructing the digital signatures and digital envelopes
described in PKCS #7. For digital signatures, the message is hashed and then
the hash is encrypted with the private key of the signer. Both message and
hash are represented together as detailed in PKCS #7. For digital envelopes
(encrypted messages), the message is first encrypted with a symmetric
algorithm, and then the message key is encrypted with the public key of the
recipient. The encrypted message and encrypted key are represented together
according to the syntax of PKCS #7. Both of these methods are compatible
with PEM standards. PKCS #1 also describes a syntax, identical to the syntax
in X.509 and PEM, for RSA public and private keys and three signature
algorithms — MD2 and RSA, MD4 and RSA, and MD5 and RSA — for signing
certificates and the like.</p>

<p class="calibre9">PKCS #3 [<a href="Applied%20Cryptography_split_036.html#r1346" class="calibre5 pcalibre">1346</a>] describes a method for implementing Diffie-Hellman key
exchange.</p>

<p class="calibre9">PKCS #5 [<a href="Applied%20Cryptography_split_036.html#r1347" class="calibre5 pcalibre">1347</a>] describes a method for encrypting messages with a secret key
derived from a password. It uses either MD2 or MD5 to derive the key from
the password, and encrypts with DES in CBC mode. The method is intended
primarily to encrypt private keys when transferring them from one computer
system to another, but can be used to encrypt messages.</p>

<p class="calibre9">PKCS #6 [<a href="Applied%20Cryptography_split_036.html#r1348" class="calibre5 pcalibre">1348</a>] describes a standard syntax for public key certificates. The
syntax is a superset of an X.509 certificate, so that X.509 certificates can be
extracted if necessary. Over and above the X.509 set, additional attributes
extend the certification process beyond just the public key. These include other
information, such as electronic mail address.</p>

<p class="calibre9">PKCS # 7 [<a href="Applied%20Cryptography_split_036.html#r1349" class="calibre5 pcalibre">1349</a>] is a general syntax for data that may be encrypted or signed,
such as digital envelopes or digital signatures. The syntax is recursive, so that
envelopes can be nested, or someone can sign some previously encrypted data.
The syntax also allows other attributes, such as timestamps, to be authenticated
along with the message content. PKCS #7 is compatible with PEM so that
signed and encrypted messages can be converted to PEM messages without
any cryptographic operations, and vice versa. PKCS #7 can support a variety
of architectures — PEM is one — for certificate-based key management.</p>

<p class="calibre9">PKCS #8 [<a href="Applied%20Cryptography_split_036.html#r1350" class="calibre5 pcalibre">1350</a>] describes a syntax for private key information — including a
private key and a set of attributes — and a syntax for encrypted private keys.
PKCS #5 can be used to encrypt the private key information.</p>

<p class="calibre9">PKCS #9 [<a href="Applied%20Cryptography_split_036.html#r1351" class="calibre5 pcalibre">1351</a>] defines selected attribute types for PKCS #6 extended
certificates, PKCS #7 digitally signed messages, and PKCS #8 private-key
information.</p>

<p class="calibre9">PKCS #10 [<a href="Applied%20Cryptography_split_036.html#r1352" class="calibre5 pcalibre">1352</a>] describes a standard syntax for certification requests. A
certification comprises a distinguished name, a public key, and (optionally) a
set of attributes, collectively signed by the person requesting certification.
Certification requests are sent to a certification authority, who either
transforms the request into an X.509 public-key certificate or a PKCS #6
certificate.</p>

<p class="calibre9">PKCS #11 [<a href="Applied%20Cryptography_split_036.html#r1353" class="calibre5 pcalibre">1353</a>], the Cryptographic Token API Standard, specifies a
programming interface called “Cryptoki” for portable cryptographic devices of
all kinds. Cryptoki presents a common logical model, enabling applications to
perform cryptographic operations on portable devices without knowing details
of the underlying technology. The standard also defines application profiles:
sets of algorithms that a device may support.</p>

<p class="calibre9">PKCS #12 [<a href="Applied%20Cryptography_split_036.html#r1354" class="calibre5 pcalibre">1354</a>] describes syntax for storing in software a user’s public keys,
protected private keys, certificates, and other related cryptographic
information. The goal is to standardize on a single key file for use among a
variety of applications.</p>

<p class="calibre9">These standards are comprehensive, but not exhaustive. Many things are
outside their scope: the problem of naming, noncryptographic issues
surrounding certification, key lengths, and conditions on various parameters.
What the PKCS provide are a format for transferring data based on public-key
cryptography and an infrastructure to support that transfer.</p>

<h3 id="24.15" class="calibre7">24.15 Universal Electronic Payment System (UEPS)</h3>

<p class="calibre9">The UEPS is a smart-card banking application initially developed for rural
South Africa, but later adopted by all of that country’s major banking groups.
About 2 million cards were issued in that country by early 1995. It has also
been adopted in Namibia, and is also being deployed by at least one bank in
Russia.</p>

<p class="calibre9">The system provides a secure debit card suitable for regions where poor
telephone service make on-line verification impossible. Both customers and
merchants have cards; customers can use their cards to transfer money to
merchants. Merchants can then take their cards to a telephone and deposit the
money in their bank account; customers can take their cards to a telephone and
have money moved onto their card. There is no intention to provide
anonymity, only to prevent fraud.</p>

<p class="calibre9">Here is the communications protocol between customer Alice and merchant
Bob. (Actually, Alice and Bob just plug their cards into a machine and wait for
it to complete the transaction.) When Alice first gets her card, she is given a
key pair, <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12">K</i><sub class="calibre15">2</sub>; the bank calculates them from her name and some secret function. Only the merchant cards have the secrets necessary to work out these
customer keys.</p>

<ol class="calibre17">

<li class="calibre14">Alice sends Bob her name, <i class="calibre12">A</i>, his name, <i class="calibre12">B</i>, and a random number, <i class="calibre12">R<sub class="calibre15">A</sub></i>, encrypted using DES: first with <i class="calibre12">K</i><sub class="calibre15">2</sub> and then with <i class="calibre12">K</i><sub class="calibre15">1</sub>. She also sends her name in the clear.
<p class="math"><i class="calibre12">A, E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">1</sub></sub>(<i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">2</sub></sub>(<i class="calibre12">A, B, R<sub class="calibre15">A</sub></i>))
</p>

</li>
<li class="calibre14">Bob calculates <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12">K</i><sub class="calibre15">2</sub> from Alice’s name. He decrypts the message, confirms that <i class="calibre12">A</i> and <i class="calibre12">B</i> are correct, then encrypts Alice’s
unencrypted second message with <i class="calibre12">K</i><sub class="calibre15">2</sub>.
<p class="math"><i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">2</sub></sub>(<i class="calibre12">A, B, R<sub class="calibre15">A</sub></i>)
</p>

Bob does not send this message to Alice; 56 bits of the ciphertext
become <i class="calibre12">K</i><sub class="calibre15">3</sub>. Bob then sends Alice his name, her name, and another
random number, <i class="calibre12">R<sub class="calibre15">B</sub></i>, encrypted using DES: first with <i class="calibre12">K</i><sub class="calibre15">3</sub> and then with
<i class="calibre12">K</i><sub class="calibre15">1</sub>.
<p class="math"><i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">1</sub></sub>(<i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">3</sub></sub>(<i class="calibre12">B, A, R<sub class="calibre15">B</sub></i>))
</p>

</li>
<li class="calibre14">Alice computes <i class="calibre12">K</i><sub class="calibre15">3</sub> in the same manner Bob did. She decrypts Bob’s
message, confirms that <i class="calibre12">B</i> and <i class="calibre12">A</i> are correct, then encrypts Bob’s
unencrypted message with <i class="calibre12">K</i><sub class="calibre15">3</sub>.
<p class="math"><i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">3</sub></sub>(<i class="calibre12">B, A, R<sub class="calibre15">B</sub></i>)
</p>

Alice does not send this message to Bob; 56 bits of the ciphertext
become <i class="calibre12">K</i><sub class="calibre15">4</sub>. Alice then sends Bob her name, his name, and the digital
check, <i class="calibre12">C. </i> This check contains the names of the sender and recipient, a
date, a check number, an amount, and two MACs, all encrypted using
DES: first with <i class="calibre12">K</i><sub class="calibre15">4</sub> and then with <i class="calibre12">K</i><sub class="calibre15">1</sub>. One of the MACs can be verified
by Alice’s bank, and the other can only be verified by the clearing
center. Alice debits her account by the correct amount.
<p class="math"><i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">1</sub></sub>(<i class="calibre12">E</i><sub class="calibre15"><i class="calibre22">K</i><sub class="calibre16">4</sub></sub>(<i class="calibre12">A, B, C</i>))
</p>

</li>
<li class="calibre14">Bob computes <i class="calibre12">K</i><sub class="calibre15">4</sub> in the same manner Alice did. Assuming all the
names match and the check is correctly formed, he accepts it for
payment.
</li>

</ol>

<p class="calibre9">A really clever thing about this protocol is that the encryption key for each
message depends on the previous message. Each message doubles as an
authenticator for <i class="calibre12">all</i> previous messages. This means that someone can’t replay
an old message; the receiver could never decrypt it. I am impressed with this
idea and expect that it will see wider use once it becomes widely known.</p>

<p class="calibre9">Another clever thing about this protocol is that it enforces correct
implementation. If the application developer doesn’t implement this protocol
correctly, it just won’t work.</p>

<p class="calibre9">Both cards store records of every transaction. When the cards eventually go
online to communicate with the bank — the merchant to deposit his money and
the customer to get more money — the bank uploads these records for auditing
purposes.</p>

<p class="calibre9">Tamperproof hardware prevents either participant from messing with the data;
Alice cannot change the value of her card. Extensive audit trails provide data
to identify and prosecute fraudulent transactions. There are universal secrets in
the cards — MAC keys in the customer cards, functions to convert customer
names to <i class="calibre12">K</i><sub class="calibre15">1</sub> and <i class="calibre12">K</i><sub class="calibre15">2</sub> in the merchant cards — but these are assumed to be
difficult to reverse-engineer.</p>

<p class="calibre9">This scheme is not meant to be perfect, only more secure than either paper
checks or traditional debit cards. The threat of fraud is not from rival
militaries, but from opportunistic customers and merchants. UEPS protects
against that kind of abuse.</p>

<p class="calibre9">The message exchange is an excellent example of a robust protocol: Every
message names both parties, includes unique information to ensure freshness,
and depends explicitly on all the messages that came before it.</p>

<h3 id="24.16" class="calibre7">24.16 Clipper</h3>

<p class="calibre9">The Clipper chip (also known as the MYK-78T) is an NSA-designed,
tamper-resistant VLSI chip designed for encrypting voice conversations; it is
one of the two chips that implements the U.S. government’s Escrowed
Encryption Standard (EES) [<a href="Applied%20Cryptography_split_036.html#r1153" class="calibre5 pcalibre">1153</a>]. VLSI Technologies, Inc. manufactures the
chip, and Mykotronx, Inc. programs it. Initially, the Clipper chip will be
available in the AT&amp;T Model 3600 Telephone Security Device (see
<a href="#24.18" class="calibre5 pcalibre">Section 24.18</a>). The chip implements the Skipjack encryption algorithm (see
<a href="Applied%20Cryptography_split_016.html#13.12" class="calibre5 pcalibre">Section 13.12</a>), an NSA-designed classified secret-key encryption algorithm,
in OFB only.</p>

<p class="calibre9">The most controversial aspect of the Clipper chip, and the entire EES, is the
key-escrow protocol (see <a href="Applied%20Cryptography_split_005.html#4.14" class="calibre5 pcalibre">Section 4.14</a>). Each chip has a special key, not
needed for messages. This key is used to encrypt a copy of each user’s
message key. As part of the synchronization process, the sending Clipper chip
generates and sends a <b class="calibre10">Law Enforcement Access Field</b> (<b class="calibre10">LEAF</b>) to the
receiving Clipper chip. The LEAF contains a copy of the current session key,
encrypted with a special key (called the <b class="calibre10">unit key</b>). This allows a government
eavesdropper to recover the session key, and then recover the plaintext of the
conversation.</p>

<p class="calibre9">According to the director of NIST [<a href="Applied%20Cryptography_split_035.html#r812" class="calibre5 pcalibre">812</a>]:</p>

<p class="quote">A “key-escrow” system is envisioned that would ensure that the
“Clipper Chip” is used to protect the privacy of law-abiding
Americans. Each device containing the chip will have two unique
“keys, ” numbers that will be needed by authorized government
agencies to decode messages encoded by the device. When the
device is manufactured, the two keys would be deposited
separately in two “key-escrow” databases established by the
attorney general. Access to these keys would be limited to
government officials with legal authorization to conduct a
wiretap.</p>

<p class="calibre9">The government also wants to encourage the sale of telephones with these
devices abroad; no one knows what might happen to those key-escrow
databases.</p>

<p class="calibre9">Politics aside, the internal structure of the LEAF is worth discussing [<a href="Applied%20Cryptography_split_035.html#r812" class="calibre5 pcalibre">812</a>,<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>,<a href="Applied%20Cryptography_split_036.html#r1594" class="calibre5 pcalibre">1594</a>,<a href="Applied%20Cryptography_split_035.html#r459" class="calibre5 pcalibre">459</a>,<a href="Applied%20Cryptography_split_035.html#r107" class="calibre5 pcalibre">107</a>,<a href="Applied%20Cryptography_split_035.html#r462" class="calibre5 pcalibre">462</a>]. 
The LEAF is a 128-bit string containing enough
information to allow law enforcement to recover the session key, <i class="calibre12">K<sub class="calibre15">S</sub></i>, assuming
the two <b class="calibre10">escrow agencies</b> in charge of those key-escrow databases cooperate.
The LEAF contains a 32-bit unit identifier, <i class="calibre12">U</i>, unique to the Clipper chip. It
also contains the current 80-bit session key encrypted with the chip’s unique
unit key, <i class="calibre12">K<sub class="calibre15">U</sub></i>, and a 16-bit checksum, <i class="calibre12">C</i>, called an escrow identifier. This checksum is a function of the session key, the IV, and possibly other
information. These three fields are encrypted with a fixed family key, <i class="calibre12">K<sub class="calibre15">F</sub></i>,
shared by all interoperable Clipper chips. The family key, the encryption
modes used, the details of the checksum, and the exact structure of the LEAF
are all secret. It probably looks something like this:</p>

<p class="math"><i class="calibre12">E<sub class="calibre15">K<sub class="calibre16">F</sub></sub></i>(<i class="calibre12">U<sub class="calibre15">K<sub class="calibre16">U</sub></sub></i>(<i class="calibre12">K<sub class="calibre15">S</sub>, C</i>))
</p>

<p class="calibre9"><i class="calibre12">K<sub class="calibre15">U</sub></i> is programmed into Clipper chips at the factory. This key is then split (see <a href="Applied%20Cryptography_split_004.html#3.6" class="calibre5 pcalibre">Section 3.6</a>) and stored in two different key-escrow databases, guarded by two
different escrow agencies.</p>

<p class="calibre9">For Eve to recover <i class="calibre12">K<sub class="calibre15">S</sub></i> from the LEAF, she first has to decrypt the LEAF with
<i class="calibre12">K<sub class="calibre15">F</sub></i> and recover <i class="calibre12">U. </i> Then she has to take a court order to each escrow agency, who each return half of <i class="calibre12">K<sub class="calibre15">U</sub></i> for the given <i class="calibre12">U. </i> Eve XORs the two halves together to recover <i class="calibre12">K<sub class="calibre15">U</sub></i>, then she uses <i class="calibre12">K<sub class="calibre15">U</sub></i> to recover <i class="calibre12">K<sub class="calibre15">S</sub></i>, and <i class="calibre12">K<sub class="calibre15">S</sub></i> to eavesdrop on the conversation.</p>

<p class="calibre9">The checksum is designed to prevent someone from circumventing this
scheme; the receiving Clipper chip won’t decrypt if the checksum doesn’t
check. However, there are only 216 possible checksum values, and a bogus
LEAF with the right checksum but the wrong key can be found in about 42
minutes [<a href="Applied%20Cryptography_split_035.html#r187" class="calibre5 pcalibre">187</a>]. This isn’t much help for Clipper voice conversations. Because
the key exchange protocol is not part of the Clipper chip, the 42-minute
brute-force attack must occur after key exchange; it cannot be done before
making the telephone call. This attack may work for facsimile transmission or
with the Fortezza card (see <a href="#24.17" class="calibre5 pcalibre">Section 24.17</a>).</p>

<p class="calibre9">Supposedly, the Clipper chip will resist reverse-engineering by “a very
sophisticated, well-funded adversary” [<a href="Applied%20Cryptography_split_036.html#r1154" class="calibre5 pcalibre">1154</a>], but rumors are that Sandia
National Laboratories successfully reverse-engineered one. Even if those
rumors aren’t true, I suspect that the largest chip manufacturers in the world
can reverse-engineer Clipper; it’s just a matter of time before someone with
the right combination of resources and ethics comes along.</p>

<p class="calibre9">Enormous privacy issues are associated with this scheme. Numerous civil
liberty advocacy groups are actively campaigning against any key-escrow
mechanism that gives the government the right to eavesdrop on citizens. But
the sneaky thing is that this idea never went through Congress; NIST
published the Escrowed Encryption Standard as a FIPS [<a href="Applied%20Cryptography_split_036.html#r1153" class="calibre5 pcalibre">1153</a>], bypassing that
irritating legislative process. Right now it looks like the EES is dying a slow
and quiet death, but standards have a way of creeping up on you.</p>

<p class="calibre9">Anyway, Table 24.2 lists the different agencies participating in this program.
Anyone want to do a threat analysis on having both escrow agents in the
executive branch? Or on having escrow agents who really don’t know
anything about the wiretap requests, and can do no more than blindly approve
them? Or on having the government impose a secret algorithm as a
commercial standard?</p>

<p id="table-24-2" class="calibre9"><b class="calibre10">Table 24.2 - EES Participating Agencies</b></p>
<hr class="calibre63"/>
<p class="calibre9">
Justice — System Sponsor and Family Key Agent <br class="calibre3"/>
NIST — Program Manager and Escrow Agent <br class="calibre3"/>
FBI — Decrypt User and Family Key Agent <br class="calibre3"/>
Treasury — Escrow Agent <br class="calibre3"/>
NSA — Program Developer
</p>

<hr class="calibre63"/>

<p class="calibre9">In any case, implementing Clipper raises enough problems to question its
value in court. Remember, Clipper only works in OFB mode. Despite what
you may have been told to the contrary, this does not provide integrity or
authentication. Imagine that Alice is on trial, and a Clipper-encrypted
telephone call is part of the evidence. Alice claims that she never made the
call; the voice is not hers. The phone’s compression algorithm is so bad that it
is hard to recognize Alice’s voice, but the prosecution argues that since only
Alice’s escrowed key will decipher the call it must have been made from her
telephone.</p>

<p class="calibre9">Alice argues that the call was forged like so [<a href="Applied%20Cryptography_split_036.html#r984" class="calibre5 pcalibre">984</a>,<a href="Applied%20Cryptography_split_036.html#r1339" class="calibre5 pcalibre">1339</a>]: Given the ciphertext
and the plaintext, it is possible to XOR them to get the keystream. This
keystream can then be XORed with an entirely different plaintext to form a
forged ciphertext, which can then be converted to forged plaintext when fed
into the Clipper decryptor. True or not, this argument could easily put enough
doubt in a jury’s mind to disregard the telephone call as evidence.</p>

<p class="calibre9">Another attack, called the Squeeze attack, allows Alice to frame Bob. Here’s
how [<a href="Applied%20Cryptography_split_035.html#r575" class="calibre5 pcalibre">575</a>]: Alice calls Bob using Clipper. She saves a copy of his LEAF as
well as the session key. Then, she calls Carol (who she knows is being
wiretapped). During the key setup, Alice forces the session key to be identical
to the one she used with Bob; this requires hacking the phone, but it is not
hard. Then, instead of sending her LEAF she sends Bob’s. It’s a valid LEAF,
so Carol’s phone will not notice. Now she can say whatever she wants to
Carol; when the police decrypt the LEAF, they will find that it is Bob’s. Even
if Bob wasn’t framed by Alice, the mere fact that he can claim this in court
undermines the purpose of the scheme.</p>

<p class="calibre9">The law enforcement authorities of the United States should not be in the
business of collecting information in criminal investigations that is useless in
court. Even if key escrow were a good idea, Clipper is a bad way of
implementing it.</p>

<h3 id="24.17" class="calibre7">24.17 Capstone</h3>

<p class="calibre9">Capstone (also known as the MYK-80) is the other NSA-developed VLSI
cryptographic chip that implements the U.S. government’s Escrowed
Encryption Standard [<a href="Applied%20Cryptography_split_036.html#r1153" class="calibre5 pcalibre">1153</a>]. Capstone includes the following functions [<a href="Applied%20Cryptography_split_036.html#r1155" class="calibre5 pcalibre">1155</a>,<a href="Applied%20Cryptography_split_035.html#r462" class="calibre5 pcalibre">462</a>]:</p>


<ul class="calibre13">

<li class="calibre14">The Skipjack algorithm in any of the four basic modes: ECB, CBC,
CFB, and OFB.
</li>
<li class="calibre14">A public-key Key Exchange Algorithm (KEA), probably
Diffie-Hellman.
</li>
<li class="calibre14">The Digital Signature Algorithm (DSA).
</li>
<li class="calibre14">The Secure Hash Algorithm (SHA).
</li>
<li class="calibre14">A general purpose exponentiation algorithm.
</li>
<li class="calibre14">A general purpose, random-number generator that uses a pure noise
source.
</li>

</ul>

<p class="calibre9">Capstone provides the cryptographic functionality needed for secure electronic
commerce and other computer-based applications. The first application of
Capstone is in a PCMCIA card called Fortezza. (It was originally called
Tessera until a company called Tessera, Inc. complained.)</p>

<p class="calibre9">NSA had considered lengthening Capstone’s LEAF checksum in production
versions for use in Fortezza cards, in order to foil the brute-force attack against
the LEAF previously discussed. Instead, they added a feature that reset the
card after 10 incorrect LEAFs. This only increases the time required to find a
fake but valid LEAF by 10 percent, to 46 minutes. I am not impressed.</p>

<h3 id="24.18" class="calibre7">24.18 AT&amp;T Model 3600 Telephone Security Device (TSD)</h3>

<p class="calibre9">The AT&amp;T Telephone Security Device (TSD) is the Clipper phone.
Actually, there are four models of the TSD. One contains the Clipper chip,
another contains an exportable proprietary AT&amp;T encryption algorithm,
the third contains a proprietary algorithm for domestic use plus the exportable
algorithm, and the fourth contains the Clipper, domestic, and exportable
algorithms.</p>

<p class="calibre9">TSDs use a different session key for each telephone call. A pair of TSDs
generate a session key using Diffie-Hellman key exchange, independent of the
Clipper chip. Since Diffie-Hellman incorporates no authentication, the TSD
has two methods to thwart a man-in-the-middle attack.</p>

<p class="calibre9">The first is a screen. The TSD hashes the session key and displays that hash on
a small screen as four Hex digits. The conversants should confirm that their
screens show the same digits. The voice quality is good enough that they can
recognize each other’s voice.</p>

<p class="calibre9">Eve still has a possible attack. Imagine her in the middle of Alice and Bob’s
conversation. She uses one TSD on the line with Alice and a modified TSD on
the line with Bob; in the middle she bridges the two phone calls. Alice tries to
go secure. She generates a key as normal, except that Eve is acting as Bob. Eve
recovers the key, and using the modified TSD, forces the key she generates
with Bob to have the same hash value. This attack may not sound very likely,
but the TSD uses a variant of the interlock protocol to prevent it.</p>

<p class="calibre9">The TSD generates random numbers using a noise source and a chaotic
amplifier with digital feedback. This generates a bit stream, which is fed
through a post-whitening filter using the digital signal processor.</p>

<p class="calibre9">Despite all of this, the TSD manual does not mention security at all. In fact, it
says [<a href="Applied%20Cryptography_split_035.html#r70" class="calibre5 pcalibre">70</a>]:</p>

<p class="quote">AT&amp;T makes no warranty that the TSD will prevent
cryptanalytic attack on any encrypted transmission by any
government agency, its agents, or any third party. Furthermore,
AT&amp;T makes no warranty that the TSD will prevent any
attack on any communication by methods which bypass
encryption.</p>

<div class="calibre6" id="calibre_pb_56"></div>
</div>






</body></html>
